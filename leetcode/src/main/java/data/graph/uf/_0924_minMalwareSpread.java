package data.graph.uf;

import java.util.Arrays;

/**
 * @BelongsProject: codes
 * @BelongsPackage: data.graph.uf
 * @Author: xuyifang
 * @CreateTime: 2021-08-30 15:39
 * @Description:
 */
public class _0924_minMalwareSpread {

    public int minMalwareSpread(int[][] mat, int[] initial) {
        Arrays.sort(initial);

        int N = mat.length;
        UnionFind uf = new UnionFind(N);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (mat[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }

        int[] count = new int[N];
        for (int i : initial) {
            count[uf.find(i)]++;
        }

        int maxCCSize = Integer.MIN_VALUE;          // Connected Component 连通分量
        int index = initial[0];
        for (int i : initial) {
            int root = uf.find(i);
            if (count[root] == 1 && uf.size[root] > maxCCSize) {
                maxCCSize = uf.size[root];
                index = i;
            }
        }
        return index;
    }

    class UnionFind {
        int count;      // 连通分量个数
        int[] parent;   // 节点i的父节点是parent[i]
        int[] size;

        public UnionFind(int N) {
            this.count = N;         // n为图的节点总数
            parent = new int[N];
            size = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;      // 父节点指针初始指向自己
                size[i] = 1;
            }
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return;
            }
            size[rootY] += size[rootX];
            parent[rootX] = rootY;          // x成为y的子树
            count--;
        }

        public int find(int x) {
            if (x != parent[x]) {
                size[find(parent[x])] += size[parent[x]];
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
    }
}
