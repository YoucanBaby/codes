[toc]

# 数据结构

## 数组与矩阵

### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

### 4. 二维数组中的查找

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210814172853.png" alt="image-20210814172852976" style="zoom:80%;" />

思路：从**右上角**开始搜索。

时间：$O(M + N)$，其中 M 为行数，N 为 列数。

<img src="https://camo.githubusercontent.com/9bbc6e61a30a135426de546d99f97eda04ca0a3065f0d6b5e6b36e7fce658b16/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33356138633731312d306463302d343631332d393566332d6265393663366336653130342e676966" alt="img" style="zoom: 67%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610212509766.png" alt="image-20210610212509766" style="zoom: 67%;" />

```java
public boolean findNumberIn2DArray(int[][] mat, int target) {
    if (mat.length == 0) {
        return false;
    }
    int M = mat.length;
    int N = mat[0].length;
    int x = 0;
    int y = N - 1;

    while (x < M && y >= 0) {
        if (mat[x][y] == target) {
            return true;
        } else if (mat[x][y] > target) {
            y--;
        } else {
            x++;
        }
    }
    return false;
}
}
```

### 5. 替换空格

https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/

**题目描述**

将一个字符串中的空格替换成 "%20"。

```java
Input:
"A B"

Output:
"A%20B"
```

**解题思路**

使用 StringBuilder

```java
// 我自己的方法
public String replaceSpace1(String s) {
    StringBuilder str = new StringBuilder();
    for (int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if (c == ' '){
            str.append("%20");
        } else {
            str.append(c);
        }
    }
    return str.toString();
}
```

### 29. 顺时针打印矩阵

不会

https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/

**题目描述**

按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210610220444306.png" alt="image-20210610220444306" style="zoom:67%;" />

要求：时间复杂度：O(mn)，空间复杂度：O(1)。

**解题思路**

一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 **r1, r2, c1, c2** 分别存储**上下左右边界值**，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行->从上到下打印最右一行->从右到左打印最下一行->从下到上打印最左一行。应当注意**只有在 r1 != r2 时才打印最下一行**，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。**只有在 c1 != c2 时才打印最左一行**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610223817470.png" alt="image-20210610223817470" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610223919259.png" alt="image-20210610223919259" style="zoom: 67%;" />

```java
public int[] spiralOrder(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return new int[0];
    int rows = matrix.length;
    int cols = matrix[0].length;
    int c1 = 0;
    int c2 = cols - 1;
    int r1 = 0;
    int r2 = rows - 1;

    int[] ret = new int[rows * cols];
    int index = 0;      // 记录ret的下标

    while(r1 <= r2 && c1 <= c2) {
        // 上
        for (int i = c1; i <= c2; i++)
            ret[index++] = matrix[r1][i];
        // 右
        for (int i = r1 + 1; i <= r2; i++)
            ret[index++] = matrix[i][c2];
        // 下
        if (r1 != r2)
            for (int i = c2 - 1; i >= c1; i--)
                ret[index++] = matrix[r2][i];
        // 左
        if (c1 != c2)
            for (int i = r2 - 1; i >= r1 + 1; i--)
                ret[index++] = matrix[i][c1];
        r1++;
        r2--;
        c1++;
        c2--;
    }
    return ret;
}
```

### 50. 第一个只出现一次的字符位置

https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/

**题目描述**

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。

```java
Input: abacc
Output: b
```

**解题思路**

解法1：使用 **HashMap** 统计出现次数

```java
public char firstUniqChar(String s) {
    int N = s.length();
    HashMap<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < N; i++) {
        char c = s.charAt(i);
        if (map.containsKey(c)) {
            map.put(c, map.get(c) + 1);
        } else {
            map.put(c, 1);
        }
    }
    for (int i = 0; i < N; i++) {
        char c = s.charAt(i);
        if (map.get(c) == 1)
            return c;
    }
    return ' ';
}
```

解法2：使用 **数组** 统计出现次数（最优解）

```java
public char firstUniqChar(String s) {
    int N = s.length();
    int[] countArr = new int[128];

    for (int i = 0; i < N; i++) {
        char c = s.charAt(i);
        countArr[c]++;
    }
    for (int i = 0; i < N; i++) {
        char c = s.charAt(i);
        if (countArr[c] == 1)
            return c;
    }
    return ' ';
}
```

解法3：使用 `s.indexOf(c)` 和 `s.lastIndexOf(c)`，并标记首次出现字母的位置 `firstIndex`

```java
public char firstUniqChar(String s) {
    int N = s.length();
    int firstIndex = s.length();		// 并标记首次出现字母的位置
    for (char c = 'a'; c <= 'z'; c++) {
        if (s.indexOf(c) >= 0 && s.indexOf(c) == s.lastIndexOf(c)) {
            if (firstIndex > s.indexOf(c)) {
                firstIndex = s.indexOf(c);
            }
        }
    }

    if (firstIndex < N)
        return s.charAt(firstIndex);
    else
        return ' ';
}
```

## 栈和队列

### [09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

不会

思路：维护两个栈：stack1 和 stack2，分别用于插入和删除。第二个栈维护待删除的元素，在执行删除操作的时候，首先检查第二个栈是否为空。如果为空，我们将第一个栈里的元素都出栈，然后入栈入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。

```java
class CQueue {

    Deque<Integer> stack1;
    Deque<Integer> stack2;

    public CQueue() {
        stack1 = new LinkedList<Integer>();
        stack2 = new LinkedList<Integer>();
    }

    public void appendTail(int value) {
        stack1.addFirst(value);
    }

    public int deleteHead() {
        // 如果stack2为空，则把stack1都弹出去，弹给stack2
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.addFirst(stack1.removeFirst());
            }
        }
        // 如果stack2还是空，则说明队列为空，返回-1
        if (stack2.isEmpty()) {
            return -1;
        } else {
            return stack2.removeFirst();
        }
    }
}

```

### [30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

不会

思路：设计一个辅助栈 minStack，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

```java
class MinStack {

    Deque<Integer> stack;
    Deque<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
    }

    public void push(int val) {
        int min = 0;
        if (stack.isEmpty()) {
            min = val;
        } else {
            min = Math.min(val, minStack.getFirst());
        }
        minStack.addFirst(min);
        stack.addFirst(val);
    }

    public void pop() {
        stack.removeFirst();
        minStack.removeFirst();
    }

    public int top() {
        return stack.getFirst();
    }

    public int getMin() {
        return minStack.getFirst();
    }
}
```

### [31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

不会

思路：辅助栈。新建一个栈用于压入序列入栈。如果 “栈顶元素 == 弹出序列的当前元素” ，就执行出栈，上述操作应该反复执行。最后如果栈为空，则说明弹出序列合法

算法：

* 实例化栈stack
* 遍历压入序列：
  * 压入序列元素入栈
  * 如果栈非空，并且 “栈顶元素 == 弹出序列的当前元素” ，就出执行出栈
* 如果栈为空，则说明弹出序列合法

```java
public boolean validateStackSequences(int[] pushed, int[] popped) {
    Deque<Integer> stack = new LinkedList<>();
    int i = 0;

    for (int num: pushed) {
        stack.addFirst(num);
        while (!stack.isEmpty() && stack.getFirst() == popped[i]) {
            stack.removeFirst();
            i++;
        }
    }

    if (stack.isEmpty()) {
        return true;
    } else {
        return false;
    }
}
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210616063136701.png" alt="image-20210616063136701" style="zoom:80%;" />

### [40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210808074746.png" alt="image-20210808074746611" style="zoom:80%;" />

思路：快排变形。

* 时间：$O(N)$

* 空间：$O(logN)$

```java
class Solution {
    public int[] getLeastNumbers(int[] nums, int k) {
        if (k == 0) {
            return new int[0];
        }
        return quickSort(nums, k - 1, 0, nums.length - 1);
    }

    public int[] quickSort(int[] nums, int k, int left, int right) {
        int mid = partition(nums, left, right);
        if (mid == k) {
            return Arrays.copyOfRange(nums, 0, k + 1);
        } else if (mid < k) {
            return quickSort(nums, k, mid + 1, right);
        } else {
            return quickSort(nums, k, left, mid - 1);
        }
    }

    private int partition(int[] nums, int left, int right) {
        int p1 = left;
        int p2 = right;
        int pivot = nums[right];
        while (p1 < p2) {
            while (p1 < p2 && nums[p1] <= pivot) {
                p1++;
            }
            while (p1 < p2 && nums[p2] >= pivot) {
                p2--;
            }
            swap(nums, p1, p2);
        }
        swap(nums, p1, right);
        return p1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### [59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210816162842.png" alt="image-20210816162842756" style="zoom:80%;" />

* 思路：单调队列。左边是队尾（最大），右边是队首（最小）。

```java
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]

解释过程中队列中都是具体的值，方便理解，具体见代码。
初始状态：L=R=0,队列:{}
i=0,nums[0]=1。队列为空,直接加入。队列：{1}
i=1,nums[1]=3。队尾值为1，3>1，弹出队尾值，加入3。队列：{3}
i=2,nums[2]=-1。队尾值为3，-1<3，直接加入。队列：{3,-1}。此时窗口已经形成，L=0,R=2，result=[3]
i=3,nums[3]=-3。队尾值为-1，-3<-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]
i=4,nums[4]=5。队尾值为-3，5>-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]
i=5,nums[5]=3。队尾值为5，3<5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]
i=6,nums[6]=6。队尾值为3，6>3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]
i=7,nums[7]=7。队尾值为6，7>6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]
```

代码：

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums.length <= 1) {
        return nums;
    }

    int N = nums.length;
    Deque<Integer> deque = new ArrayDeque<>();      // 左边是队尾（最大），右边是队首（最小）
    int[] res = new int[N - k + 1];

    for (int right = 0; right < N; right++) {
        int left = right - k + 1;
        // 删除不在窗口内的元素
        if (!deque.isEmpty() && deque.getFirst() <= left - 1) {
            deque.removeFirst();
        }
        // 弹出前面小的数，保证队尾最大，队首最小
        while (!deque.isEmpty() && nums[deque.getLast()] <= nums[right]) {
            deque.removeLast();
        }
        deque.addLast(right);
        // 窗口形成之后（即窗口长度为k之后），保存窗口的最大值
        if (left >= 0) {
            res[left] = nums[deque.getFirst()];
        }
    }
    return res;
}
```

* 时间：O(N)

* 空间：O(k)

### [59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

思路1：暴力。直接遍历找最大值。

```java
class MaxQueue {

    Deque<Integer> deque;

    public MaxQueue() {
        deque = new ArrayDeque<>();
    }

    public int max_value() {
        int N = deque.size();
        int max = -1;
        for (int i = 0; i < N; i++) {
            int temp = deque.removeFirst();
            max = Math.max(max,temp);
            deque.addLast(temp);
        }
        return max;
    }

    public void push_back(int value) {
        deque.addLast(value);
    }

    public int pop_front() {
        if (deque.isEmpty()) {
            return -1;
        } else {
            return deque.removeFirst();
        }
    }
}
```

思路2：**辅助队列**。使用**双端队列存放最大值**。（最优解）。只有当 dequeMax 队首的元素和 deque 队首的元素相等时，dequeMax 才出队列，不然 dequeMax.getFirst 即可。

<img src="https://pic.leetcode-cn.com/9d038fc9bca6db656f81853d49caccae358a5630589df304fc24d8999777df98-fig3.gif" alt="fig3.gif" style="zoom: 50%;" />

```java
class MaxQueue {

    Deque<Integer> deque;
    Deque<Integer> dequeMax;

    public MaxQueue() {
        deque = new ArrayDeque<>();
        dequeMax = new ArrayDeque<>();
    }

    public int max_value() {
        if (dequeMax.isEmpty()) {
            return -1;
        } else {
            return dequeMax.getFirst();
        }
    }

    public void push_back(int value) {
        while (!dequeMax.isEmpty() && dequeMax.getLast() < value) {
            dequeMax.removeLast();
        }
        dequeMax.addLast(value);
        deque.addLast(value);
    }

    public int pop_front() {
        if (deque.isEmpty()) {
            return -1;
        } else {
            // 当Integer大于127之后，需要使用equals()，而不能使用==
            if (deque.getFirst().equals(dequeMax.getFirst())) {
                dequeMax.removeFirst();
            }
            return deque.removeFirst();
        }
    }
}
```

## 堆

### [41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210811095657.png" alt="image-20210811095657590" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210811095640.png" alt="image-20210811095640503" style="zoom:80%;" />

思路：**大根堆 + 小根堆**。大根堆对应左边数组，小根堆对应右边数组。如果两个堆的大小为奇数，保证 大根堆大小 = 小根堆大小 + 1。

```java
class MedianFinder {
    PriorityQueue<Integer> maxPQ;
    PriorityQueue<Integer> minPQ;
    int size;

    public MedianFinder() {
        maxPQ = new PriorityQueue<>((o1, o2) -> o2 - o1);
        minPQ = new PriorityQueue<>();
        size = 0;
    }

    public void addNum(int num) {
        size += 1;
        maxPQ.add(num);
        minPQ.add(maxPQ.remove());
        if ((size & 1) == 1) {
            maxPQ.add(minPQ.remove());
        }
    }

    public double findMedian() {
        if ((size & 1) == 0) {
            return (double) (maxPQ.peek() + minPQ.peek()) / 2;
        } else {
            return maxPQ.peek();
        }
    }
}
```

## 链表

### [06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210819204447.png" alt="image-20210819204447091" style="zoom:80%;" />

思路：统计链表长度，创建结果数组。把链表上的值倒序放入数组中。

```java
public int[] reversePrint(ListNode head) {
    int N = 0;
    for (ListNode cur = head; cur != null; cur = cur.next) {
        N++;
    }

    int[] res = new int[N];
    ListNode cur = head;
    for (int i = N - 1; i >= 0; i--) {
        res[i] = cur.val;
        cur = cur.next;
    }
    return res;
}
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)

### [18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```java
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
    
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

思路：定义一个 pre 在 cur 之前，找到需要删除的值，令 pre.next = cur.next

```java
public ListNode deleteNode(ListNode head, int val) {
    if (head.val == val) {
        return head.next;
    }

    ListNode cur = head;
    ListNode pre = head;

    while (cur.val != val) {
        pre = cur;
        cur = cur.next;
    }

    pre.next = cur.next;
    return head;
}
```

* 时间复杂度：O(N)
* 空间复杂度：O(1)

### [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210818214428.png" alt="image-20210818214428060" style="zoom:80%;" />

思路：快慢指针。时间：$O(N)$ ；空间：$O(1)$

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode slow = head;
    ListNode fast = head;

    for (int i = 0; i < k; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```

### [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

画个图就会了！

```java
public ListNode reverseList(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;

    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)

### [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

新建一个头节点 head，l1 和 l2 哪个节点小，就把哪个节点添加到 cur 后面，最后返回 head.next

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode cur1 = l1;
    ListNode cur2 = l2;
    ListNode head = new ListNode(0);
    ListNode cur = head;

    while (cur1 != null && cur2 != null) {
        if (cur1.val < cur2.val) {
            cur.next = cur1;
            cur1 = cur1.next;
        } else {
            cur.next = cur2;
            cur2 = cur2.next;
        }
        cur = cur.next;
    }

    if (cur1 != null) {
        cur.next = cur1;
    }

    if (cur2 != null) {
        cur.next = cur2;
    }

    return head.next;
}
```

* 时间复杂度 O(M+N)：M和N分别是两个链表的长度
* 空间复杂度 O(1)

### [35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

不会

题解：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/

思路1：**哈希表**。哈希表存储 [原节点：新节点] 键值对。遍历原链表，构建新链表。

```java
public Node copyRandomList(Node head) {
    if (head == null)
        return null;

    Map<Node, Node> map = new HashMap<>();
    Node cur = head;
	
    // 哈希表存储 [原节点：新节点] 键值对
    while (cur != null) {
        map.put(cur, new Node(cur.val));
        cur = cur.next;
    }
	
    // 遍历原链表，构建新链表。
    cur = head;
    while (cur != null) {
        map.get(cur).next = map.get(cur.next);
        map.get(cur).random = map.get(cur.random);
        cur = cur.next;
    }
    return map.get(head);
}
```

- **时间复杂度 O(N)：** 两轮遍历链表，使用 O(N) 时间。
- **空间复杂度 O(N)：** 哈希表 `dic` 使用线性大小的额外空间。

思路2：**拼接 + 拆分**。构建 <font color='cornflowerblue'>原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> ……</font> 的拼接链表，在访问原节点的 random 指向节点的同时找到新节点的 random 指向节点。

* **复制各节点，构建拼接链表:**
* **构建新链表各节点的 `random` 指向：**
* **拆分原 / 新链表：**

```java
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }

    // 复制节点，构建新链表
    Node cur = head;
    while (cur != null) {
        Node temp = cur.next;
        cur.next = new Node(cur.val);
        cur.next.next = temp;
        cur = cur.next.next;
    }

    // 构建新链表各节点的 random
    cur = head;
    while (cur != null) {
        if (cur.random != null) {
            cur.next.random = cur.random.next;
        }
        cur = cur.next.next;
    }

    // 拆分原 / 新链表
    cur = head.next;
    Node pre = head;
    Node ret = head.next;
    while (cur.next != null) {
        pre.next = cur.next;
        cur.next = cur.next.next;
        pre = pre.next;
        cur = cur.next;
    }
    pre.next = null;
    return ret;
}
```

- **时间复杂度 O(N) ：** 三轮遍历链表，使用 O(N) 时间。
- **空间复杂度 O(1) ：** 节点引用变量使用常数大小的额外空间。

### [52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210721010432.gif" alt="剑指 Offer 52. 两个链表的第一个公共节点" style="zoom: 50%;" />

思路：**双指针**。使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点。然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode node1 = headA;
    ListNode node2 = headB;

    while (node1 != node2) {
        if (node1 == null) {
            node1 = headB;
        } else {
            node1 = node1.next;
        }
        if (node2 == null) {
            node2 = headA;
        } else {
            node2 = node2.next;
        }
    }
    return node1;
}
```

* 时间：O(N+M)
* 空间：O(1)

## 二叉树

### [07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

### [26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

### [27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

### [28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

### [32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

### [ 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

### [32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

思路：在上题的基础上，加一个 `boolean flag`。如果 flag 为 true，则从左向右打印；如果 flag 为 false，则从右向左打印。每次把这一层的数据加入到结果以后，`flag = !flag`。

### [33. 验证二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823120557.png" alt="image-20210823120557334" style="zoom:80%;" />

不会 * 2

时间：$O(N)$，空间：$O(N)$

思路：单调栈，栈顶最小，栈底最大，栈底是根节点。**倒序的后序遍历**遍历数组，即按照**根右左**的顺序遍历。所以数组需要逆序遍历。根节点的左子树都比它小，右子树都比它大，在遍历左子树的时候，出现了比根节点大的值，说明这不是二叉搜索树的后序遍历。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823134235.gif" alt="剑指 Offer 33. 二叉搜索树的后序遍历序列" style="zoom: 50%;" />

```java
public boolean verifyPostorder(int[] postorder) {
    Deque<Integer> stack = new ArrayDeque<>();      // 右边是栈顶
    int root = Integer.MAX_VALUE;
    for (int i = postorder.length - 1; i >= 0; i--) {
        if (postorder[i] > root) {
            return false;
        }
        while (!stack.isEmpty() && stack.getLast() > postorder[i]) {
            root = stack.removeLast();
        }
        stack.addLast(postorder[i]);
    }
    return true;
}
```

### [36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

### [37. 二叉树的序列化和反序列化](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

思路：BFS和反BFS。

### [54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823144427.png" alt="image-20210823144427846" style="zoom:80%;" />

不会 * 2

思路：**倒序的中序遍历**。`res` 和 `k` 是全局变量。

```java
class Solution {
    int res;
    int k;

    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return res;
    }

    public void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        dfs(root.right);
        k--;
        if (k == 0) {
            res = root.val;
            return;
        }
        dfs(root.left);
    }
}
```

### [55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

### [55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

### [68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

### [68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

# 算法

## 双指针/快慢指针/滑动窗口

### [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210819205934.png" alt="image-20210819205934102" style="zoom:80%;" />

思路：双指针。从左向右找偶数，从右向左找奇数，交换它们，直到两个指针相遇。

```java
class Solution {
    public int[] exchange(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            while (left < right && (nums[left] & 1) == 1) {
                left++;
            }
            while (left < right && (nums[right] & 1) == 0) {
                right--;
            }
            swap(nums, left, right);
        }
        return nums;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### [48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210816144057.png" alt="image-20210816144057061" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210816144106.png" alt="image-20210816144106641" style="zoom:80%;" />

思路：**滑动窗口 + 哈希表**。

```java
public int lengthOfLongestSubstring(String s) {
    if (s.length() <= 1) {
        return s.length();
    }

    Set<Character> set = new HashSet<>();
    int res = 0;
    int left = 0;
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        while (!set.isEmpty() && set.contains(c)) {
            set.remove(s.charAt(left));
            left++;
        }
        set.add(s.charAt(right));
        res = Math.max(res, set.size());
    }
    return res;
}
```

### [57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210814181954.png" alt="image-20210814181954397" style="zoom:80%;" />

```java
public int[] twoSum(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        if (nums[left] + nums[right] == target) {
            return new int[] {nums[left], nums[right]};
        } else if (nums[left] + nums[right] < target) {
            left++;
        } else {
            right--;
        }
    }
    return new int[0];
}
```

### [57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210819094221.png" alt="image-20210819094221871" style="zoom:80%;" />

思路：**滑动窗口**。注意是**连续**的正数序列。

```java
public int[][] findContinuousSequence(int target) {
    List<int[]> res = new ArrayList<>();
    int sum = 0;

    int left = 1;
    for (int right = 1; right < target; right++) {
        sum += right;
        while (sum > target) {
            sum -= left;
            left++;
        }
        if (sum == target) {
            int[] temp = new int[right - left + 1];
            for (int i = left; i <= right; i++) {
                temp[i - left] = i;
            }
            res.add(temp);
        }
    }
    return res.toArray(new int[0][0]);
}
```

### [58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210819195602.png" alt="image-20210819195601965" style="zoom:80%;" />

```java
public String reverseWords(String s) {
    s = s.trim();       				// 删除首尾空格
    String[] strs = s.split(" ");    	// 以空格分割字符串s
    StringBuilder sb = new StringBuilder();

    for (String str : strs) {
        if (str.equals("")) {			// 遇到空字符串就跳过
            continue;
        } else {
            sb.insert(0, " ");
            sb.insert(0, str);
        }
    }
    return sb.toString().trim();		// 最后删除首位的空格
}
```

### [58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210820155252.png" alt="image-20210820155252139" style="zoom:80%;" />

```java
public String reverseLeftWords(String s, int k) {
    int N = s.length();
    k %= N;

    String str1 = s.substring(0, k);
    String str2 = s.substring(k, N);

    return str2 + str1;
}
```

## 二分查找

### [11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210813193455.png" alt="image-20210813193455499" style="zoom:80%;" />

如下图所示，寻找旋转数组的最小元素即为寻找 **右排序数组** 的首个元素 nums[x] ，称 x 为 **旋转点** 。

<img src="https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png" alt="Picture1.png" style="zoom:33%;" />

思路：二分查找。假设左指针left 和 右指针right，分别指向数组左边和右边；在两指针的中间的指针 mid，会出现以下情况：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210727233256.png" alt="image-20210727233255910" style="zoom:67%;" />

1. `nums[mid] < nums[right]`：分界点在 mid 的左边
2. `nums[mid] > nums[right]`：分界点在 mid 的右边
3. `nums[mid] == nums[right]`：出现了重复的元素，需要删除最右边的元素

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210727234129.gif" alt="剑指 Offer 11. 旋转数组的最小数字" style="zoom: 50%;" />

```java
public int minArray(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] < nums[right]) {
            right = mid;
        } else if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right--;
        }
    }
    return nums[left];
}
```

### [53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

思路：分别二分查找 `target` 和 `target - 1` 的右边界，将两结果相减并返回即可。

```java
class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums, target) - binarySearch(nums, target - 1);
    }
	
    // 这里只能写这种二分查找
    public int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```

### [53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

思路：排序数组中的搜索问题，首先想到 **二分法** 解决。

* 根据题意，数组可以按照以下规则划分为两部分：
  * **左子数组：** `nums[i] = i` 
  * **右子数组：**` nums[i] != i` ；
* 缺失的数字等于 **“右子数组的首位元素”** 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。

<img src="https://pic.leetcode-cn.com/df7e04fbab0937ff74e5f29e958c7b1d531af066789ff363be5e1c8e75f17f56-Picture1.png" alt="Picture1.png" style="zoom:50%;" />

```java
public int missingNumber(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == mid) {
            left = mid + 1;
        } else if (nums[mid] > mid) {
            right = mid - 1;
        }
    }
    return left;
}
```

## 排序

### [45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

不会

思路：使用比较器

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210620140240049.png" alt="image-20210620140240049" style="zoom: 80%;" />

* 把 int[] nums 转为 String[] strs
* 对 strs 排序，使用比较器，`(o1 + o2).compareTo(o2 + o1)`
* 使用sb把排序后的结果加起来

```java
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];

    for (int i = 0; i < nums.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }

    Arrays.sort(strs, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            return (o1 + o2).compareTo(o2 + o1);
        }
    });

    StringBuilder sb = new StringBuilder();
    for (String str: strs) {
        sb.append(str);
    }
    return sb.toString();
}
```

### [51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210808230509.png" alt="image-20210808230509391" style="zoom:80%;" />

思路：归并排序。在归并排序的时候，**如果右边比左边小，count 就加上左边剩余元素的个数**（mid + 1 - p1）

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210620161734563.png" alt="image-20210620161734563" style="zoom:80%;" />

```java
class Solution {
    int count = 0;    // 用于计数

    public int reversePairs(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return count;
    }

    public void mergeSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int mid = (left + right) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, right, mid);
    }

    public void merge(int[] nums, int left, int right, int mid) {
        int[] temp = new int[right - left + 1];
        int p1 = left;
        int p2 = mid + 1;
        int i = 0;

        while (p1 <= mid && p2 <= right) {
            if (nums[p1] <= nums[p2]) {
                temp[i++] = nums[p1++];
            } else {
                temp[i++] = nums[p2++];
                count += mid + 1 - p1;      // count加上左边剩余元素的个数
            }
        }
        while (p1 <= mid) {
            temp[i++] = nums[p1++];
        }
        while (p2 <= right) {
            temp[i++] = nums[p2++];
        }
        for (int j = 0; j < temp.length; j++) {
            nums[left + j] = temp[j];
        }
    }
}
```

### [61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210810175546.png" alt="image-20210810175546331" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210810175606.png" alt="image-20210810175606008" style="zoom:80%;" />

思路：排序，统计大小王个数，遇到重复的数字就构不成顺子（除了大小王以外）。

```java
public boolean isStraight(int[] nums) {
    Arrays.sort(nums);
    int joker = 0;
    for (int i = 0; i < 4; i++) {
        if (nums[i] == 0) {
            joker++;
        } else if (nums[i] == nums[i + 1]) {
            return false;
        }
    }
    return nums[4] - nums[joker] < 5;       // 最大牌 - 最小牌 < 5，可构成顺子
}
```

## DFS暴搜

### [13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

思路：**DFS + FloodFill**（只有下方和右方两个方向 ）

求数位之和：

```java
public int sum(int x) {
    int res = 0;
    while (x != 0) {
        res += x % 10;
        x /= 10;
    }
    return res;
}
```

`dfs`：

* 如果越界、位数和大于k、已经访问过这个节点了，就返回。
* 只需要递归下方和右方

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210729201623.gif" alt="剑指 Offer 13. 机器人的运动范围" style="zoom: 50%;" />

```java
class Solution {
    int M, N, k;
    boolean[][] visited;

    public int movingCount(int M, int N, int k) {
        this.M = M;
        this.N = N;
        this.k = k;
        this.visited = new boolean[M][N];

        return dfs(0,0,0,0);
    }

    public int dfs(int x, int y, int sumX, int sumY) {
        // 如果越界、位数和大于k、已经访问过这个节点了，就返回
        if (x >= M || y >= N || k < sumX + sumY || visited[x][y]) {
            return 0;
        }
        visited[x][y] = true;
        // 递归下方和右方
        int a = dfs(x + 1, y, sum(x + 1), sumY);
        int b = dfs(x, y + 1, sumX, sum(y + 1));
        return 1 + a + b;
    }

    // 求数位之和
    public int sum(int x) {
        int res = 0;
        while (x != 0) {
            res += x % 10;
            x /= 10;
        }
        return res;
    }
}
```









### [16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

不会

1. 如果 `n == Integer.MIN_VALUE` 进行特殊值判断：
   1. 如果 `x == 1 || x == -1`，返回 -1；反之返回 0
2. 如果 `n == 0`，返回 1
3. 如果 `n < 0` ，返回 $1/x^{-n}$
4. 如果 n 为奇数，返回 $x * x^{n-1}$
5. 如果 n 为偶数，返回 $x^{2 * (n / 2)}$

```java
public double myPow(double x, int n) {
    if (n == Integer.MIN_VALUE) {
        if (x == 1 || x == -1) {
            return 1;
        } else {
            return 0;
        }
    }
    if (n == 0) {
        return 1;
    } else if (n < 0) {
        return myPow(1 / x, -n);
    } else if (n % 2 == 0) {
        return myPow(x * x, n / 2);
    } else {
        return x * myPow(x, n - 1);
    }
}
```

* 时间复杂度：O(logN)
* 空间复杂度：O(logN)

思路2：**迭代快速幂**。

假设除法是“**向下取整**”的，则：

$x^n = (x^{2})^{n/2}, n为偶数$

$x^n = x(x^{2})^{n/2}, n为奇数$

<img src="https://pic.leetcode-cn.com/40a7a874523e26cacae9c502a6e8cf8b58dba878739f17e6bb3ed6be76e97569-Picture1.png" alt="Picture1.png" style="zoom:50%;" />

**位运算**：

* **向下整除** `n / 2` 等价于 **右移一位** `n >> 1`；
* **判断奇数** `n % 2 == 1` 等价于 **判断二进制最右位** `(n & 1) == 1` ；

**算法流程**：

1. 如果 `n == Integer.MIN_VALUE` 进行特殊值判断：
   1. 如果 `x == 1 || x == -1`，返回 -1；反之返回 0
2. 如果 `n < 0` ，`x = 1 /x`， `n = -n`
3. 循环计算：当 `n == 0` 时跳出：
   1. 当前数是奇数的时候，将 x 乘入 res
   2. 执行 $x = x^{2}$
   3. 执行 `n右移一位`

```java
public double myPow(double x, int n) {
    if (n == Integer.MIN_VALUE) {
        if (x == 1 || x == -1) {
            return 1;
        } else {
            return 0;
        }
    }
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }
    double res = 1;
    while (n != 0) {
        if ((n & 1) == 1) {
            res *= x;
        }
        x = x * x;
        n = n >> 1;
    }
    return res;
}
```

* 时间复杂度：O(logN)
* 空间复杂度：O(1)

### [17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

说明：本题有问题，如果数字很大，必须要用字符串保存。本题其实就是对数字 0~9 的可重复的**全排列**，其中要注意的是数字开头不应该有0。**为了能够测试通过**，最后把字符串形式变成了 int 形式，其实应该返回字符串数组。

放弃。

```java
class Solution {
    int[] res;
    int count = 0;

    public int[] printNumbers(int n) {
        res = new int[(int)Math.pow(10, n) - 1];
        for(int digit = 1; digit < n + 1; digit++){
            for(char first = '1'; first <= '9'; first++){
                char[] num = new char[digit];
                num[0] = first;
                dfs(1, num, digit);
            }
        }
        return res;
    }

    private void dfs(int index, char[] num, int digit){
        if(index == digit){
            res[count++] = Integer.parseInt(String.valueOf(num));
            return;
        }
        for(char i = '0'; i <= '9'; i++){
            num[index] = i;
            dfs(index + 1, num, digit);
        }
    }
}
```

### [ 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

```java
public int sumNums(int n) {
    if (n == 1) {
        return 1;
    }
    return n + sumNums(n - 1);
}
```

## 回溯

### [12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int M = board.length;
        int N = board[0].length;

        // 从左上角开始找
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    // 棋盘，要找的字符串，棋盘下标[i,j]，要找的字符的下标index
    public boolean dfs(char[][] board, String word, int i, int j, int index) {
        if (index == word.length()) {
            return true;
        }
        // 如果棋盘下标越界，返回false
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
            return false;
        }
        // 如果当前的值不是我们要找的字符
        if (board[i][j] != word.charAt(index)) {
            return false;
        }

        board[i][j] = '\0';
        // 递归上下左右，回溯
        boolean res = dfs(board, word, i - 1, j, index + 1) || dfs(board, word, i + 1, j, index + 1)
                || dfs(board, word, i, j - 1, index + 1) || dfs(board, word, i, j + 1, index + 1);
        board[i][j] = word.charAt(index);
        return res;
    }
}
```

### [34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

思路：**回溯**。

**`recur(root, tar) 函数：`**

**1. 确定递归函数的参数和返回值**：输入根节点、目标值

**2. 确定终止条件**：

* 如果越过叶子节点，返回空。
* 如果当前节点的值等于目标值，并且左右节点为空，更新路径和结果

**3. 确定单层递归的逻辑**：更新路径，递归左节点，递归右节点，回溯

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> pathSum(TreeNode root, int target) {
        dfs(root, target);
        return res;
    }

    public void dfs(TreeNode root, int target) {
        if (root == null) {
            return;
        }
        if (root.val == target && root.left == null && root.right == null) {
            path.add(root.val);
            res.add(new ArrayList<>(path));
        }

        path.add(root.val);
        // 递归左节点，递归右节点，回溯
        dfs(root.left, target - root.val);
        dfs(root.right, target - root.val);
        path.remove(path.size() - 1);
    }
}
```

### [38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public String[] permutation(String str) {
        boolean[] used = new boolean[str.length()];
        char[] arr = str.toCharArray();
        Arrays.sort(arr);
        dfs(arr, used);

        String[] ret = new String[res.size()];
        for (int i = 0; i < res.size(); i++) {
            ret[i] = res.get(i);
        }
        return ret;
    }

    public void dfs(char[] arr, boolean[] used) {
        if (path.length() == arr.length) {
            res.add(path.toString());
            return;
        }

        for (int i = 0; i < arr.length; i++) {
            if (i > 0 && arr[i] == arr[i - 1] && used[i - 1] == true) {
                continue;
            }
            if (used[i] == false) {
                path.append(arr[i]);
                used[i] = true;
                dfs(arr, used);
                used[i] =false;
                path.deleteCharAt(path.length() - 1);
            }
        }
    }
}
```

## 动态规划

### [10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```java
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    int pre = 0;
    int cur = 1;

    for (int i = 2; i <= n; i++) {
        int temp = (pre + cur) % 1000000007;
        pre = cur;
        cur = temp;
    }

    return cur;
}
```

### [10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

就是爬楼梯

```java
public int numWays(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }

    int pre = 1;
    int cur = 1;
    for (int i = 2; i <= n; i++) {
        int temp = (pre + cur) % 1000000007;
        pre = cur;
        cur = temp;
    }

    return cur;
}
```

### [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

不会。

**1. 确定DP数组和下标的含义**：`dp[i]` 表示将正整数 `i` 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

**2. 确定递推公式**：

当 `i >= 2` 时，假设对正整数 `i` 拆分出的第一个正整数是 `j (1 <= j <= i)`，则有以下两种方案：

* 将 $i$ 拆分成 $j$ 和 $i-j$ 的和，且 $i-j$ **不再拆分**成多个正整数，此时的乘积是 $j \times (i-j)$；

* 将 $i$ 拆分成 $j$ 和 $i-j$ 的和，且 $i-j$ **可以拆分**成多个正整数，此时的乘积是 $j \times dp(i-j)$；

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210726215936.png" alt="image-20210726215936343" style="zoom:80%;" />

**3. DP数组初始化**：0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，所以：

* `dp[0] = 0`
* `dp[1] = 0`

**4. 确定遍历顺序**：`2 <= i <= n`，`1 <= j <= i - 1`

```java
public int cuttingRope(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i - 1; j++) {
            int temp = Math.max(j * (i - j), j * dp[i - j]);
            dp[i] = Math.max(dp[i], temp);
        }
    }

    return dp[n];
}
```

### [14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

不会

思路：和 [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) 一样，但是增加了 n，所以不能使用动态规划，只能使用**贪心**。

我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？

* `1` 会包含吗？ 不会，因为 `1 * (k - 1) < k`, 只要把 `1` 和任何一个其他的片段组合在一起就有个更大的值
* `2` 可以
* `3` 可以
* `4` 可以吗？不可以，因为它可以拆成两个 2 
* `5`以上 可以吗？ 不可以，这些绳子必须拆

综上，`当 n >= 5时， 3 * (n - 3) >= 2 * (n - 2)`，因此我们优先拆成 3，最后剩余的拆成 2。最后的结果一定是由 **若干个`3 `**和 **1或2个`2`** 组成.

```java
public int cuttingRope1(int n) {
    if (n == 2) {
        return 1;
    }
    if (n == 3) {
        return 2;
    }

    int MOD = (int) (1e9 + 7);
    long res = 1;
    while (n > 4) {
        res = (res * 3) % MOD;
        n -= 3;
    }

    return (int) (res * n % MOD);
}
```

### [42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```java
public int maxSubArray(int[] nums) {
    int max = nums[0];
    int pre = Integer.MIN_VALUE;

    for (int num : nums) {
        if (pre <= 0) {
            pre = num;
        } else {
            pre += num;
        }
        max = Math.max(max, pre);
    }

    return max;
}
```

### [47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

### [49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

不会。

**1. 确定DP数组和下标的含义**：`dp[i]` 表示第 i + 1 个的丑数

**2. 确定递推公式**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210728155925.png" alt="image-20210728155925481" style="zoom:80%;" />

**3. DP数组初始化**：`dp[0] = 1`

**4. 确定遍历顺序**：从左向右遍历

**5. 举例推导DP数组**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210728155002.gif" alt="剑指 Offer 49. 丑数" style="zoom: 50%;" />

**6. 空间优化**：无法空间优化

```java
public int nthUglyNumber(int n) {
    int[] dp = new int[n];
    dp[0] = 1;
    int a = 0;
    int b = 0;
    int c = 0;

    for (int i = 1; i < n; i++) {
        int n2 = dp[a] * 2;
        int n3 = dp[b] * 3;
        int n5 = dp[c] * 5;

        dp[i] = Math.min(Math.min(n2, n3), n5);

        if (dp[i] == n2) a++;
        if (dp[i] == n3) b++;
        if (dp[i] == n5) c++;
    }

    return dp[n - 1];
}
```

### [60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

不会。

**1. 确定DP数组和下标的含义**：`dp[i]` 表示...

**2. 确定递推公式**

**3. DP数组初始化**：`[1/6, 1/6, 1/6, 1/6, 1/6, 1/6]`

**4. 确定遍历顺序**：

**5. 举例推导DP数组**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210728173722.gif" alt="剑指 Offer 60. n个骰子的点数" style="zoom: 50%;" />

```java
public double[] dicesProbability(int n) {
    double[] dp = new double[6];
    Arrays.fill(dp, 1.0 / 6.0);
	
    // k代表k个骰子
    for (int k = 2; k <= n; k++) {
        double[] temp = new double[5 * k + 1];
		
        // i用于遍历上一层dp
        for (int i = 0; i < dp.length; i++) {
            // j代表骰子的六个面
            for (int j = 0; j < 6; j++) {
                temp[i + j] +=  dp[i] / 6.0;
            }
        }
        dp = temp;
    }

    return dp;
}
```

### [62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

思路：**动态规划**。

最终剩下一个人时的安全位置肯定为 0，反推安全位置在人数为 n 时的编号。

* 人数为 1 ：0
* 人数为 2 ：(0+m) % 2
* 人数为 3 ：((0+m) % 2 + m) % 3
* ...
* 迭代推理到n就可以得出答案

```java
public int lastRemaining(int n, int m) {
    int dp = 0;
    for (int i = 2; i <= n; i++) {
        dp = (dp + m) % i;
    }
    return dp;
}
```

### [66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

见 [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) ，前缀积

**1. 确定DP数组和下标的含义**：`dp[i]` 表示除了下标 `i` 以外的元素的积

**2. 确定递推公式**

**3. DP数组初始化**：`dp[0] = 1`

**4. 确定遍历顺序**

**5. 举例推导DP数组**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210729003225.gif" alt="剑指 Offer 66. 构建乘积数组" style="zoom: 67%;" />

```java
public int[] constructArr(int[] nums) {
    if (nums.length == 0) {
        return new int[0];
    }

    int N = nums.length;
    int[] dp = new int[N];
    dp[0] = 1;
	
    // 计算下三角
    for (int i = 1; i < N; i++) {
        dp[i] = dp[i - 1] * nums[i - 1];
    }
    // 计算上三角
    int temp = 1;
    for (int i = N - 2; i >= 0; i--) {
        temp *= nums[i + 1];
        dp[i] *= temp;
    }

    return dp;
}
```



## 贪心

### [63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

```java
public int maxProfit(int[] prices) {
    if (prices.length == 0) {
        return 0;
    }

    int res = 0;
    int minPrice = prices[0];
    for (int price : prices) {
        if (minPrice > price) {
            minPrice = price;
        }
        if (res < price - minPrice) {
            res = price - minPrice;
        }
    }
    return res;
}
```

## 搜索









## 二进制/位运算

### [15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

思路1：**`n &= n - 1` ：** 消去数字 n 最右边的 1 。

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count++;
        n = n & (n - 1);
    }
    return count;
}
```

思路2：

```java
public int hammingWeight(int n) {
    return Integer.bitCount(n);
}
```

## 数学

### [39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210811021641.png" alt="image-20210811021641774" style="zoom:80%;" />

思路：**摩尔投票**算法。

```java
public int majorityElement(int[] nums) {
    int res = nums[0];
    int count = 1;

    for (int i = 1; i < nums.length; i++) {
        if (nums[i] == res) {
            count++;
        } else {
            if (count == 0) {
                res = nums[i];
                count = 1;
            } else {
                count--;
            }
        }
    }
    return res;
}
```

### [43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

<img src="https://pic.leetcode-cn.com/89b6be570b5ce741481172b65397760eb0d19541ad761641f974e4c9f62d2eda-Picture5.png" alt="img" style="zoom:50%;" />

<img src="https://pic.leetcode-cn.com/1f7e8ce0bf03c7fc974082c32ec909ebffc6429636ec46cecd492604c65ec87f-Picture6.png" alt="img" style="zoom:50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210713202338.png" alt="image-20210713202338707" style="zoom:80%;" />

```java
public int countDigitOne(int n) {
    int digit = 1;
    int high = n / 10;
    int cur = n % 10;
    int low = 0;
    int res = 0;
    while (n / digit != 0) {
        if (cur == 0) {
            res += high * digit;
        } else if (cur == 1) {
            res += high * digit + low + 1;
        } else {
            res += high * digit + digit;
        }
        low += cur * digit;
        cur = high % 10;
        high /= 10;
        digit *= 10;
    }
    return res;
}
```

### [44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210815143113.png" alt="image-20210815143113800" style="zoom:80%;" />

思路：

| 数字位数 |       数字范围        |     数字长度      |
| :------: | :-------------------: | :---------------: |
|    0     |           0           |         0         |
|    1     |         1 - 9         |     9 * 1 * 1     |
|    2     |        10 - 99        |    9 * 10 * 2     |
|    3     |       100 - 999       |    9 * 100 * 3    |
|    4     |      1000 - 9999      |   9 * 1000 * 4    |
|    5     |     10000 - 99999     |   9 * 10000 * 5   |
|    6     |    100000 - 999999    |  9 * 100000 * 6   |
|    7     |   1000000 - 9999999   |  9 * 1000000 * 7  |
|    8     |  10000000 - 99999999  | 9 * 10000000 * 8  |
|    9     | 100000000 - 999999999 | 9 * 100000000 * 9 |

```java
public int findNthDigit(int n) {
    n -= 1;
    for (int digit = 1; digit <= 10; digit++) {
        long firstNum = (long) Math.pow(10, digit - 1);
        if (n < 9 * firstNum * digit) {
            return String.valueOf((firstNum + n / digit)).charAt(n % digit) - '0';
        }
        n -= 9 * firstNum * digit;
    }
    return 0;
}
```























