[toc]

# 无向图

## **无向图的连通分量**

### [323. 无向图中连通分量的数目](https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825021835.png" alt="image-20210825021835874" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825021850.png" alt="image-20210825021850045" style="zoom:80%;" />

连通图：任意两个节点都是连通的。

连通分量：连通子图的最大数量。

思路：DFS。记录连通分量的个数。

```java
class Solution {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    public int countComponents(int N, int[][] graph) {
        visited = new boolean[N];
        for (int src = 0; src < N; src++) {
            edges.add(new ArrayList<>());
        }
        for (int i = 0; i < graph.length; i++) {
            int src = graph[i][0];
            int dst = graph[i][1];
            edges.get(src).add(dst);
            edges.get(dst).add(src);
        }

        int count = 0;
        for (int src = 0; src < N; src++) {
            if (!visited[src]) {
                dfs(src);
                count++;
            }
        }
        return count;
    }

    public void dfs(int src) {
        visited[src] = true;
        for (int dst : edges.get(src)) {
            if (!visited[dst]) {
                dfs(dst);
            }
        }
    }
}
```

### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825022625.png" alt="image-20210825022625746" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825022633.png" alt="image-20210825022633892" style="zoom:80%;" />

思路：DFS。

```java
class Solution {

    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    public int findCircleNum(int[][] isConnected) {
        int N = isConnected.length;
        visited = new boolean[N];
        for (int i = 0; i < N; i++) {
            edges.add(new ArrayList<>());
        }
        for (int src = 0; src < N; src++) {
            for (int dst = 0; dst < N; dst++) {
                if (isConnected[src][dst] == 1) {
                    edges.get(src).add(dst);
                }
            }
        }

        int count = 0;
        for (int src = 0; src < N; src++) {
            if (!visited[src]) {
                dfs(src);
                count++;
            }
        }
        return count;
    }

    public void dfs(int src) {
        visited[src] = true;
        for (int dst : edges.get(src)) {
            if (!visited[dst]) {
                dfs(dst);
            }
        }
    }
}
```

### 具体的无向图的连通分量

思路：`visited` 使用 `int数组` 保存。初始化 `visited` 都是 0。初始化 id，`int id = 1` 。每次 DFS，`visited[src] = id`。最后再遍历 `visited`，求出不同的连通分量的节点。

```java
class DFS2CC {
    List<List<Integer>> edges = new ArrayList<>();
    int[] visited;

    public void solution(int n, int[][] relation) {
        visited = new int[n];
        // 初始化边
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        // 添加所有的边
        for (int[] edge : relation) {
            int src = edge[0];
            int dst = edge[1];
            edges.get(src).add(dst);
        }
        // DFS
        int id = 1;
        for (int src = 0; src < n; src++) {
            if (visited[src] == 0) {
                dfs(src, id);
                id++;
            }
        }
    }

    public void dfs(int src, int id) {
        visited[src] = id;
        System.out.println(src);
        for (int dst : edges.get(src)) {
            if (visited[dst] == 0) {
                dfs(dst, id);
            }
        }
    }
}
```

## **二分图检测**

### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825022832.png" alt="image-20210825022832631" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825022840.png" alt="image-20210825022840324" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825022852.png" alt="image-20210825022852765" style="zoom:80%;" />

**二分图** 定义：如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B` ，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 **二分图** 。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210803082757.png" alt="image-20210803082757160" style="zoom: 33%;" />

思路：DFS。如果相邻节点的颜色一样（也就是源点的颜色和汇点的颜色一样），说明这不是二分图。

* `visited`：
  * -1，蓝色
  * 0，没有访问过，未染色
  * 1，红色

```java
class Solution {
    int[][] graph;
    int[] visited;      // -1，蓝色；0，未染色；1，红色

    public boolean isBipartite(int[][] graph) {
        int N = graph.length;
        this.graph = graph;
        visited = new int[N];

        for (int src = 0; src < N; src++) {
            if (visited[src] == 0) {
                if (dfs(src, 1) == false) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean dfs(int src, int color) {
        visited[src] = color;
        for (int dst : graph[src]) {
            if (visited[dst] == 0) {
                if (dfs(dst, -color) == false) {
                    return false;
                }
            }
            if (visited[src] == visited[dst]) {
                return false;
            }
        }
        return true;
    }
}
```

### [886. 可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825143803.png" alt="image-20210825143802869" style="zoom:80%;" />

思路：二分图检测。节点从1开始算。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825145309.png" alt="image-20210825145309531" style="zoom: 50%;" />

```java
class Solution {
    List<List<Integer>> edges = new ArrayList<>();
    int[] visited;      // -1，蓝色；0，未染色；1，红色

    public boolean possibleBipartition(int N, int[][] dislikes) {
        visited = new int[N + 1];
        for (int i = 0; i < N + 1; i++) {
            edges.add(new ArrayList<>());
        }
        for (int[] dislike : dislikes) {
            edges.get(dislike[0]).add(dislike[1]);
            edges.get(dislike[1]).add(dislike[0]);
        }

        for (int src = 1; src < N + 1; src++) {
            if (visited[src] == 0) {
                if (dfs(src, 1) == false) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean dfs(int src, int color) {
        visited[src] = color;
        for (int dst : edges.get(src)) {
            if (visited[dst] == 0) {
                if (dfs(dst, -color) == false) {
                    return false;
                }
            }
            if (visited[src] == visited[dst]) {
                return false;
            }
        }
        return true;
    }
}
```

## 无向图的单源路径

思路：新建一个数组 `path`，`path[dst] = src`，保存 `src` 的上一个节点，如果 `path[dst] == -1`，说明这个点是 DFS的起点。最后在数组 `path` 上，往回找起点。如果存在环的话，是找不到起点的。

```java
class DFS {
    List<List<Integer>> edges = new ArrayList<>();
    int[] visited;
    int[] path;

    public int[] solution(int n, int[][] relation) {
        visited = new int[n];
        path = new int[n];
        Arrays.fill(path, -1);

        // 初始化边
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        // 添加所有的边
        for (int[] edge : relation) {
            int src = edge[0];
            int dst = edge[1];
            edges.get(src).add(dst);
        }
        // DFS
        for (int src = 0; src < n; src++) {
            if (visited[src] == 0) {
                dfs(src);
            }
        }
        return path;
    }
    
    public void dfs(int src) {
        visited[src] = 1;
        System.out.println(src);
        for (int dst : edges.get(src)) {
            if (visited[dst] == 0) {
                path[dst] = src;
                dfs(dst);
            }
        }
    }
}
```

## 无向图的拓扑排序

### [310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825141234.png" alt="image-20210825141234426" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825141309.png" alt="image-20210825141309417" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825141316.png" alt="image-20210825141316056" style="zoom:80%;" />

思路：本题是无向图。不断缩小图，每次删除的度为1的点。直至剩下<=2个点为止。

```java
public List<Integer> findMinHeightTrees(int N, int[][] relations) {
    List<Integer> res = new ArrayList<>();
    if (N == 1) {
        res.add(0);
        return res;
    }

    List<List<Integer>> edges = new ArrayList<>();
    for (int i = 0; i < N; i++) {
        edges.add(new ArrayList<>());       // 初始化所有的点
    }
    int[] degree = new int[N];              // 度
    for (int[] r : relations) {             // 添加节点和度
        edges.get(r[0]).add(r[1]);
        edges.get(r[1]).add(r[0]);
        degree[r[0]]++;
        degree[r[1]]++;
    }

    Deque<Integer> deque = new ArrayDeque<>();
    for (int i = 0; i < N; i++) {       // 添加所有度为1的点
        if (degree[i] == 1) {
            deque.addLast(i);
        }
    }
    while (!deque.isEmpty()) {
        res.clear();
        int size = deque.size();

        for (int i = 0; i < size; i++) {        // 遍历这一整层
            Integer src = deque.removeFirst();
            res.add(src);

            List<Integer> dstList = edges.get(src);
            for (int dst : dstList) {
                degree[dst]--;
                if (degree[dst] == 1) {
                    deque.addLast(dst);
                }
            }
        }
    }
    return res;
}
```

## **其他**

### [133. 深拷贝无向图](https://leetcode-cn.com/problems/clone-graph/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825151737.png" alt="image-20210825151737506" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825151944.png" alt="image-20210825151944026" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825151823.png" alt="image-20210825151822925" style="zoom:80%;" />

不会 * 2

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825161236.png" alt="image-20210825161236657" style="zoom: 50%;" />

思路：**DFS前序遍历**。哈希表保存 **<已被访问的节点，克隆的节点>**。如果哈希表里有克隆的节点，就返回克隆的节点。不然就克隆当前节点，加入到哈希表中。

递归：遍历当前节点的汇点，把克隆节点的克隆好的汇点加入到克隆节点的汇点中。

```java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }
        Map<Node, Node> map = new HashMap<>();
        return dfs(node, map);
    }

    private Node dfs(Node node, Map<Node, Node> map) {
        if (map.containsKey(node)) {
            return map.get(node);
        }

        Node cloneNode = new Node(node.val, new ArrayList<>());
        map.put(node, cloneNode);

        for (Node n : node.neighbors) {
            cloneNode.neighbors.add(dfs(n, map));
        }
        return cloneNode;
    }
}

class Node {
    public int val;
    public List<Node> neighbors;
}
```

### [1042. 不邻接植花](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826020022.png" alt="image-20210826020022759" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826020029.png" alt="image-20210826020029874" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826020035.png" alt="image-20210826020035573" style="zoom:80%;" />

思路：暴力。

* 默认所有的花园先不染色，即染0
* 从第一个花园开始走，把与它邻接的花园的颜色从color{1,2,3,4}这个颜色集中删除
* 删完了所有与它相邻的颜色，就可以把集合中剩下的颜色随机选一个给它了，为了简单，将集合中的第一个颜色赋给当前花园
* 循环上述操作，直到最后一个花园

```java
public int[] gardenNoAdj(int N, int[][] paths) {
    List<List<Integer>> edges = new ArrayList<>();
    for (int i = 0; i < N; i++) {
        edges.add(new ArrayList<>());
    }
    for (int i = 0; i < paths.length; i++) {
        edges.get(paths[i][0] - 1).add(paths[i][1] - 1);
        edges.get(paths[i][1] - 1).add(paths[i][0] - 1);
    }

    int[] res = new int[N];
    for (int src = 0; src < N; src++) {
        Set<Integer> color = new HashSet<>(){{
            add(1);
            add(2);
            add(3);
            add(4);
        }};
        for (int dst : edges.get(src)) {
            color.remove(res[dst]);
        }
        res[src] = color.iterator().next();
    }
    return res;
}
```

### [261. 判断图是否是有效的树](https://leetcode-cn.com/problems/graph-valid-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826023050.png" alt="image-20210826023050549" style="zoom:80%;" />

思路：如果无向图是树的话，要满足两个条件：

1. 边的数量 = 点的数量 - 1
2. 该无向图是一个连通图

```java
class Solution {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    public boolean validTree(int N, int[][] graph) {
        if (N - 1 != graph.length) {
            return false;
        }

        visited = new boolean[N];
        for (int i = 0; i < N; i++) {
            edges.add(new ArrayList<>());
        }
        for (int[] g : graph) {
            edges.get(g[0]).add(g[1]);
            edges.get(g[1]).add(g[0]);
        }

        dfs(0);
        for (int i = 0; i < visited.length; i++) {
            if (!visited[i]) {
                return false;
            }
        }
        return true;
    }

    private void dfs(int src) {
        visited[src] = true;
        for (int dst : edges.get(src)) {
            if (!visited[dst]) {
                dfs(dst);
            }
        }
    }
}
```

# 有向图

## **拓扑排序（找环）**

### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825025419.png" alt="image-20210825025419059" style="zoom:80%;" />

思路1：拓扑排序。

```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    List<List<Integer>> edges = new ArrayList<>();
    for (int i = 0; i < numCourses; i++) {
        edges.add(new ArrayList<>());           // 初始化所有的点
    }

    int[] inDegree = new int[numCourses];       // 入度
    for (int[] p : prerequisites) {             // 添加点和入度
        edges.get(p[1]).add(p[0]);
        inDegree[p[0]]++;
    }

    List<Integer> res = new ArrayList<>();      // 拓扑排序的结果
    Deque<Integer> deque = new ArrayDeque<>();
    for (int i = 0; i < numCourses; i++) {      // 添加所有入度为0的点
        if (inDegree[i] == 0) {
            deque.addLast(i);
        }
    }
    while (!deque.isEmpty()) {
        Integer src = deque.removeFirst();
        res.add(src);

        List<Integer> dstList = edges.get(src);
        for (int dst : dstList) {
            inDegree[dst]--;
            if (inDegree[dst] == 0) {
                deque.addLast(dst);
            }
        }
    }
    return res.size() == numCourses;
}
```

思路2：通过 **DFS** 判断 **图中是否有环**。借助一个标志列表 `visited`，用于判断源点 `src` （课程）的状态：

* 0：未被 DFS 访问
* -1：已被**其他节点启动**的 DFS 访问
* 1：已被**当前节点启动**的 DFS 访问

**DFS 流程**：

1. 标记当前节点为被**当前节点启动**的 DFS 访问；
2. 遍历所有汇点，如果汇点
3. 递归访问当前节点 `src` 的所有邻接节点 `dst`，当发现环直接返回 False；当 `visited[src] == 1`，说明在本轮 DFS 搜索中节点 `src` 被第 2 次访问，即 **课程安排图有环** ，直接返回 False。
4. 当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点标记为已被**其他节点启动**的 DFS 访问，并返回 True。

```java
class Solution {
    List<List<Integer>> edges = new ArrayList<>();
    int[] visited;          //  0, 没有访问过; -1, 已被其它节点访问过; 1, 被当前节点访问过

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        visited = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<>());
        }
        for (int[] edge : prerequisites) {
            int src = edge[0];
            int dst = edge[1];
            edges.get(src).add(dst);
        }

        for (int src = 0; src < numCourses; src++) {
            if (visited[src] == 0) {
                if (!dfs(src)) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean dfs(int src) {
        visited[src] = 1;
        for (int dst : edges.get(src)) {
            if (visited[dst] == 0) {
                if (!dfs(dst)) {
                    return false;
                }
            }
            if (visited[dst] == 1) {
                return false;
            }
        }
        visited[src] = -1;
        return true;
    }
}
```

### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825035607.png" alt="image-20210825035606930" style="zoom:80%;" />

示例2：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825040023.png" alt="image-20210825040023905" style="zoom:67%;" />

思路：拓扑排序。先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。重复上述操作，直到所有的节点都被分离出来。如果最后存在入度不为0的节点，那就说明有环，不存在拓扑排序的结果。

<img src="https://pic.leetcode-cn.com/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt="0210.gif" style="zoom: 33%;" />

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    List<List<Integer>> edges = new ArrayList<>();	// 初始化点
    for (int i = 0; i < numCourses; i++) {
        edges.add(new ArrayList<>());
    }

    int[] inDegree = new int[numCourses];       // 入度
    for (int[] p : prerequisites) {             // 添加点和入度
        edges.get(p[1]).add(p[0]);
        inDegree[p[0]]++;
    }

    List<Integer> res = new ArrayList<>();      // 拓扑排序的结果
    Deque<Integer> deque = new ArrayDeque<>();
    for (int i = 0; i < numCourses; i++) {      // 添加所有入度为0的点
        if (inDegree[i] == 0) {
            deque.addLast(i);
        }
    }
    while (!deque.isEmpty()) {
        Integer src = deque.removeFirst();
        res.add(src);

        List<Integer> dstList = edges.get(src);
        for (int dst : dstList) {
            inDegree[dst]--;
            if (inDegree[dst] == 0) {
                deque.addLast(dst);
            }
        }
    }
    if (res.size() != numCourses) {     // 拓扑排序未完成
        return new int[0];
    }
    int[] ret = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        ret[i] = res.get(i);
    }
    return ret;
}
```

### [1136. 平行课程](https://leetcode-cn.com/problems/parallel-courses/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826024827.png" alt="image-20210826024827559" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826024837.png" alt="image-20210826024837326" style="zoom:80%;" />

思路：拓扑排序。拓扑排序的队列每一次遍历这一层的节点。

```java
public int minimumSemesters(int N, int[][] relations) {
    List<List<Integer>> edges = new ArrayList<>();	// 初始化点
    for (int i = 0; i < N; i++) {
        edges.add(new ArrayList<>());
    }
    int[] inDegree = new int[N];            // 入度
    for (int[] r : relations) {             // 添加点和入度
        edges.get(r[0] - 1).add(r[1] - 1);
        inDegree[r[1] - 1]++;
    }

    int count = 0;              // 拓扑排序了几个点
    int res = 0;
    Deque<Integer> deque = new ArrayDeque<>();
    for (int i = 0; i < N; i++) {           // 添加所有入度为0的点
        if (inDegree[i] == 0) {
            deque.addLast(i);
        }
    }
    while (!deque.isEmpty()) {
        res++;
        int size = deque.size();				// 改动
        for (int i = 0; i < size; i++) {
            int src = deque.removeFirst();
            count++;
            List<Integer> dstList = edges.get(src);
            for (int dst : dstList) {
                inDegree[dst]--;
                if (inDegree[dst] == 0) {
                    deque.addLast(dst);
                }
            }
        }
    }
    return count == N ? res : -1;
}
```

### [269. 火星词典](https://leetcode-cn.com/problems/alien-dictionary/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825131250.png" alt="image-20210825131250812" style="zoom:80%;" />

不会。

思路：将词典中字符串的字符两两对比，只有第一个不同的字符才是正确的排序，如`ert`和`wrf`，只能推断出`e`的优先级高于`w`，剩余字符的优先级不能推断。

注意对于输入`"za"`,`"zb"`,`"ca"`,`"cb"`，字符关系为`a->b、z->c`，输出可以为`azbc`、`zacb`，只要输出一种即可。

```java
public String alienOrder(String[] words) {
    Map<Character, Set<Character>> map = new HashMap<>();
    for (int i = 0; i < words.length - 1; i++) {
        for (int j = 0; j < words[i].length(); j++) {
            if (j >= words[i + 1].length()) {			// ["abc","ab"]返回""
                return "";
            }
            if (words[i].charAt(j) == words[i + 1].charAt(j)) {
                continue;
            } else {
                // 保存第一个不同的字符顺序
                Set<Character> set = map.getOrDefault(words[i].charAt(j), new HashSet<>());
                set.add(words[i + 1].charAt(j));
                map.put(words[i].charAt(j), set);
                break;
            }
        }
    }

    int[] inDegree = new int[128];           // 入度
    Arrays.fill(inDegree, - 1);         // 没有出现的字母入度为-1
    for (String word : words) {             // 出现的字母入度都为0
        for (char c : word.toCharArray()) {
            inDegree[c] = 0;
        }
    }
    for (char key : map.keySet()) {
        for (char val : map.get(key)) {
            inDegree[val]++;          // 统计入度
        }
    }

    StringBuilder sb = new StringBuilder();         // 拓扑排序的结果
    Deque<Character> deque = new ArrayDeque<>();
    int count = 0;                                  // 图中节点数
    for (char c = 0; c < inDegree.length; c++) {    // 添加所有入度为0的点
        if (inDegree[c] != -1) {
            count++;
        }
        if (inDegree[c] == 0) {
            deque.addLast(c);
        }
    }
    while (!deque.isEmpty()) {
        Character src = deque.removeFirst();
        sb.append(src);

        if (map.containsKey(src)) {
            Set<Character> dstSet = map.get(src);
            for (Character dst : dstSet) {
                inDegree[dst]--;
                if (inDegree[dst] == 0) {
                    deque.addLast(dst);
                }
            }
        }
    }
    return sb.length() != count ? "" : sb.toString();
}
```

### [1203. 项目管理](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/)



## 欧拉路径

### [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210825194745473.png" alt="image-20210825194745473" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825194804.png" alt="image-20210825194757521" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825194828.png" alt="image-20210825194828659" style="zoom:80%;" />

不会。

欧拉图和半欧拉图的定义：

- 图中所有边恰好通过一次且走遍所有顶点的通路称为**欧拉通路**。
- 图中所有边恰好通过一次且走遍所有顶点的回路称为**欧拉回路**。
- 具有欧拉回路的无向图称为**欧拉图**。
- 具有欧拉通路但不具有欧拉回路的无向图称为**半欧拉图**。

考虑下面的这张图：

<img src="https://assets.leetcode-cn.com/solution-static/332/332_fig1.png" alt="Graph1" style="zoom: 25%;" />

我们从起点 `JFK` 出发，合法路径有两条：

* JFK → AAA → JFK → BBB → JFK
* JFK → BBB → JFK → AAA → JFK

既然要求字典序最小，那么我们每次应该贪心地选择当前节点所连的节点中字典序最小的那一个，并将其入栈。最后栈中就保存了我们遍历的顺序。

为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 $O(1) $ 地找到最小字典序的节点，并 $O(logM)$ 地删除它。

然后我们考虑一种特殊情况：

<img src="https://assets.leetcode-cn.com/solution-static/332/332_fig2.png" alt="Graph2" style="zoom:25%;" />

当我们先访问 AAA 时，我们无法回到 JFK，这样我们就无法访问剩余的边了。这种情况称为「死胡同」。

当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。

不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致**死胡同**。而**该节点必然是最后一个遍历到的节点**。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即**逆序入栈**）。**最后将所有栈中内容反转**。

**Hierholzer 算法**：用于在连通图中寻找欧拉路径，其流程如下：

1. 从起点出发，进行DFS。
2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。

时间：$O(MlogM)$，M是边的数量，对于每一条边我们需要 $O(logM)$ 地删除它。

空间：$O(M)$ 。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825211856.png" alt="image-20210825211856530" style="zoom:50%;" />

```java
class Solution {
    Map<String, PriorityQueue<String>> map = new HashMap<>();
    List<String> stack = new ArrayList<>();

    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets) {
            String src = ticket.get(0);
            String dst = ticket.get(1);
            map.computeIfAbsent(src, k -> new PriorityQueue<>()).add(dst);
        }
        dfs("JFK");
        Collections.reverse(stack);
        return stack;
    }

    private void dfs(String src) {
        while (map.containsKey(src) && map.get(src).size() > 0) {
            String dst = map.get(src).remove();
            dfs(dst);
        }
        stack.add(src);
    }
}
```

### [753. 破解保险箱](https://leetcode-cn.com/problems/cracking-the-safe/)

题意：求出一个最短的字符串，使其包含从 $0$ 到 $k^{n}$（k进制）中的所有数字。

[题解](https://leetcode-cn.com/problems/cracking-the-safe/solution/yi-bu-yi-bu-tui-dao-chu-0ms-jie-fa-tan-xin-gou-zao/)

放弃

## 回溯

### [1059. 从始点到终点的所有路径](https://leetcode-cn.com/problems/all-paths-from-source-lead-to-destination/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825224931.png" alt="image-20210825224921320" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825224950.png" alt="image-20210825224950539" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825225001.png" alt="image-20210825225001420" style="zoom:80%;" />

思路：**DFS回溯**。

```java
class Solution {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    public boolean leadsToDestination(int N, int[][] relations, int src, int target) {
        visited = new boolean[N];
        for (int i = 0; i < N; i++) {
            edges.add(new ArrayList<>());
        }
        for (int[] r : relations) {
            edges.get(r[0]).add(r[1]);
        }

        if (edges.get(target).size() != 0) {		// 目标点的出度为0
            return false;
        }
        visited[src] = true;
        return dfs(src, target);
    }

    private boolean dfs(int src, int target) {
        if (edges.get(src).size() == 0) {		// 如果当前的出度为0，看是不是目标点
            return src == target;
        }
        for (int dst : edges.get(src)) {
            if (visited[dst]) {
                return false;
            }
            visited[dst] = true;
            if (!dfs(dst, target)) {
                return false;
            }
            visited[dst] = false;			// 回溯
        }
        return true;
    }
}
```

### [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825232537.png" alt="image-20210825232537676" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825232546.png" alt="image-20210825232546008" style="zoom:80%;" />

思路：DFS回溯。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] edges) {
        path.add(0);
        dfs(edges, 0, edges.length - 1);
        return res;
    }

    private void dfs(int[][] edges, int src, int target) {
        if (src == target) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int dst : edges[src]) {
            path.add(dst);
            dfs(edges, dst, target);
            path.remove(path.size() - 1);
        }
    }
}
```

## 单源路径

### [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210826015134889.png" alt="image-20210826015134889" style="zoom:80%;" />

思路：DFS

```java
class Solution {
    boolean[] visited;
    int count = 0;

    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        visited = new boolean[rooms.size()];
        dfs(rooms, 0);
        return count == rooms.size();
    }

    private void dfs(List<List<Integer>> rooms, int src) {
        visited[src] = true;
        count++;
        for (int dst : rooms.get(src)) {
            if (!visited[dst]) {
                dfs(rooms, dst);
            }
        }
    }
}
```

### [997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826021538.png" alt="image-20210826021537932" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826021604.png" alt="image-20210826021604402" style="zoom:80%;" />

题意翻译：目标节点入度为 N - 1，出度为 0。

思路：暴力。用两个数组分别统计**入度**和**出度**。最后再找入度为 N - 1，出度为 0 的目标节点，找不到返回 -1 。

```java
public int findJudge(int N, int[][] trusts) {
    int[] inDegree = new int[N + 1];
    int[] outDegree = new int[N + 1];
    for (int[] t : trusts) {
        outDegree[t[0]]++;
        inDegree[t[1]]++;
    }
    for (int i = 1; i <= N; i++) {
        if (outDegree[i] == 0 && inDegree[i] == N - 1) {
            return i;
        }
    }
    return -1;
}
```

## 多源路径

### [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827215417.png" alt="image-20210827215417764" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827220119.png" alt="image-20210827220119362" style="zoom:80%;" />

不会。

时间：$O(n^{2}*2^{n})$，点的数量为 $O(n*2^{n})$，边的数量为 $O(n^{2}*2^{n})$

思路：**BFS + 状态压缩**。最多只有十二个节点，使用 `int` 的低12位来表示是否被访问过。例如：$(000...0101)_{2}$ 代表 2节点 和 0节点 已经被访问过了。

* `(state >> i) & 1` ：获取 `state` 的第 `i` 位
* `state | (1 << i)` ：标记 `state` 的第 `i` 位

```java
public int shortestPathLength(int[][] graph) {
    final int INF = (int) 0x3f3f3f3f;
    int N = graph.length;
    int mask = 1 << N;

    int[][] dist = new int[mask][N];
    for (int i = 0; i < mask; i++) {
        Arrays.fill(dist[i], INF);
    }

    Deque<int[]> deque = new ArrayDeque<>();
    for (int i = 0; i < N; i++) {
        dist[1 << i][i] = 0;
        deque.addLast(new int[] {1 << i, i});
    }

    while (!deque.isEmpty()) {
        int[] temp = deque.removeFirst();
        int state = temp[0];
        int u = temp[1];
        int step = dist[state][u];
        if (state == mask - 1) {
            return step;
        }
        for (int i : graph[u]) {
            if (dist[state | (1 << i)][i] == INF) {
                dist[state | (1 << i)][i] = step + 1;
                deque.addLast(new int[]{state | (1 << i), i});
            }
        }
    }
    return -1;
}
```

### 智力题. 如何获得四升水

问题：有两个水桶，一个能装5升水，一个能装3升水，如何利用这两个水桶得到4升水。返回最短的步骤。

思路：BFS。`图上节点的值 = a * 10 + b`。下个选择有：A桶加满水，B桶加满水，A桶水倒掉，B桶水倒掉，把A桶水倒进B桶，把B桶水倒进A桶。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210712013556.png" alt="image-20210712013556230" style="zoom: 50%;" />

```java
class WaterPuzzle {

    public int dfs() {
        Deque<Integer> deque = new ArrayDeque<>();
        deque.addLast(0);

        boolean[] visited = new boolean[100];
        visited[0] = true;
        int count = 0;

        while (!deque.isEmpty()) {
            count++;
            int cur = deque.removeFirst();
            int a = cur / 10;
            int b = cur % 10;

            List<Integer> nexts = createNexts(a, b);

            for (int next : nexts) {
                if (!visited[next]) {
                    deque.addLast(next);
                    visited[next] = true;

                    if (next / 10 == 4 || next % 10 == 4) {
                        return count;
                    }
                }
            }
        }
        return count;
    }

    public List<Integer> createNexts(int a, int b) {
        List<Integer> nexts = new ArrayList<>();

        // A桶加满水，B桶加满水
        nexts.add(5 * 10 + b);
        nexts.add(a + 3 * 10);
        // A桶水倒掉，B桶水倒掉
        nexts.add(0 * 10 + b);
        nexts.add(a * 10 + 0);
        // 把A桶水倒进B桶
        int x = Math.min(a, 3 - b);
        nexts.add((a - x) * 10 + (b + x));
        // 把B桶水倒进A桶
        int y = Math.min((5 - a), b);
        nexts.add((a + y) * 10 + (b - y));

        return nexts;
    }
}
```

# 并查集

## 并查集模板

多用在**无向图连通性**的题目上。

**路径压缩**：

union: $O(logN)$

find: $O(logN)$

```java
class UnionFind {
    int count;      // 连通分量个数
    int[] parent;   // 节点i的父节点是parent[i]

    public UnionFind(int N) {
        this.count = N;         // n为图的节点总数
        parent = new int[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;      // 父节点指针初始指向自己
        }
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        parent[rootX] = rootY;          // x成为y的子树
        count--;
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

**路径压缩 + 带权**：

union: 接近常数

find: 接近常数

```java
class UnionFind {
    int count;      // 连通分量个数
    int[] parent;   // 节点i的父节点是parent[i]
    int[] size;     // 每棵树的重量

    public UnionFind(int N) {
        this.count = N;         // n为图的节点总数
        parent = new int[N];
        size = new int[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;      // 父节点指针初始指向自己
            size[i] = 1;        // 最初每个树只有一个节点，即每棵树的初始重量为1
        }
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        if (size[rootX] < size[rootY]) {
            parent[rootX] = rootY;          // x成为y的子树
            size[rootY] += size[rootX];
        } else {
            parent[rootY] = rootX;          // y成为x的子树
            size[rootX] += size[rootY];
        }
        count--;
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

## 并查集入门

### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

给你一个数组 `equations`，装着若干字符串表示的算式。每个算式 `equations[i]` 长度都是 4，而且只有这两种情况：`a==b` 或者 `a!=b`，其中 `a,b` 可以是任意小写字母。你写一个算法，如果 `equations` 中所有算式都不会互相冲突，返回 true，否则返回 false。

* 比如说，输入 `["a==b","b!=c","c==a"]`，算法返回 false，因为这三个算式不可能同时正确。

* 再比如，输入 `["c==c","b==d","x!=z"]`，算法返回 true，因为这三个算式并不会造成逻辑冲突。

思路：并查集。先让**相等的字母形成连通分量**。再检查**不等式的关系是否打破相等关系的连通性**。

时间：$O(N+logC)$，N是equations的数量，C是变量总数

空间：$O(C)$，创建长度为C的数组 `parent` 存储每个变量的连通分量信息

```java
public boolean equationsPossible(String[] equations) {
    UnionFind uf = new UnionFind(26);
    for (String e : equations) {
        if (e.charAt(1) == '=') {
            int x = e.charAt(0);
            int y = e.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    for (String e : equations) {
        if (e.charAt(1) == '!') {
            int x = e.charAt(0);
            int y = e.charAt(3);
            if (uf.find(x - 'a') == uf.find(y - 'a')) {
                return false;
            }
        }
    }
    return true;
}
```

### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828061644.png" alt="image-20210828061644057" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828054936.png" alt="image-20210828054936737" style="zoom:80%;" />

时间：$O(NlogN)$，N 是图中的节点个数，需要遍历 N 条边，每次查找的时间复杂度为 $O(logN)$

空间：$O(N)$，N个节点

思路：如果两个节点已连通，就返回这两个节点；未连通，就连通它们。

```java
public int[] findRedundantConnection(int[][] edges) {
    int N = edges.length;
    UnionFind uf = new UnionFind(N + 1);

    for (int[] edge : edges) {
        if (uf.find(edge[0]) == uf.find(edge[1])) {
            return edge;
        } else {
            uf.union(edge[0], edge[1]);
        }
    }
    return new int[0];
}
```

### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828074143.png" alt="image-20210828074143429" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828074215.png" alt="image-20210828074215883" style="zoom:80%;" />

思路：先处理特殊情况。再连通所有节点。返回连通分量个数 - 1 。

```java
public int makeConnected(int N, int[][] connections) {
    if (connections.length < N - 1) {
        return -1;
    }

    UnionFind uf = new UnionFind(N);
    for (int[] c : connections) {
        uf.union(c[0], c[1]);
    }
    return uf.count - 1;
}
```

### [839. 相似字符串组](https://leetcode-cn.com/problems/similar-string-groups/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210830000541767.png" alt="image-20210830000541767" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210830000551135.png" alt="image-20210830000551135" style="zoom:80%;" />

时间：$O(N^{2}*M + NlogN)$，$O(N^{2})$ 枚举所有的字符串，$O(M)$ 检查字符串是否相同。

思路：连接所有的字母异位词，返回连通分量个数。所有单词长度相同，而且是彼此的字母异位词。所以直接按位比较，不同个数小于等于 2 的词，就是字母异位词。

```java
public int numSimilarGroups(String[] arr) {
    int N = arr.length;
    UnionFind uf = new UnionFind(N);
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            if (isSameWord(arr[i], arr[j])) {
                uf.union(i, j);
            }
        }
    }
    return uf.count;
}

private boolean isSameWord(String word1, String word2) {
    if (word1.equals(word2)) {
        return true;
    }
    int count = 0;          // 字母不相同的个数
    for (int i = 0; i < word1.length(); i++) {
        if (word1.charAt(i) != word2.charAt(i)) {
            count++;
        }
        if (count > 2) {
            return false;
        }
    }
    return true;
}
```

### [947. 移除最多的同行或同列石头](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830010103.png" alt="image-20210830010103278" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830010121.png" alt="image-20210830010121052" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830010229.png" alt="image-20210830010229668" style="zoom: 50%;" />

时间：$O(NlogN)$，N是石头的数量

思路：连接在 同一行 or 同一列的石头。返回 石头个数 - 有效的连通分量个数。

具体做法：石头的最大坐标为 $10^{4}$，并查集大小只要稍微大于 $2*10^{4}$ 即可。最后统计石头的有效连通分量个数。

```java
public int removeStones(int[][] stones) {
    UnionFind uf = new UnionFind(20010);
    for (int[] stone : stones) {
        uf.union(stone[0], stone[1] + 10000);
    }

    Set<Integer> set = new HashSet<>();
    for (int[] stone : stones) {
        set.add(uf.find(stone[0]));
        set.add(uf.find(stone[1] + 10000));			// 这句也可以不用加
    }
    return stones.length - set.size();
}
```

### [959. 由斜杠划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830013249.png" alt="image-20210830013249492" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830013306.png" alt="image-20210830013306397" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830013318.png" alt="image-20210830013318295" style="zoom:80%;" />

不会。

思路：把一个单元格划分为4个小格子。根据「空格」、「斜杠」、「反斜杠」，进行合并。分为单元格内部合并，和单元格之间合并。

**单元格内**：

- 如果是空格：合并 0、1、2、3；
- 如果是斜杠：合并 0、3，合并 1、2；
- 如果是反斜杠：合并 0、1，合并 2、3。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830011639.png" alt="image-20210830011639797" style="zoom:80%;" />

**单元格外**：

尝试「向右、向下」合并。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830011931.png" alt="image-20210830011931725" style="zoom:80%;" />

```java
public int regionsBySlashes(String[] grid) {
    int N = grid.length;
    UnionFind uf = new UnionFind(4 * N * N);

    for (int i = 0; i < N; i++) {
        char[] arr = grid[i].toCharArray();

        for (int j = 0; j < N; j++) {
            int index = 4 * (i * N + j);    // 二维坐标一维化
            char c = arr[j];
            // 单元格内部合并
            if (c == '/') {
                uf.union(index, index + 3);
                uf.union(index + 1, index + 2);
            } else if (c == '\\') {
                uf.union(index, index + 1);
                uf.union(index + 2, index + 3);
            } else {
                uf.union(index, index + 1);
                uf.union(index + 1, index + 2);
                uf.union(index + 2, index + 3);
            }
            // 单元格外部合并
            if (j + 1 < N) {
                uf.union(index + 1, 4 * (i * N + j + 1) + 3);
            }
            if (i + 1 < N) {
                uf.union(index + 2, 4 * ((i + 1) * N + j));
            }
        }
    }
    return uf.count;
}
```

### [1559. 二维网格图中探测环](https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830023239.png" alt="image-20210830023239267" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830023249.png" alt="image-20210830023249496" style="zoom:80%;" />

思路：并查集。从左上角开始，每次向右和向下搜索，如果是相同字母则合并。如果在合并之前它们就属于同一个连通分量了，则形成环了。

```java
public boolean containsCycle(char[][] mat) {
    int M = mat.length;
    int N = mat[0].length;
    UnionFind uf = new UnionFind(M * N);

    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            // 向右搜索
            if (j + 1 < N && mat[i][j] == mat[i][j + 1]) {
                if (uf.find(i * N + j) == uf.find(i * N + j + 1)) {
                    return true;
                }
                uf.union(i * N + j, i * N + j + 1);
            }
            // 向下搜索
            if (i + 1 < M && mat[i][j] == mat[i + 1][j]) {
                if (uf.find(i * N + j) == uf.find((i + 1)* N + j)) {
                    return true;
                }
                uf.union(i * N + j, (i + 1)* N + j);
            }
        }
    }
    return false;
}
```

### [765. 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)

时间：$O(NlogN)$ ，空间：$O(N)$

思路：并查集。「至少交换的次数 = 所有情侣的对数 - 并查集里连通分量的个数」。

```java
public int minSwapsCouples(int[] nums) {
    int N = nums.length / 2;
    UnionFind uf = new UnionFind(N);
    for (int i = 0; i < nums.length; i += 2) {
        uf.union(nums[i] / 2, nums[i + 1] / 2);
    }
    return N - uf.count;
}
```

## 并查集中等

### [1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210829162757.png" alt="image-20210829162757563" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210829162819.png" alt="image-20210829162819670" style="zoom:80%;" />

时间：$O(NlongN)$，空间：$O(N)$

思路：连接可以交换的节点。新建哈希表存放 **< 并查集的根节点，同一个连通分量的字符集合（优先队列）>** 。最后重组字符串。

```java
public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
    UnionFind uf = new UnionFind(s.length());
    for (List<Integer> p : pairs) {
        uf.union(p.get(0), p.get(1));
    }

    Map<Integer, PriorityQueue<Character>> rootAndPQ = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        int root = uf.find(i);
        rootAndPQ.computeIfAbsent(root, key -> new PriorityQueue<>()).add(s.charAt(i));
    }

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        int root = uf.find(i);
        sb.append(rootAndPQ.get(root).remove());
    }
    return sb.toString();
}
```

### [1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830150614.png" alt="image-20210830150614233" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830150634.png" alt="image-20210830150634299" style="zoom:80%;" />

时间：$O(MNlogMN)$，空间：$O(MN)$

思路：从左上角开始遍历节点，获得每条边的权重（绝对值），保存到 list 中，**[边的权重, 边的源点, 边的汇点]** ，源点和汇点坐标需要转为一维坐标。对 list 排序，从小的权重开始遍历，连接源点和汇点，如果左上角和右下角是连通的，返回刚刚遍历到的边的权重。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830150840.png" alt="image-20210830150840731" style="zoom:67%;" />

```java
public int minimumEffortPath(int[][] mat) {
    int M = mat.length;
    int N = mat[0].length;

    List<int[]> edges = new ArrayList<>();
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            if (j + 1 < N) {
                edges.add(new int[] {
                    Math.abs(mat[i][j + 1] - mat[i][j]),
                    i * N + j,
                    i * N + j + 1
                });
            }
            if (i + 1 < M) {	
                edges.add(new int[] {
                    Math.abs(mat[i + 1][j] - mat[i][j]),
                    i * N + j,
                    (i + 1) * N + j
                });
            }
        }
    }
    Collections.sort(edges, (o1, o2) -> o1[0] - o2[0]);

    UnionFind uf = new UnionFind(M * N);
    for (int[] edge : edges) {
        uf.union(edge[1], edge[2]);
        if (uf.find(0) == uf.find(M * N - 1)) {
            return edge[0];
        }
    }
    return 0;
}
```

### [952. 按公因数计算最大组件大小](https://leetcode-cn.com/problems/largest-component-size-by-common-factor/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901003525.png" alt="image-20210901003525804" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901003543.png" alt="image-20210901003542933" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901003551.png" alt="image-20210901003551245" style="zoom:80%;" />

思路：找出节点的最大值。把节点与它的所有因子相连。遍历节点，统计根节点出现的次数，找出最大值。

```java
public int largestComponentSize(int[] nums) {
    int max = 0;
    for (int num : nums) {
        max = Math.max(max, num);
    }

    UnionFind uf = new UnionFind(max + 1);
    for (int num : nums) {
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                uf.union(num, i);
                uf.union(num, num / i);
            }
        }
    }

    int[] freq = new int[max + 1];
    int res = 0;
    for (int num : nums) {
        freq[uf.find(num)]++;
        res = Math.max(res, freq[uf.find(num)]);
    }
    return res;
}
```

时间：$O(N\sqrt{Max})$，N是数组长度，max是数组中的最大值。

空间：$O(N)$

## 并查集困难

### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828153751.png" alt="image-20210828153751035" style="zoom:80%;" />

时间：$O((M+N)logC)$，M 是 `equations` 的长度，N 是 `queries` 的长度，C 是 `equations` 中不同字符的个数。

空间：$O(C)$

思路：**哈希表 + 并查集**。

先用哈希表存放 <等式的变量，id> ，并把所有节点连接起来。再去判断两个节点是否在哈希表中，是否连通。

并查集：`double[] weight;` 是指向父节点的权值

路径压缩：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828154436.png" alt="image-20210828154435998" style="zoom: 80%;" />

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        UnionFind uf = new UnionFind(equations.size() * 2);

        Map<String, Integer> valAndId = new HashMap<>();        // <等式的变量，id>
        int id = 0;
        for (int i = 0; i < equations.size(); i++) {
            String var1 = equations.get(i).get(0);
            String var2 = equations.get(i).get(1);

            if (!valAndId.containsKey(var1)) {
                valAndId.put(var1, id++);
            }
            if (!valAndId.containsKey(var2)) {
                valAndId.put(var2, id++);
            }
            uf.union(valAndId.get(var1), valAndId.get(var2), values[i]);
        }

        double[] res = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String var1 = queries.get(i).get(0);
            String var2 = queries.get(i).get(1);

            Integer id1 = valAndId.get(var1);
            Integer id2 = valAndId.get(var2);
            if (id1 == null || id2 == null) {
                res[i] = -1.0;
                continue;
            }

            if (uf.find(id1) == uf.find(id2)) {
                res[i] = uf.weight[id1] / uf.weight[id2];
            } else {
                res[i] = -1.0;
            }
        }
        return res;
    }

    class UnionFind {
        int[] parent;       // 节点i的父节点是parent[i]
        double[] weight;    // 指向父节点的权值

        public UnionFind(int N) {
            parent = new int[N];
            weight = new double[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
                weight[i] = 1;
            }
        }

        public void union(int x, int y,double val) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return;
            }
            parent[rootX] = rootY;
            weight[rootX] = weight[y] * val / weight[x];
        }

        public int find(int x) {
            if (x != parent[x]) {
                int temp = parent[x];
                parent[x] = find(parent[x]);
                weight[x] *= weight[temp];
            }
            return parent[x];
        }
    }
}
```

### [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210829102430960.png" alt="image-20210829102430960" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210829102504.png" alt="image-20210829102444613" style="zoom:80%;" />

不会，时间：$O(NlongN)$，空间：$O(N)$

思路：哈希表 + 并查集。

* 哈希表 `emailAndIndex` 保存 <邮箱，账户的下标>。在并查集中连接有相同邮箱的账户。遍历账户下标，
* 另一个哈希表 `indexAndEmails` 保存 <账户下标，邮箱集合>。
* 最后遍历 <账户下标，邮箱集合>，把账户下标和邮箱集合拼接成list。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210829162711.png" alt="image-20210829162711546" style="zoom: 67%;" />

```java
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    int N = accounts.size();
    UnionFind uf = new UnionFind(N);

    Map<String, Integer> emailAndIndex = new HashMap<>();       // <邮箱，账户下标>
    for (int i = 0; i < N; i++) {
        List<String> account = accounts.get(i);
        for (int j = 1; j < account.size(); j++) {
            String email = account.get(j);
            if (emailAndIndex.containsKey(email)) {
                uf.union(i, emailAndIndex.get(email));
            }
            emailAndIndex.put(email, i);
        }
    }

    Map<Integer, Set<String>> indexAndEmails = new HashMap<>();   // <账户下标，邮箱集合>
    for (int i = 0; i < N; i++) {
        List<String> account = accounts.get(i);
        List<String> emails = account.subList(1, account.size());

        int index = uf.find(i);
        if (!indexAndEmails.containsKey(index)) {
            indexAndEmails.put(index, new TreeSet<>());
        }
        indexAndEmails.get(index).addAll(emails);
    }

    List<List<String>> res = new ArrayList<>();
    for (Map.Entry<Integer, Set<String>> entry: indexAndEmails.entrySet()) {
        List<String> list = new ArrayList<>();
        int index = entry.getKey();
        String name = accounts.get(index).get(0);
        list.add(name);
        list.addAll(entry.getValue());
        res.add(list);
    }
    return res;
}
```

### [924. 尽量减少恶意软件的传播](https://leetcode-cn.com/problems/minimize-malware-spread/)

时间：$O(NlongN)$，空间：$O(N)$

思路：根据连通子图的被感染节点个数分类：

1. **被感染节点数** < 1，连通子图的节点均正常，不存在需要恢复的节点
2. **被感染节点数** = 1，只需要恢复该被感染节点，整个连通子图将恢复正常
3. **被感染节点数** > 1，就算恢复该被感染节点，整个连通子图也无法恢复正常

所以我们需要连接所有节点。再统计每个连通分量的感染节点数，统计在根节点上。最后找感染节点数为 1，且节点数最多连通分量。如果有多个节点数相同的连通分量，返回最小坐标即可。

```java
public int minMalwareSpread(int[][] mat, int[] initial) {
    Arrays.sort(initial);

    int N = mat.length;
    UnionFind uf = new UnionFind(N);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (mat[i][j] == 1) {
                uf.union(i, j);
            }
        }
    }

    int[] count = new int[N];
    for (int i : initial) {
        count[uf.find(i)]++;
    }

    int maxCCSize = Integer.MIN_VALUE;          // Connected Component 连通分量
    int index = initial[0];
    for (int i : initial) {
        int root = uf.find(i);
        if (count[root] == 1 && uf.size[root] > maxCCSize) {
            maxCCSize = uf.size[root];
            index = i;
        }
    }
    return index;
}

class UnionFind {
    int count;      // 连通分量个数
    int[] parent;   // 节点i的父节点是parent[i]
    int[] size;

    public UnionFind(int N) {
        this.count = N;         // n为图的节点总数
        parent = new int[N];
        size = new int[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;      // 父节点指针初始指向自己
            size[i] = 1;
        }
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        size[rootY] += size[rootX];
        parent[rootX] = rootY;          // x成为y的子树
        count--;
    }

    public int find(int x) {
        if (x != parent[x]) {
            size[find(parent[x])] += size[parent[x]];
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

### [685. 冗余连接 II](https://leetcode-cn.com/problems/redundant-connection-ii/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210830161400293.png" alt="image-20210830161400293" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210830161413208.png" alt="image-20210830161413208" style="zoom:80%;" />

不会。

时间复杂度：$O(N^{2}logN)$

思路：树的的节点入度都为 1，且不存在环。如果一条边的两个节点在连接之前就已经被连接了，就说明存在环。

一共三种情况：

1. 入度为2，且有环
2. 入度为2，不存在环
3. 入度都为1，存在环

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830163534.png" alt="image-20210830163534830" style="zoom:50%;" />

具体做法：统计所有节点的入度。尝试删除入度为2的节点，如果不成环，那就是需要删除的边。如果上述操作不行，就去找入度为1的节点，删除之后，树不成环，就是需要删除的边了。因为可能有多个答案，所以尝试删除的时候需要逆序遍历。

```java
public int[] findRedundantDirectedConnection(int[][] edges) {
    int N = edges.length;           // 边的条数，在本题等于节点数量
    int[] inDegree = new int[N + 1];
    for (int[] edge : edges) {
        inDegree[edge[1]]++;
    }

    for (int i = N - 1; i >= 0; i--) {
        if (inDegree[edges[i][1]] == 2) {
            if (!isCircle(edges, i)) {
                return edges[i];        // 不成环，这条边就是需要去掉的边
            }
        }
    }

    for (int i = N - 1; i >= 0; i--) {
        if (inDegree[edges[i][1]] == 1) {
            if (!isCircle(edges, i)) {
                return edges[i];        // 不成环，这条边就是需要去掉的边
            }
        }
    }
    return new int[0];
}

// 是否成环
private boolean isCircle(int[][] edges, int removeEdgeIndex) {
    int N = edges.length;
    UnionFind uf = new UnionFind(N + 1);
    for (int i = 0; i < N; i++) {
        if (i == removeEdgeIndex) {
            continue;
        }
        if (uf.find(edges[i][0]) == uf.find(edges[i][1])) {
            return true;
        }
        uf.union(edges[i][0], edges[i][1]);
    }
    return false;
}
```

## 并查集地狱

### [803. 打砖块](https://leetcode-cn.com/problems/bricks-falling-when-hit/)

不会。

思路：敲碎所有需要敲碎的砖头。屋顶的砖头都与 `M * N + 1` 连接，再连接所有相邻的砖头（找上边和左边即可）。之后，逆序补回被敲碎的砖头。最后使用计算补回砖头后，`M * N + 1` 增加的 ”重量“。注意所有的增加都是对根节点的增加。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int[] hitBricks(int[][] grid, int[][] hits) {
        int M = grid.length;
        int N = grid[0].length;

        int[][]mat = new int[M][N];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                mat[i][j] = grid[i][j];
            }
        }
        for (int[] h : hits) {
            mat[h[0]][h[1]] = 0;
        }

        UnionFind uf = new UnionFind(M * N + 1);    // 与屋顶相连的砖块都与M*N相连
        for (int j = 0; j < N; j++) {
            if (mat[0][j] == 1) {
                uf.union(0 * N + j, M * N);     // 连接所有屋顶的砖块
            }
        }
        for (int i = 1; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (mat[i][j] == 1) {
                    if (mat[i - 1][j] == 1) {
                        uf.union((i - 1) * N + j, i * N + j);   // 连接上边的砖块
                    }
                    if (j - 1 >= 0 && mat[i][j - 1] == 1) {
                        uf.union(i * N + j - 1, i * N + j);     // 再连接左边的砖块
                    }
                }
            }
        }

        int[] res = new int[hits.length];
        for (int i = hits.length - 1; i >= 0; i--) {
            int x = hits[i][0];
            int y = hits[i][1];
            if (grid[x][y] == 0) {
                continue;
            }

            int origin = uf.size[uf.find(M * N)];                // 补回之前与屋顶相连的砖头数
            if (x == 0) {
                uf.union(0 * N + y, M * N);     // 如果是屋顶的砖头就与M*N相连
            }

            // 再连接相邻的砖头
            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == 1) {
                    uf.union(x * N + y, nextX * N + nextY);
                }
            }

            int cur = uf.size[uf.find(M * N)];
            res[i] = Math.max(0, cur - origin - 1);     // 避免cur-origin为0的情况
            mat[x][y] = 1;      // 补上砖头
        }
        return res;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }

    class UnionFind {
        int[] parent;   // 节点i的父节点是parent[i]
        int[] size;

        public UnionFind(int N) {
            parent = new int[N];
            size = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;      // 父节点指针初始指向自己
                size[i] = 1;
            }
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return;
            }
            parent[rootX] = rootY;          // x成为y的子树
            size[rootY] += size[rootX];
        }

        public int find(int x) {
            if (x != parent[x]) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
    }
}
```

# 单源最短路径

## Dijkstra 算法 

### [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828041327.png" alt="image-20210826042433259" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828041327.png" alt="image-20210826042446069" style="zoom:80%;" />

题意：求从K出发的最长路径。

解决方法：求K到其他所有点的最短路，然后取最大值。

思路：Dijkstra 算法，邻接矩阵表示。

```java
public int networkDelayTime(int[][] times, int N, int K) {
    final int INF = (int) 1e7;
    int[][] edges = new int[N][N];      // 邻接矩阵
    for (int i = 0; i < N; i++) {
        Arrays.fill(edges[i], INF);
    }
    for (int[] t : times) {
        int src = t[0] - 1;             // 节点1~N，对应下标0~N-1
        int dst = t[1] - 1;
        edges[src][dst] = t[2];
    }

    int[] dist = new int[N];            // 所有路径的初始长度为无穷，K节点的长度为0
    Arrays.fill(dist, INF);
    dist[K - 1] = 0;
    boolean[] visited = new boolean[N];
    for (int i = 0; i < N; i++) {
        int src = -1;                    // 每次找到「最短距离最小」且「未被更新」的点 src
        for (int dst = 0; dst < N; dst++) {
            if (!visited[dst] &&  (src == -1 || dist[src] > dist[dst])) {
                src = dst;
            }
        }
        visited[src] = true;            // 标记点 src 为已更新
        for (int dst = 0; dst < N; dst++) {     // 用点 dst 的「最小距离」更新其他点
            dist[dst] = Math.min(dist[dst], dist[src] + edges[src][dst]);
        }
    }

    int maxDist = 0;
    for (int d : dist) {
        maxDist = Math.max(maxDist, d);
    }
    return maxDist == INF ? -1 : maxDist;
}
```



