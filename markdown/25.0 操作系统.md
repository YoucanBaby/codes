[toc]

# 一、概述

操作系统：控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。

## 基本特征

### 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

### 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 操作系统的运行机制

### 1. 两种指令

* 非特权指令：如普通的运算指令。
* 特权指令：不允许用户使用，如内存清零指令。

### 2. 两种处理器状态

* 用户态：只能执行非特权指令。
* 内核态：非特权指令、特权指令都可执行。

### 3. 两种程序

* 用户程序：只能执行非特权指令，运行在用户态。

* 内核程序：即能执行特权指令，也能执行非特权指令，运行在核心态。

## 操作系统的内核

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413195605594.png" alt="image-20210413195605594" style="zoom: 50%;" />

## 操作系统中的大内核和微内核

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413203621774.png" alt="image-20210413203621774" style="zoom: 67%;" />

**大内核和微内核的区别**：

* 大内核：将操作系统的**主要功能模块**作为内核。
* 微内核：将操作系统的**最基本的功能**保留在内核。

**各自的优缺点**：

* 大内核：**高性能**，但难以维护。
* 微内核：**方便维护**，但需要频繁地在核心态和用户态之间切换，性能低。

## 操作系统的体系结构

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413200503914.png" alt="image-20210413200503914" style="zoom:67%;" />

## 基本功能

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 中断分类

### 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

### 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

### 3. 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

Linux 的系统调用主要有以下这些：

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

## 原子操作

不可被中断的操作。

# 二、进程管理

## 进程、线程、协程

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408112037526.png" alt="image-20210408112037526" style="zoom:80%;" />

<img src="H:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210413142753186.png" alt="image-20210413142753186" style="zoom:67%;" />

协程：协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413144131808.png" alt="image-20210413144131808" style="zoom: 67%;" />

## 进程的状态与转换

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408111923615.png" alt="image-20210408111923615" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408105851331.png" alt="image-20210408105851331" style="zoom: 67%;" />

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 1. 批处理系统

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照<font color='orange'>请求的顺序</font>进行调度。

<font color='red'>有利于长作业，但不利于短作业</font>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计<font color='orange'>运行时间最短的顺序</font>进行调度。

<font color='red'>长作业有可能会饿死</font>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

<font color='red'>最短作业优先的抢占式版本</font>，按<font color='orange'>剩余运行时间最短的顺序</font>进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**1.4 最高响应比优先 highest response ratio next (HRRN)**

非抢占式的调度算法，按<font color='orange'>响应比最高的顺序</font>进行调度。

### 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转 round-robin（RR）** 

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

抢占式的调度算法。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408142737090.png" alt="image-20210408142737090" style="zoom:80%;" />

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408142750887.png" alt="image-20210408142750887" style="zoom:80%;" />

### 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### 4. 批处理系统与交互式系统的区别

* 批处理系统：需要预先编译命令
* 交互式系统：有一行命令就执行一行命令

## 进程同步

### 1. 临界区

对临界资源进行访问的那段代码称为临界区。

### 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```java
int s = 1;

void down (int s) {
    while (s<=0);
    s = s - 1;
}

void up (int s) {
    s = s + 1;
}
```

**使用信号量实现生产者-消费者问题** 

```c++
semaphore mutex = 1;		// 互斥信号量，实现对缓冲区的互斥访问
semaphore empty = N;		// 同步信号量，表示空闲缓冲区的数量
semaphore full = 0;			// 同步信号量，表示产品的数量，即非空缓冲区的数量

producer() {
    while(1) {
        生产一个产品;
        down(empty);		// 空闲缓冲区-1
        down(mutex);		// 上锁
        把产品放入缓冲区;
        up(mutex);			// 解锁
        up(full);			// 产品+1
    }
}

consumer() {
    while(1) {
        down(full);			// 产品-1
        down(mutex);		// 上锁
        从缓冲区中取出一个产品;
        up(mutex);			// 解锁
        up(empty);			// 空闲缓冲区+1
        使用产品;
    }
}
```

## 经典同步问题  

### 1. 读者-写者问题  

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

```c++
semaphore count_mutex = 1;		// 用于对 count 加锁
semaphore data_mutex = 1;		// 用于对读写的数据加锁
int count = 0;					// 记录在对数据进行读操作的进程数量

reader() {
    while(1) {
        down(count_mutex);			// count加锁
        if(count == 0) 
            down(data_mutex); 		// 第一个读者“加锁”
        count++;					// 读者+1
        up(count_mutex);			// count解锁
       	读文件;
        down(count_mutex);			// count加锁
        count--;					// 读者-1
        if(count == 0) 
            up(data_mutex);			// 最后一个读者“解锁”
		up(count_mutex);			// count解锁
	}
}

writer() {
    while(1) {
        down(data_mutex);			// 写者加锁
       	写文件;
        up(data_mutex);				// 写者解锁
    }
}
```

* 上述方法只要有读进程在读，写进程就一直阻塞，可能“饿死”，因此优化代码可以让“写优先”

### 2. 哲学家进餐问题  

* 出现次数少

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411112702468.png" alt="image-20210411112702468" style="zoom: 67%;" />

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。  

```c++
semaphore mutex = 1; 			// 临界区的互斥
semaphore chopstick[5] = {1,1,1,1,1}; 		// i号筷子

Pi() {	// i号哲学家的进程
    down(mutex);				// 加锁
    down(chopstick[i]);			// 拿左
    down(chopstick[(i+1)%5]);	// 拿右
    吃饭;
    up(mutex);					// 解锁
    up(chopstick[i]);			// 放左
    up(chopstick[(i+1)%5]);		// 放右
    思考;
}
```

* 以上方法会造成死锁，为了防止死锁的发生，可以设置两个条件：
  * 必须同时拿起左右两根筷子；
  * 只有在两个邻居都没有进餐的情况下才允许进餐。  

## 进程通信  

进程同步与进程通信很容易混淆，它们的区别在于：

* 进程同步：控制多个进程按一定顺序执行；

* 进程通信：进程间传输信息。


进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 1. 管道  

**在内存中开辟一个大小固定的缓冲区。**

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c++
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

* 只支持**半双工通信**（单向交替传输）；
* 只能在**父子进程**中使用。  

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411120150348.png" alt="image-20210411120150348" style="zoom: 67%;" />

### 2. FIFO  

也称为命名管道，**去除了管道只能在父子进程中使用的限制**。  

```c++
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

**FIFO 常用于客户-服务器应用程序中**，FIFO 用作汇聚点，**在客户进程和服务器进程之间传递数据**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411120452192.png" alt="image-20210411120452192" style="zoom: 67%;" />

### 3. 消息队列  

相比于 FIFO，消息队列具有以下优点：

* 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
* **避免了 FIFO 的同步阻塞问题**，不需要进程自己提供同步方法；
* 读进程可以根据消息类型**有选择地接收消息**，而不像 FIFO 那样只能默认地接收。  

### 4. 共享存储  

允许**多个进程共享一个给定的存储区**。因为数据不需要在进程之间复制，所以这是最快（**效率最高**）的一种 IPC 。

需要使用信号量用来同步对共享存储的访问。  

**多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存**。

XSI 共享内存不是使用文件，而是使用使用内存的匿名段。

### 5. 套接字（socket）

与其它通信机制不同的是，它可用于不同机器间的进程通信。

## 守护进程、孤儿进程、僵尸进程

### 1. 守护进程

Daemon（守护进程）是**运行在后台的一种特殊进程**。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。**它不需要用户输入就能运行而且提供某种服务，这种服务可提供给整个系统or某个用户。**Linux系统的大多数服务器就是通过守护进程实现的。

### 2. 孤儿进程

一个**父进程退出**，而它的**子进程还在运行**，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 3. 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。

**子进程退出**，而**父进程并没有调用 wait() 或 waitpid()**，那么**子进程的进程描述符仍然保存在系统中**，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie），要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

# 三、死锁

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411153345153.png" alt="image-20210411153345153" style="zoom: 80%;" />

## 必要条件  

* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 处理方法

主要有以下四种方法：

* 鸵鸟策略
* 死锁检测与死锁恢复
* 死锁预防
* 死锁避免  

## 鸵鸟策略  

把头埋在沙子里，假装根本没发生问题。  

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是**忽略它**。  

## 死锁检测与死锁恢复  

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。  

### 1. 每种类型一个资源的死锁检测  

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411170628257.png" alt="image-20210411170628257" style="zoom: 67%;" />

上图为资源分配图，其中**方框表示资源**，**圆圈表示进程**。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。
图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。
每种类型一个资源的死锁检测算法是通过**检测有向图是否存在环**来实现，**从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环**，也就是检测到死锁的发生。  

### 2. 每种类型多个资源的死锁检测  

### 3. 死锁恢复  

* 利用**抢占恢复**：挂起部分死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
* 利用**回滚恢复**：让部分死锁进程回滚到足以避免死锁的地步。
* 通过**杀死进程恢复**：强制杀死部分死锁进程。

## 死锁预防  

在程序运行之前预防发生死锁。  

### 1. 破坏互斥条件  

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。  

互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。

### 2. 破坏占有和等待条件  

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。  

### 3. 破坏不可抢占条件  

一种实现方法是当某个进程请求新资源得不到满足时，它必须立即释放所有资源。

不可抢占条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走。

### 4. 破坏环路等待  

给资源统一编号，进程只能按编号顺序来请求资源。  

## 死锁避免  

在程序运行时避免发生死锁。  

### 1. 安全状态  

* **不会发生死锁的状态。**

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411185326178.png" alt="image-20210411185326178" style="zoom: 80%;" />

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。  

### 2. 安全序列

* 系统按照这种序列分配资源，每个进程都能顺利完成，不会出现不安全状态

### 3. 多个资源的银行家算法  

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412094514752.png" alt="image-20210412094514752" style="zoom: 80%;" />

* **银行家算法**步骤：
  1. 检查此次申请的资源是否小于等于最大需求数（**Request <= Need**）
  2. 检查此次申请的资源是否小于等于系统剩余的可用资源（**Request <= Available**）
  3. 试着**分配资源**，更改对应的数据结构
  4. 用**安全性算法检查**此次分配是否会导致系统进入不安全状态

* **安全性算法**步骤：

  检查当前进程的最大需求数是否小于等于系统剩余的可用资源（**Need <= Available**），如果小于等于，就把该进程加入**安全序列**，并把该进程持有的**资源全部回收**。

  不断**重复上述过程**，看最终是否能将所有进程都加入安全序列。

# 四、内存管理

## 虚拟内存

虚拟内存的目的：为了让**物理内存扩充成更大的逻辑内存**，从而让程序获得**更多的可用内存**。

虚拟内存实现方法：**操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个大小固定的块，每一块称为一页，每一页再与物理地址进行映射。**

虚拟内存**允许程序不用将地址空间中的每一页都映射到物理内存**，即**一个程序不需要全部调入内存就可以运行**。

优点： 

1. **扩充内存** 
2. 多次性，**允许作业被分成多次调入内存**。
3. 对换性，**允许在作业运行过程中，将作业换入、换出**

**局部性原理**：**时间局部性**，在一段时间内，整个程序的执行仅限于程序的某一部分；**空间局部性**，程序访问的存储空间局限于某一内存区域。

虚拟内存基于局部性原理设计的，采用分页技术。

## 分页

分页的做法：**把地址空间被分割成多个大小固定的块，每一块称为一页，每一页再与物理地址进行映射。**

**内存管理单元**（MMU）负责虚拟地址和物理地址的转换。

**页表**存储着**虚拟地址和物理地址的映射表**。

**虚拟地址**：**页号➕偏移量**。  

物理地址：页框号➕偏移量。

地址空间：虚拟地址空间

物理内存：物理地址空间

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412202627400.png" alt="image-20210412202627400" style="zoom:67%;" />

**局部性原理**：在一段时间内，整个程序的执行仅限于程序的某一部分（**时间局部性**），相应地，程序访问的存储空间也局限于某个内存区域（**空间局部性**）。

虚拟内存基于局部性原理设计的，采用分页技术。

## 分段

分段的做法：把**地址空间分成段**，一个段构成一个独立的地址空间。**每个段的长度可以不同**，并且可以**动态增长**。

优点：

1. 共享：一个段可以被多个进程使用
2. 保护：进程不会访问超出该段的内存单元

## 段页式

段页式的做法：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

## 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

## 页面置换算法  

也称为缓存更新算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法的主要目标是使**缺页率最低**。

### 1. 先进先出

> **FIFO**, First In First Out

**每次淘汰最先进入的页面。**

该算法会将那些经常被访问的页面换出，导致**缺页率最高**。

### 2. 最佳

> **OPT**, Optimal replacement algorithm

**每次淘汰最长时间内不再被访问的页面**，通常可以保证**缺页率最低**。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412163310273.png" alt="image-20210412163310273" style="zoom: 67%;" />

### 3. 最近最久未使用

> **LRU**, Least Recently Used

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU **每次淘汰最近最久未使用的页面**。

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此实现 LRU **代价很高**。

```
4，7，0，7，1，0，1，2，1，2，6
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412163214596.png" alt="image-20210412163214596" style="zoom: 67%;" />

### 4. 最近未使用

> **NRU**, Not Recently Used

**知道名称即可**

改进型的时钟置换算法，每个页面都有两个状态位：R（访问位） 与 M（修改位），当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### 5. 时钟

> **Clock**

**知道名称即可**

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法**使用环形链表将页面连接起来**，再使用一个指针指向最老的页面。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412161223013.png" alt="image-20210412161223013" style="zoom:67%;" />

### 6. 第二次机会算法

**知道名称即可**

FIFO 算法的改进版，FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

# 五、文件管理

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210414144134966.png" alt="image-20210414144134966" style="zoom:80%;" />

# 六、设备管理

## 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

[![img](https://camo.githubusercontent.com/062b5e89146b6df61a790e3585635f2d8892ab9f8f6181da26aa58a9cbd55922/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067)](https://camo.githubusercontent.com/062b5e89146b6df61a790e3585635f2d8892ab9f8f6181da26aa58a9cbd55922/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067)



## 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

### 1. 先来先服务

> FCFS, First Come First Served

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

### 2. 最短寻道时间优先

> SSTF, Shortest Seek Time First

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

[![img](https://camo.githubusercontent.com/4aaee136900eb1ece1352fa6ca5b92f37e59801a6fcd0a2345afa73ca44fd5b0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67)](https://camo.githubusercontent.com/4aaee136900eb1ece1352fa6ca5b92f37e59801a6fcd0a2345afa73ca44fd5b0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67)



### 3. 电梯算法

> SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

[![img](https://camo.githubusercontent.com/e4956eee145c33a868e367fe6a32eb40465503a4e6a31755ca4fe5a4a83d4019/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67)](https://camo.githubusercontent.com/e4956eee145c33a868e367fe6a32eb40465503a4e6a31755ca4fe5a4a83d4019/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67)

## 假脱机技术

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210414155125491.png" alt="image-20210414155125491" style="zoom: 67%;" />

# 七、链接

## 编译系统

以下是一个 hello.c 程序：

```
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```
gcc -o hello hello.c
```

这个过程大致如下：

[![img](https://camo.githubusercontent.com/b106110f7870e9d6faef1e5831e1ed97b94076cfbb9929cd006606f9adeb41ce/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62333936643732362d623735662d346133322d383961322d3033613762366531396636662e6a7067)](https://camo.githubusercontent.com/b106110f7870e9d6faef1e5831e1ed97b94076cfbb9929cd006606f9adeb41ce/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62333936643732362d623735662d346133322d383961322d3033613762366531396636662e6a7067)



- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

## 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

[![img](https://camo.githubusercontent.com/b5a16d3176db7f213f470c2d877c08b75e8fcc43ef1cc6f930b340320f2c8e9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34376439383538332d386262302d343563632d383132642d3437656566613061346134302e6a7067)](https://camo.githubusercontent.com/b5a16d3176db7f213f470c2d877c08b75e8fcc43ef1cc6f930b340320f2c8e9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34376439383538332d386262302d343563632d383132642d3437656566613061346134302e6a7067)



## 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

## 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

[![img](https://camo.githubusercontent.com/e4bd3c0074bc832f7b8f4d7dda678b26a51185668d5afc2f14af14198051d1eb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37366463373736392d316161632d343838382d396265612d3036346631636161386537372e6a7067)](https://camo.githubusercontent.com/e4bd3c0074bc832f7b8f4d7dda678b26a51185668d5afc2f14af14198051d1eb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37366463373736392d316161632d343838382d396265612d3036346631636161386537372e6a7067)