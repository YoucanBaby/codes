# 排序

## 桶排序

### [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809093106.png" alt="image-20210809093106809" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809093049.png" alt="image-20210809093049787" style="zoom:80%;" />

不会 * 2

思路：桶排序（HashMap实现）。

令桶的大小为 `size = t + 1`，根据 `nums[i]`（简写为 `num`） 计算所在桶编号`index`：

- 如果哈希表里已经存在该桶，说明前面已有 `[num - t, num + t]` 范围的数字，返回 `true` 
- 如果不存在该桶，则检查相邻两个桶的元素是有 `[num - t, num + t]` 范围的数字，如有 返回 `true`
- 否则建立目标桶，哈希表里只保留下标范围在 `[max(0, i - k), i)` 内的桶

`getIdx`：

* `0 1 2 3` 落在同一个桶中，即 ` num / size`  ==  0
* `-4 -3 -2 -1` 落在同一个桶中，即 `(num + 1) / size - 1`  ==  -1

```java
class Solution {
    long size = 0;      // 桶的大小

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        HashMap<Long, Long> map = new HashMap<>();
        size = t + 1L;
        for (int i = 0; i < nums.length; i++) {
            long num = nums[i] * 1L;
            long index = getIdx(num);
            if (map.containsKey(index)) {   // 目标桶是否存在
                return true;
            }

            long left = index - 1;
            long right = index + 1;         // 检查相邻的桶
            if (map.containsKey(left) && num - t <= map.get(left)) {
                return true;
            }
            if (map.containsKey(right) && map.get(right) <= num + t) {
                return true;
            }

            map.put(index, num);
            if (i >= k) {
                map.remove(getIdx(nums[i - k]) * 1L);   // 移除下标范围不在[max(0, i - k), i)内的桶,
            }
        }
        return false;
    }

    private long getIdx(long num) {
        return num >= 0 ? num / size : (num + 1) / size - 1;
    }
}
```

## 计数排序

### [1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809121653.png" alt="image-20210809121653819" style="zoom:80%;" />

思路：模拟。统计 `nums1` 中每个元素出现的次数，然后根据 `nums2` 的顺序，把 `nums1` 的元素添加正确的位置上。枚举统计数组，把剩余的元素，按照升序放到结果数组的末尾。

```java
public int[] relativeSortArray(int[] nums1, int[] nums2) {
    int max = Arrays.stream(nums1).max().getAsInt();
    int[] freq = new int[max + 1];
    for (int num : nums1) {
        freq[num]++;
    }

    int[] res = new int[nums1.length];
    int index = 0;
    for (int i = 0; i < nums2.length; i++) {
        while (freq[nums2[i]] > 0) {
            res[index++] = nums2[i];
            freq[nums2[i]]--;
        }
    }

    for (int i = 0; i < freq.length; i++) {
        while (freq[i] > 0) {
            res[index++] = i;
            freq[i]--;
        }
    }
    return res;
}
```

### [1846. 减小和重新排列数组后的最大元素](https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809152735.png" alt="image-20210809152735135" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809152753.png" alt="image-20210809152753762" style="zoom:80%;" />

思路：计数，统计所有数字出现的频率，超过长度 `N` 的数字，就让 `count[N]++` 。枚举计数数组，返回能到达最远下标。

```java
public int maximumElementAfterDecrementingAndRearranging(int[] nums) {
    int N = nums.length;
    int[] count = new int[N + 1];
    for (int num : nums) {
        if (num >= N) {
            count[N]++;
        } else {
            count[num]++;
        }
    }

    int res = 1;
    for (int i = 1; i <= N; i++) {
        res = Math.min(res + count[i], i);
    }
    return res;
}
```

# 贪心

## 计数

### [274. H 指数](https://leetcode-cn.com/problems/h-index/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809141429.png" alt="image-20210809141412127" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927234824.png" alt="image-20210809141419948" style="zoom:80%;" />

输入`int[] citations = {3,0,6,1,5}`

<img src="https://pic.leetcode-cn.com/1439a3fe36a95008acb7d718131f94030ff103b4b370061daa6405dbfc533ae0-1568344538481.png" alt="1568344538481.png" style="zoom: 67%;" />

* H指数不会超过数组的长度N。所以小于N的引用量分别计数；大于等于N的引用量单独计数，即 `count[N]++`
* 从后向前统计大于等于h的引用量总数，如果引用量总数>=h，就是我们要找的h

思路：贪心，计数。枚举引用数组，引用数超过数组长度的，记录在N上面，其他记录在对应的位置。然后从后向前枚举计数数组，累加上引用的次数，如果引用总和超过当前位置的下标，就返回这个下标。

```java
public int hIndex(int[] citations) {
    int N = citations.length;
    int[] freq = new int[N + 1];
    for (int c : citations) {
        if (c >= N) freq[N]++;
        else freq[c]++;
    }
    int sum = 0;
    for (int h = N; h >= 0; h--) {
        sum += freq[h];
        if (sum >= h) return h;
    }
    return 0;
}
```

### [945. 使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210812101021.png" alt="image-20210812101021465" style="zoom:80%;" />

思路：统计数组中每个数字的出现频率。然后枚举计数数组，只要当前位置的频率超过1，就把多的频率加到下一个位置上，多的频率累加到结果上。最后一个位置上用求和公式单独计算。

```java
public int minIncrementForUnique(int[] nums) {
    int[] freq = new int[200000];		// 大小为200000，是因为有些用例超了过40000了，这题不严谨
    int max = 0;
    for (int num : nums) {
        freq[num]++;
        max = Math.max(max, num);
    }

    int res = 0;
    for (int i = 0; i < max; i++) {
        if (freq[i] > 1) {				// 若当前数字的个数freq[i]大于1个，则只留下1个，其他的freq[i]-1个后移
            res += freq[i] - 1;
            freq[i + 1] += freq[i] - 1;		
        }
    }

    if (freq[max] > 1) {				// freq[max] 单独计算
        int n = freq[max] - 1;			// 有n个需要增加，分别增加为max+1，max+2...，max+n
        res += (n + 1) * n / 2;			// 使用等差数列公式求和
    }
    return res;
}
```

### [1833. 雪糕的最大数量](https://leetcode-cn.com/problems/maximum-ice-cream-bars/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809123730.png" alt="image-20210809123730166" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809123756.png" alt="image-20210809123756039" style="zoom:80%;" />

思路：对雪糕的所有花费计数，然后从小枚举到大，直到现金数不能支付下一根雪糕了。		

```java
public int maxIceCream(int[] costs, int coins) {
    int[] freq = new int[(int) (1e5 + 1)];
    for (int cost: costs) {
        freq[cost]++;
    }
    int res = 0;
    for (int cost = 1; cost < freq.length; cost++) {
        if (coins < cost) {
            break;
        } else {
            int minCount = Math.min(freq[cost], coins / cost);      // 最多可以买多少根
            coins -= cost * minCount;
            res += minCount;
        }
    }
    return res;
}
```

### [881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826032746.png" alt="image-20210826032745970" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210826032757.png" alt="image-20210826032757739" style="zoom:80%;" />

时间：$O(N)$

思路：对每个人的体重计数。双指针：如果两人体重总和不超过 limit ，一起上船；如果超重了，先让重的上船。

```java
public int numRescueBoats(int[] people, int limit) {
    int[] weights = new int[limit + 1];
    for (int weight : people) {
        weights[weight]++;
    }

    int res = 0;
    int left = 0;
    int right = limit;
    while (left <= right) {
        // weights[left] <= 0，是因为当left和right相等且left+right<=limit的时候，weights[i]是可能是-1
        while (left <= right && weights[left] <= 0) {
            left++;
        }
        while (left <= right && weights[right] <= 0) {
            right--;
        }
        if (left <= right) {
            if (left + right <= limit) {
                weights[left]--;
                weights[right]--;
            } else {
                weights[right]--;
            }
            res++;
        }
    }
    return res;
}
```

# 二分查找

### [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928050433.png" alt="image-20210928050433813" style="zoom:80%;" />

思路：二分查找。错误版本在右边，找错误版本的左边界。

```java
public int firstBadVersion(int n) {
    int left = 1;
    int right = n;

    while (left <= right) {
        int mid = left + (right - left) / 2;		// 注意越界
        if (isBadVersion(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### [275. H 指数 II](https://leetcode-cn.com/problems/h-index-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809145510.png" alt="image-20210809145510732" style="zoom:80%;" />

不会 * 2

思路：**二分查找**。找到满足 `citations[i] >= n - i` 的第一个 `citations[i]`。

```java
public int hIndex(int[] citations) {
    int N = citations.length;
    if (citations[N - 1] == 0) return 0;    // 特殊情况，输入[0]，返回0

    int left = 0, right = N - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (citations[mid] >= N - mid) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return N - left;
}
```

### [1283. 使结果不超过阈值的最小除数](https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928051939.png" alt="image-20210928051939572" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928051928.png" alt="image-20210928051928768" style="zoom:67%;" />

```java
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int left = 0;
        int right = (int) 1e6;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (sum(nums, mid) <= threshold) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int sum(int[] nums, int mid) {
        int sum = 0;
        for (int num : nums) {
            sum += Math.ceil((double) num / mid);
        }
        return sum;
    }
}
```

### [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210815113716.png" alt="image-20210815113716034" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210815113730.png" alt="image-20210815113730367" style="zoom:80%;" />

二分查找放弃。

思路：暴力。两层循环枚举数组，求分数，对分数排序，返回第k个。

```java
public int[] kthSmallestPrimeFraction(int[] nums, int k) {
    int N = nums.length;
    TreeMap<Double, int[]> treeMap = new TreeMap<>();

    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            treeMap.put((double)nums[i] / nums[j], new int[]{nums[i], nums[j]});
        }
    }
    for (int i = 1; i < k; i++) {
        treeMap.remove(treeMap.firstKey());
    }
    return treeMap.get(treeMap.firstKey());
}
```

### [778. 在水位上升的泳池中游泳](https://leetcode-cn.com/problems/swim-in-rising-water/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210813103236.png" alt="image-20210813102557082" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210813103232.png" alt="image-20210813102611700" style="zoom:80%;" />

思路：二分查找找合适水位的最小值。用DFS判断能否从左上角游到右下角。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };
    boolean[][] visited;

    public int swimInWater(int[][] mat) {
        int N = mat.length;
        visited = new boolean[N][N];

        int left = 0;
        int right = (int) 1e6;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (possible(mat, mid, 0, 0)) {     // 能到达右下角
                right = mid - 1;
            } else {
                left = mid + 1;
            }
            visited = new boolean[N][N];
        }
        return left;
    }

    private boolean possible(int[][] mat, int mid, int x, int y) {
        if (!inArea(mat, x, y)) return false;
        if (mat[x][y] > mid) return false;
        if (visited[x][y]) return false;

        if (x == mat.length - 1 && y == mat.length - 1) {
            return true;
        }
        visited[x][y] = true;
        boolean res = false;
        for (int[] dir : dirs) {
            res |= possible(mat, mid, x + dir[0], y + dir[1]);
        }
        return res;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [719. 第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210812052414.png" alt="image-20210812052414497" style="zoom:80%;" />

思路：先对数组排序，再二分查找第 k 个最小的距离对，用双指针计算数对的数量。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928184117.png" alt="image-20210928184117669" style="zoom: 80%;" />

```java
class Solution {
    public int smallestDistancePair(int[] nums, int K) {
        Arrays.sort(nums);
        int left = 0;
        int right = nums[nums.length - 1] - nums[0];

        while (left <= right) {
            int mid = (left + right) / 2;
            if (possible(nums, K, mid)) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // 小于等于mid的数对个数是否有K个（超过K也算）
    private boolean possible(int[] nums, int K, int mid) {
        int count = 0;
        int N = nums.length;
        int i = 0;
        for (int j = 0; j < N; j++) {
            while (nums[j] - nums[i] > mid) {
                i++;
            }
            count += j - i;
        }
        return count >= K;
    }
}
```

### [1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809160840.png" alt="image-20210809160840689" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210809160912.png" alt="image-20210809160912272" style="zoom:80%;" />

思路：**优先队列 + 二分查找**。

「**二分**」找到每一行最后一个军人的位置。

建立一个「**战力大根堆**」，堆顶元素为战力最大的数对，「战力大根堆」存放 `{军人数量, 下标}`，。

时间：$O(MlogN)$

```java
class Solution {
    public int[] kWeakestRows(int[][] mat, int k) {
        int M = mat.length;
        // {下标，军人出现次数}
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[1] != b[1]) {
                return b[1] - a[1];
            } else {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < M; i++) {
            int num = binarySearch(mat[i]);
            pq.add(new int[] {i, num});
        }

        while (pq.size() > k) {
            pq.poll();
        }
        int[] res = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            res[i] = pq.poll()[0];
        }
        return res;
    }

    public int binarySearch(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == 1) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left] == 1 ? left + 1 : left;	// 如果最后返回的下标对应的nums[下标]为1，则结果要+1
    }
}
```

### [1818. 绝对差值和](https://leetcode-cn.com/problems/minimum-absolute-sum-difference/)

不会，还是不会。

思路：**贪心** + **二分查找**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210714034015.png" alt="image-20210714034014952" style="zoom:80%;" />

* 我们需要让 `nums1[j]` 尽可能的大，这样可以使得答案尽可能小。 所以新建一个数组 `nums`，深拷贝`nums1`，保证 `nums` 有序。
* 遍历数组 `nums1`。每次就二分查找，**找到一个最接近 `nums2[i]` 的值**，不断比对，找到能优化的最大值。二分查找需要自己写，就算找不到目标值，也要返回接近的下标，内置的二分查找如果找不到目标，会返回一个负数。
* 最后结果 `(sum - max + MOD) % MOD`，加上 `MOD` 是因为有的结果已经超过 `MOD` 变成负数了，加上`MOD` 再 模上 `MOD`，得到正数。

```java
public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
    int MOD = (int) (Math.pow(10, 9) + 7);
    int N = nums1.length;

    int[] nums = new int[N];
    System.arraycopy(nums1,0, nums, 0, N);
    Arrays.sort(nums);

    int sum = 0;
    int max = 0;
    for (int i = 0; i < N; i++) {
        int diff = Math.abs(nums1[i] - nums2[i]);
        sum = (sum + diff) % MOD;
        int j = binarySearch(nums, nums2[i]);
        max = Math.max(max, diff - Math.abs(nums[j] - nums2[i]));
        if (j + 1 < N) {
            max = Math.max(max, diff - Math.abs(nums[j + 1] - nums2[i]));
        }
        if (j - 1 >= 0) {
            max = Math.max(max, diff - Math.abs(nums[j - 1] - nums2[i]));
        }
    }
    return (sum - max + MOD) % MOD;
}

public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return left == nums.length ? left - 1 : left;       // 左边界越界
}
```

### [475. 供暖器](https://leetcode-cn.com/problems/heaters/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928212128.png" alt="image-20210928212127953" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928212344.png" alt="image-20210928212344290" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928212200.png" alt="image-20210928212200713" style="zoom:80%;" />

思路：先对数组排序。再枚举房屋，二分查找离当前房屋最近的供暖器，更新房屋离供暖器最远的距离。

```java
class Solution {
    // 遍历house，得到坐标小于heater的个数，再得到house离heater最近的距离，更新这个距离。
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(houses);
        Arrays.sort(heaters);

        int res = 0;
        for (int house : houses) {
            int index = binarySearch(heaters, house);
            int leftDist = index - 1 >= 0 ? house - heaters[index - 1] : Integer.MAX_VALUE;
            int rightDist = index < heaters.length ? heaters[index] - house : Integer.MAX_VALUE;
            res = Math.max(res, Math.min(leftDist, rightDist));
        }
        return res;
    }

    private int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                right = mid - 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

### [1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928220820.png" alt="image-20210928220820848" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928220827.png" alt="image-20210928220827396" style="zoom:80%;" />

思路：二分查找使得结果接近 `target` 的最小值。

最后打个补丁：可能 `right` 和 `left` 离 `target` 的距离都一样，这种时候返回 `right`

```java
class Solution {
    public int findBestValue(int[] nums, int target) {
        int left = 0;
        int right = Arrays.stream(nums).max().getAsInt();

        while (left <= right) {
            int mid = (left + right) / 2;
            if (getSum(nums, mid) >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        int diff1 = Math.abs(target - getSum(nums, right));
        int diff2 = Math.abs(target - getSum(nums, left));
        return diff1 <= diff2 ? right : left;
    }

    private int getSum(int[] nums, int mid) {
        int sum = 0;
        for (int num : nums) {
            sum += Math.min(num, mid);
        }
        return sum;
    }
}
```

### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928234217.png" alt="image-20210928234217233" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928234355.png" alt="image-20210928234355606" style="zoom:80%;" />

```java
public int peakIndexInMountainArray(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] > nums[mid + 1]) {		// ">"改成">="也可以
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```



# 二叉树

## 二叉搜索树

### [1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824140147.png" alt="image-20210824140147218" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824140201.png" alt="image-20210824140201099" style="zoom:80%;" />

不会 * 2

题意：根据前序遍历数组构造二叉搜索树。

思路：DFS**前序遍历**。

```java
class Solution {
    int index = 0;

    public TreeNode bstFromPreorder(int[] preorder) {
        return dfs(preorder, Integer.MAX_VALUE);
    }
	
    // max是当前节点不能超过的值
    private TreeNode dfs(int[] preorder, int max) {
        if (index == preorder.length || preorder[index] > max) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[index++]);
        
        root.left = dfs(preorder, root.val);
        root.right = dfs(preorder, max);

        return root;
    }
}
```

### [897. 递增顺序搜索树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824024153.png" alt="image-20210824024153012" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824024220.png" alt="image-20210824024220189" style="zoom:80%;" />

时间：$O(N)$  ，空间：$O(N)$

思路：DFS**中序遍历**，把所有节点按照中序遍历的顺序放入链表，再把链表构造成只有右子节点的树。

```java
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        dfs(root, list);

        TreeNode newNode = new TreeNode(-1);
        TreeNode cur = newNode;
        for (int value : list) {
            cur.right = new TreeNode(value);
            cur = cur.right;
        }
        return newNode.right;
    }

    private void dfs(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        dfs(root.left, list);
        list.add(root.val);
        dfs(root.right, list);
    }
}
```

### [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822230532.png" alt="image-20210822230532448" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822230540.png" alt="image-20210822230540635" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211012132417.png" alt="image-20211012132410172" style="zoom: 80%;" />

这是 [108. 将有序数组转换为高度平衡的二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) 的扩展

思路：先把二叉搜索树转为 list，再通过 list 构造平衡的二叉搜索树。

```java
class Solution {
    public TreeNode balanceBST(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        bst2List(list, root);
        return dfs(list, 0, list.size() - 1);
    }

    public TreeNode dfs(List<Integer> list, int left, int right) {
        if (left > right) {
            return null;
        }

        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(list.get(mid));

        root.left = dfs(list, left, mid - 1);
        root.right = dfs(list, mid + 1, right);

        return root;
    }

    public void bst2List(List<Integer> list, TreeNode root) {
        if (root == null) {
            return;
        }
        bst2List(list, root.left);
        list.add(root.val);         // 中序遍历
        bst2List(list, root.right);
    }
}
```

### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823194739.png" alt="image-20210823194739124" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211012153423.png" alt="image-20210823195622391" style="zoom:80%;" />

不会 * 2

思路：DFS后序遍历 + 回溯。

```java
class Solution {
    public List<TreeNode> generateTrees(int N) {
        return dfs(1, N);
    }

    private List<TreeNode> dfs(int start, int end) {
        List<TreeNode> list = new ArrayList<>();

        if (start > end) {
            list.add(null);					// 没有子树，要加null
            return list;
        }

        for (int i = start; i <= end; i++) {
            List<TreeNode> leftList = dfs(start, i - 1);
            List<TreeNode> rightList = dfs(i + 1, end);

            for (TreeNode left : leftList) {		
                for (TreeNode right : rightList) {		// 固定左孩子，遍历右孩子
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    list.add(root);
                }
            }
        }
        return list;
    }
}
```

### [285. 二叉搜索树中的中序后继](https://leetcode-cn.com/problems/inorder-successor-in-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822203140.png" alt="image-20210822203140042" style="zoom:80%;" />

不会。

思路：迭代。当前节点小于等于目标节点，就去右边找；反之，更新结果，再去左边找。

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode res = null;
    while (root != null) {
        if (root.val <= p.val) {
            root = root.right;
        } else {
            res = root;
            root = root.left;
        }
    }
    return res;
}
```

### [510. 二叉搜索树中的中序后继 II](https://leetcode-cn.com/problems/inorder-successor-in-bst-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822211841.png" alt="image-20210822211841021" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822212154.png" alt="image-20210822212154051" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822212606.png" alt="image-20210822212605905" style="zoom:80%;" />

不会 * 2

预备知识：

- 前驱：指的是中序遍历的上一个结点，或者说是比当前结点小的最大结点。
- 后继：指的是中序遍历的下一个结点，或者说是比当前结点大的最小结点。

思路：

* 若 `node` 结点有右孩子，则它的后继在树中相对较低的位置。我们向右走一次，再尽可能的向左走，返回最后所在的结点。
* 若 `node` 结点没有右孩子，则它的后继在树中相对较高的位置。我们向上走到直到结点 `parent` 的左子树中包含 `node`时，则 `node` 的后继为 `parent`。

```java
class Solution {
    public Node inorderSuccessor(Node node) {
        if (node == null) {
            return null;
        }

        if (node.right != null) {
            return getMostLeft(node.right);
        } else {
            Node parent = node.parent;
            while (parent != null && parent.right == node) {
                node = parent;
                parent = node.parent;
            }
            return parent;
        }
    }

    private Node getMostLeft(Node node) {
        if (node == null) {
            return null;
        }
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}
```

### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822204451.png" alt="image-20210822204451500" style="zoom:80%;" />

不会 * 2

思路1:  **DFS中序遍历**，用 `preValue` 记录上一个出现的的数字，用 `count` 记录当前数字重复的次数，用 `maxCount` 来维护已经扫描过的数当中出现最多的那个数字的出现次数，用 `list `记录出现的众数。

更新操作：每次扫描到一个新的元素：

* 首先更新 `preValue` 和 `count`

* 然后更新 `maxCount`

```java
class Solution {
    int preValue = 0;
    int count = 0;
    int maxCount = 0;
    List<Integer> list = new ArrayList<>();

    public int[] findMode(TreeNode root) {
        dfs(root);

        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        dfs(root.left);
        update(root.val);
        dfs(root.right);
    }

    private void update(int val) {
        if (val == preValue) {
            count++;
        } else {
            preValue = val;
            count = 1;
        }

        if (count == maxCount) {
            list.add(preValue);
        } else if (count > maxCount) {
            list.clear();
            list.add(preValue);
            maxCount = count;
        }
    }
}
```

### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822211451.png" alt="image-20210822211451548" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822211335.png" alt="image-20210822211335363" style="zoom:80%;" />

不会。

思路：**逆序中序遍历**。二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。

```java
class Solution {
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        if (root == null) {
            return null;
        }

        convertBST(root.right);
        sum += root.val;
        root.val = sum;
        convertBST(root.left);

        return root;
    }
}
```

### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824125101.png" alt="image-20210824125101777" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824125115.png" alt="image-20210824125115115" style="zoom:80%;" />

题意：本题是要输出中序遍历数组中，大于等于left 并且 小于等于right 的数的总和。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824125315.png" alt="image-20210824125315694" style="zoom:50%;" />

```java
class Solution {
    int res = 0;

    public int rangeSumBST(TreeNode root, int left, int right) {
        dfs(root, left, right);
        return res;
    }

    private void dfs(TreeNode root, int left, int right) {
        if (root == null) {
            return;
        }

        dfs(root.left, left, right);
        if (left <= root.val && root.val <= right) {
            res += root.val;
        }
        dfs(root.right, left, right);
    }
}
```

## BFS的应用

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821105307.png" alt="image-20210821105307342" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821105212.png" alt="image-20210821105212813" style="zoom:80%;" />

时间：$O(N)$，空间：$O(1)$

思路：DFS前序遍历，连接两个节点，连接相同父节点的两个子节点，连接跨越父节点的两个子节点。

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return null;
        }
        connectTwoNodes(root.left, root.right);
        return root;
    }

    private void connectTwoNodes(Node node1, Node node2) {
        if (node1 == null || node2 == null) {
            return;
        }	
        node1.next = node2;								// 连接两个节点
		
        connectTwoNodes(node1.left, node1.right);		// 连接相同父节点的两个子节点
        connectTwoNodes(node2.left, node2.right);		// 连接相同父节点的两个子节点
	
        connectTwoNodes(node1.right, node2.left);		// 连接跨越父节点的两个子节点
    }
}
```

### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822125528.png" alt="image-20210822125528097" style="zoom:80%;" />

时间：$O(N)$ ，空间：$O(N)$

```java
public List<Integer> largestValues(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.add(root);

    while (!deque.isEmpty()) {
        int N = deque.size();
        int max = Integer.MIN_VALUE;

        for (int i = 0; i < N; i++) {
            TreeNode node = deque.removeFirst();
            if (node.left != null) {
                deque.add(node.left);
            }
            if (node.right != null) {
                deque.add(node.right);
            }
            max = Math.max(max, node.val);
        }
        res.add(max);
    }
    return res;
}
```

### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822125731.png" alt="image-20210822125731834" style="zoom:80%;" />

时间：$O(N)$ ，空间：$O(N)$

```java
public List<Double> averageOfLevels(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Double> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.add(root);

    while (!deque.isEmpty()) {
        int N = deque.size();
        double sum = 0;

        for (int i = 0; i < N; i++) {
            TreeNode node = deque.removeFirst();
            if (node.left != null) {
                deque.add(node.left);
            }
            if (node.right != null) {
                deque.add(node.right);
            }
            sum += node.val;
        }
        res.add(sum / N);
    }
    return res;
}
```

### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211104134814.png" alt="image-20211104134814087" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211104134653.png" alt="image-20211104134653860" style="zoom:80%;" />

思路：BFS。

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.addLast(root);
        int res = -1;

        while (!deque.isEmpty()) {
            int size = deque.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = deque.removeFirst();
                if (node.left != null) deque.addLast(node.left);
                if (node.right != null) deque.addLast(node.right);
                if (i == 0) res = node.val;
            }
        }
        return res;
    }
}
```

## 二叉树的属性

### [298. 二叉树最长连续序列](https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824025051.png" alt="image-20210824025051141" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824025109.png" alt="image-20210824025109516" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824025131.png" alt="image-20210824025131090" style="zoom:80%;" />

时间：$O(N)$  ，空间：$O(N)$

思路：当前节点的

```java
class Solution {
    int max = 0;

    public int longestConsecutive(TreeNode root) {
        dfs(root, null, 0);
        return max;
    }

    private void dfs(TreeNode root, TreeNode parent, int length) {
        if (root == null) {
            return;
        }

        if (parent == null || root.val != parent.val + 1) {
            length = 1;
        } else {
            length++;
        }
        max = Math.max(max, length);

        dfs(root.left, root, length);
        dfs(root.right, root, length);
    }
}
```

### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821174644.png" alt="image-20210821174644032" style="zoom:80%;" />

思路：当前节点的左节点是叶子节点，就把它的值加到结果上。

```java
class Solution {

    int res = 0;

    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }

        if (root.left != null) {
            if (root.left.left == null && root.left.right == null) {
                res += root.left.val;
            }
        }
        sumOfLeftLeaves(root.left);
        sumOfLeftLeaves(root.right);

        return res;
    }
}
```

### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824140930.png" alt="image-20210824140929905" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824140941.png" alt="image-20210824140941583" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824141015.png" alt="image-20210824141014981" style="zoom:80%;" />

思路：DFS**后序遍历**。在 求左右子树的节点总和 的基础上，求每个节点的坡度。

```java
class Solution {
    int res = 0;

    public int findTilt(TreeNode root) {
        dfs(root);
        return res;
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftSum = dfs(root.left);
        int rightSum = dfs(root.right);

        res += Math.abs(leftSum - rightSum);
        return root.val + leftSum + rightSum;
    }
}
```

### [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823224221.png" alt="image-20210823224221660" style="zoom:80%;" />

不会。时间：$O(N)$  ，空间：$O(N)$

思路：DFS前序遍历。根左右。

```java
public String tree2str(TreeNode root) {
    if (root == null) {
        return "";
    }

    if (root.left == null && root.right == null) {
        return "" + root.val;
    } else if (root.right == null) {
        return root.val + "(" + tree2str(root.left) + ")";
    } else {
        return root.val + "(" + tree2str(root.left) + ")" + "(" + tree2str(root.right) + ")";
    }
}
```

使用 sb

```java
class Solution {

    StringBuilder sb = new StringBuilder();

    public String tree2str(TreeNode root) {
        if (root == null) {
            return "";
        }

        if (root.left == null && root.right == null) {
            sb.append(root.val);
        } else if (root.right == null) {
            sb.append(root.val + "(");
            tree2str(root.left);
            sb.append(")");
        } else {
            sb.append(root.val + "(");
            tree2str(root.left);
            sb.append(")" + "(");
            tree2str(root.right);
            sb.append(")");
        }
        return sb.toString();
    }
}
```

### [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821183401.png" alt="image-20210821183401087" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821183429.png" alt="image-20210821183429311" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821183451.png" alt="image-20210821183451141" style="zoom:80%;" />

思路：DFS先序遍历。要加入一个flag，判断倒数第二小的值是否更新。

**1. 确定递归函数的参数和返回值**：输入根节点，无输出（用全局变量代替了）

**2. 确定终止条件**：越过叶子节点，返回空

**3. 确定单层递归的逻辑**：

* 当前节点的值 **小于** 最小值，那就更新 最小值 和 倒数第二小的值
* 当前节点的值 **大于** 最小值，但是 **小于等于** 倒数第二小的值，就更新倒数第二小的值（**小于等于**是为了避免出现`[2,2,Integer.MAX_VALUE]` 这种情况）

```java
class Solution {
    int min1 = Integer.MAX_VALUE;   // 最小值
    int min2 = Integer.MAX_VALUE;   // 倒数第二小的值
    boolean flag;                   // 倒数第二小的值是否更新

    public int findSecondMinimumValue(TreeNode root) {
        dfs(root);
        return flag == true ? min2 : -1;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        if (root.val < min1) {
            min2 = min1;
            min1 = root.val;
        }
        if (min1 < root.val && root.val <= min2) {
            min2 = root.val;
            flag = true;
        }
        
        dfs(root.left);
        dfs(root.right);
    }
}
```

### [872. 叶子相似的树](https://leetcode-cn.com/problems/leaf-similar-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824195955.png" alt="image-20210824195954901" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824200017.png" alt="image-20210824200017198" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824200026.png" alt="image-20210824200026571" style="zoom:80%;" />

不会。

思路：DFS先序遍历。把所有叶子节点加入到list中，再比较两个list。

```java
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        dfs(root1, list1);
        dfs(root2, list2);

        if (list1.size() != list2.size()) {
            return false;
        }
        for (int i = 0; i < list1.size(); i++) {
            if (!list1.get(i).equals(list2.get(i))) {
                return false;
            }
        }
        return true;
    }

    private void dfs(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        
        if (root.left == null && root.right == null) {
            list.add(root.val);
        }
        dfs(root.left, list);
        dfs(root.right, list);
    }
}
```

### [951. 翻转等价二叉树](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824160436.png" alt="image-20210824160436393" style="zoom:80%;" />

思路：

两个节点都是空，说明越界了。两个节点其中一个为空，就不是翻转等价二叉树。两个节点要相同，不相同就不是翻转等价二叉树。

递归：

AB的左儿子，AB的右儿子；A左B右，A右B左。

```java
public boolean flipEquiv(TreeNode A, TreeNode B) {
    if (A == null && B == null) {
        return true;
    }
    if (A == null || B == null) {
        return false;
    }
    if (A.val != B.val) {
        return false;
    }

    return flipEquiv(A.left, B.left) && flipEquiv(A.right, B.right) ||
        flipEquiv(A.left, B.right) && flipEquiv(A.right, B.left);
}
```

## 二叉树的增删改

### [156. 右旋转二叉树](https://leetcode-cn.com/problems/binary-tree-upside-down/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824143134.png" alt="image-20210824143134214" style="zoom: 80%;" />

注意：所有的右节点要么有兄弟节点的叶子节点，要么为空。

思路：左子节点变父节点；父节点变右子节点；右子节点变左子节点。

具体做法：左子节点的左子节点是右子节点，左子节点的右节点是当前节点，当前节点的左右子节点为空。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824153338.png" alt="image-20210824153338828" style="zoom:50%;" />

```java
public TreeNode upsideDownBinaryTree(TreeNode root) {
    if (root == null) {                                 // 空，返回
        return null;
    }
    if (root.left == null && root.right == null) {      // 叶子节点，返回
        return root;
    }

    TreeNode newRoot = upsideDownBinaryTree(root.left); // 左儿子是新的节点

    root.left.left = root.right;
    root.left.right = root;
    root.left = null;
    root.right = null;

    return newRoot;
}
```

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821131303.png" alt="image-20210821131303378" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821131414.png" alt="image-20210821131414633" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821131354.png" alt="image-20210821131354416" style="zoom:80%;" />

**1. 确定递归函数的参数和返回值**：输入数组、左边界、右边界，返回最大二叉树的根节点

**2. 确定终止条件**：左边界 > 右边界

**3. 确定单层递归的逻辑**：根据数组最大值新建节点。

思路：DFS**前序遍历**，获得最大值的下标 `maxIndex`，根据 `nums[maxIndex]` 新建根节点。

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return construct(nums, 0, nums.length - 1);
    }
    
    public TreeNode construct(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        int maxIndex = left;
        for (int i = left; i <= right; i++) {
            if (nums[maxIndex] < nums[i]) {
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(nums[maxIndex]);

        root.left = construct(nums, left, maxIndex - 1);
        root.right = construct(nums, maxIndex + 1, right);

        return root;
    }
}
```

### [814. 二叉树剪枝](https://leetcode-cn.com/problems/binary-tree-pruning/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824151154.png" alt="image-20210824151154870" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824151222.png" alt="image-20210824151222000" style="zoom: 80%;" />

思路：后序遍历。如果当前节点的值是0，并且左右儿子都不包含1，则当前节点置为空。

```java
public TreeNode pruneTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    root.left = pruneTree(root.left);
    root.right= pruneTree(root.right);
    if (root.val == 0 && root.left == null && root.right == null) {
        root = null;
    }

    return root;
}
```

### [1028. 从先序遍历还原二叉树](https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824152628.png" alt="image-20210824152627911" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824152637.png" alt="image-20210824152637303" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824152648.png" alt="image-20210824152648885" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824203030.png" alt="image-20210824203030502" style="zoom:80%;" />

不会。

思路：迭代（用栈模拟）。求当前节点的层数和值。如果当前节点是根节点，就直接把根节点加入到栈中。如果不是根节点，那就先找到正确父节点（栈中元素个数等于当前节点层数），优先成为到父节点的左儿子，最后在把当前节点加入到栈中。迭代完成，栈底元素就是根节点。

```java
public TreeNode recoverFromPreorder(String s) {
    Deque<TreeNode> stack = new ArrayDeque<>();         // 左边是栈顶

    int i = 0;
    while (i < s.length()) {
        int level = 0;      // 当前节点在第几层
        while (s.charAt(i) == '-') {
            level++;
            i++;
        }

        int val = 0;        // 当前节点的值
        while (i < s.length() && s.charAt(i) != '-') {
            val = val * 10 + (s.charAt(i) - '0');
            i++;
        }

        while (stack.size() > level) {
            stack.removeLast();
        }
        TreeNode node = new TreeNode(val);
        if (!stack.isEmpty()) {
            if (stack.getLast().left == null) {
                stack.getLast().left = node;
            } else {
                stack.getLast().right = node;
            }
        }
        stack.addLast(node);
    }

    while (stack.size() > 1) {
        stack.removeLast();
    }
    return stack.removeLast();
}
```

## 子树

### [1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824133911.png" alt="image-20210824133911351" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824133922.png" alt="image-20210824133922521" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824133935.png" alt="image-20210824133935782" style="zoom:80%;" />

思路：DFS先序遍历。先当前节点存在要找路径，再判断左右是否有要找的路径。特例：链表是空，就是找到了。当前节点是空，那是没有找到。

```java
class Solution {
    public boolean isSubPath(ListNode head, TreeNode root) {
        if (head == null) {
            return true;
        }
        if (root == null) {
            return false;
        }

        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);
    }

    private boolean dfs(ListNode head, TreeNode root) {
        if (head == null) {
            return true;
        }
        if (root == null) {
            return false;
        }

        if (head.val != root.val) {
            return false;
        }
        return dfs(head.next, root.left) || dfs(head.next, root.right);
    }
}
```

## 路径

### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824020400.png" alt="image-20210824020400291" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824020411.png" alt="image-20210824020410986" style="zoom:80%;" />

不会。时间：$O(N)$  ，空间：$O(H)$，H是树的高度

思路：DFS后序遍历。求当前节点左右两边同值的个数，返回左右两边同值最多的个数。

```java
class Solution {
    int res = 0;

    public int longestUnivaluePath(TreeNode root) {
        dfs(root);
        return res;
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int left = dfs(root.left);
        int right = dfs(root.right);

        int arrowLeft = 0;
        int arrowRight = 0;
        if (root.left != null && root.left.val == root.val) {
            arrowLeft = left + 1;
        }
        if (root.right != null && root.right.val == root.val) {
            arrowRight = right + 1;
        }
        res = Math.max(res, arrowLeft + arrowRight);

        return Math.max(arrowLeft, arrowRight);
    }
}
```

## 序列化

### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824033003.png" alt="image-20210824033003192" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824033011.png" alt="image-20210824033011513" style="zoom:80%;" />

思路：序列化二叉树。DFS**后序遍历**。

```java
class Solution {
    
    Map<String, Integer> freq = new HashMap<>();
    List<TreeNode> res = new ArrayList<>();

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        dfs(root);
        return res;
    }

    private String dfs(TreeNode root) {
        if (root == null) {
            return "#";
        }
        String serial = root.val + "," + dfs(root.left) + "," + dfs(root.right);

        freq.put(serial, freq.getOrDefault(serial, 0) + 1);
        if (freq.get(serial) == 2) {
            res.add(root);
        }
        return serial;
    }
}
```

### [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824112332.png" alt="image-20210824112325511" style="zoom:80%;" />

时间：$O(N)$  ，空间：$O(1)$

思路：**出度入度**。在一个二叉树中，**所有节点的入度之和等于出度之和**。我们只要把字符串遍历一次，每个节点都累加 `diff = 出度 - 入度` 。在遍历到任何一个节点的时候，要求 `diff >= 0`，原因是还没遍历到该节点的子节点，所以此时的出度应该大于等于入度。当所有节点遍历完成之后，整棵树的 `diff == 0` 。

- 每个空节点（ `"#"` ）会提供 0 个出度和 1 个入度。
- 每个非空节点会提供 2 个出度和 1 个入度（根节点的入度是 0）。

这里解释一下为什么下面的代码中 **diff 的初始化为 1**。因为，我们加入一个非空节点时，都会对 diff 先减去 1（入度），再加上 2（出度）。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2。

![image-20210824115147241](https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824115147.png)

```java
public boolean isValidSerialization(String preorder) {
    String[] nodes = preorder.split(",");
    int diff = 1;
    for (String node : nodes) {
        diff--;
        if (diff < 0) {
            return false;
        }
        if (!node.equals("#")) {
            diff += 2;
        }
    }
    return diff == 0;
}
```

## 完全二叉树

### [1104. 完全二叉树寻路](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821184802.png" alt="image-20210821184801987" style="zoom:80%;" />

思路：模拟。首先算出二叉树的深度。在最后一层向上迭代。除了最后一层和第一层不反转以外，每上一层，反转一次。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210729013100.png" alt="image-20210729013100322" style="zoom:50%;" />

```java
public List<Integer> pathInZigZagTree(int target) {
    List<Integer> res = new ArrayList<>();
    int depth = (int) (Math.log(target) / Math.log(2)) + 1;     // ln(target) / ln(2)

    // 每上一层，反转一次
    while (target > 1) {
        res.add(0, target);
        target = target / 2;
        depth--;
        // 上一层最右边和最左边的值
        int right = (int) (Math.pow(2, depth) - 1);
        int left = (int) (Math.pow(2, depth - 1));
        // 反转
        target = right - (target - left);
    }
    res.add(0, 1);      // 加入根节点

    return res;
}
```

## 序列化

### [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823194441.png" alt="image-20210823194441608" style="zoom:80%;" />

思路：和 [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) 一样。

* BFS + 由BFS数组构造二叉树

## 其他

### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821133323.png" alt="image-20210821133322941" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821133340.png" alt="image-20210821133340196" style="zoom:80%;" />

时间：$O(N)$，空间：$O(N)$

思路：DFS**前序遍历**。HashSet 存放 `target - root.val`。

```java
class Solution {
    Set<Integer> set = new HashSet<>();
    
    public boolean findTarget(TreeNode root, int target) {
        if (root == null) {
            return false;
        }

        if (set.contains(root.val)) {
            return true;
        } else {
            set.add(target - root.val);
        }

        boolean left = findTarget(root.left, target);
        boolean right = findTarget(root.right, target);

        return left || right;
    }
}
```

### [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823161710.png" alt="image-20210823161710472" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823161719.png" alt="image-20210823161719322" style="zoom:80%;" />

`NestedInteger` 接口：

```java
public interface NestedInteger {
    public boolean isInteger();					// true是整数，false是nestedList
    
    public Integer getInteger();				// 获得整数，如果是nestedList，返回null
    
    public List<NestedInteger> getList();		// 获得nestedList，如果是整数，返回空的List
}
```

时间：$O(N)$ ，空间：$O(N)$

思路：深搜 + 队列。把 `nestedList` 中的所有元素都加入到队列中，遇到数字就加入队列，遇到 `list` 就进入 `list`

```java
public class NestedIterator implements Iterator<Integer> {

    Deque<Integer> deque = new ArrayDeque<>();

    public NestedIterator(List<NestedInteger> nestedList) {
        dfs(nestedList);
    }

    private void dfs(List<NestedInteger> nestedList) {
        for (NestedInteger item : nestedList) {
            if (item.isInteger()) {
                deque.push(item.getInteger());
            } else {
                dfs(item.getList());
            }
        }
    }

    @Override
    public Integer next() {
        return deque.poll();
    }

    @Override
    public boolean hasNext() {
        return !deque.isEmpty();
    }
}
```

### [314. 二叉树的垂直遍历](https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824210056.png" alt="image-20210824210056037" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824210104.png" alt="image-20210824210104602" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824210121.png" alt="image-20210824210121870" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824210132.png" alt="image-20210824210132480" style="zoom:80%;" />

不会。

思路：BFS。TreeMap 存放 <层级，在当前层级上的节点> ， HashMap 存放 <节点，节点的层级>。BFS每次向左，层级-1；向右，层级+1.

```java
public List<List<Integer>> verticalOrder(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    Map<Integer, List<Integer>> res = new TreeMap<>();      // <层级，在当前层级上的节点>
    Map<TreeNode, Integer> map = new HashMap<>();           // <节点，节点的层级>
    map.put(root, 0);

    Deque<TreeNode> deque = new LinkedList<>();
    deque.addLast(root);
    while (!deque.isEmpty()) {
        TreeNode node = deque.removeFirst();
        int level = map.get(node);
        res.computeIfAbsent(level, k -> new ArrayList<>()).add(node.val);

        if (node.left != null) {
            deque.addLast(node.left);
            map.put(node.left, level - 1);
        }
        if (node.right != null) {
            deque.addLast(node.right);
            map.put(node.right, level + 1);
        }
    }
    return new ArrayList<>(res.values());
}
```

### [987. 二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824023007.png" alt="image-20210824023007230" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824023027.png" alt="image-20210824023027659" style="zoom:80%;" />

放弃。

### [1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824040338.png" alt="image-20210824040337939" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824040346.png" alt="image-20210824040346553" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824040400.png" alt="image-20210824040400391" style="zoom: 80%;" />

不会。

思路：DFS**后序遍历**，求以各个节点为根的子树总和，把和加入list。遍历list，去掉一条边的乘积 = 子树总和 * （总和 - 子树总和），取最大值。

```java
class Solution {
    List<Long> sums = new ArrayList<>();
    int MOD = (int) (1e9 + 7);

    public int maxProduct(TreeNode root) {
        dfs(root);

        long res = 0;
        long allSum = sums.get(sums.size() - 1);
        for (long sum : sums) {
            res = Math.max(res, sum * (allSum - sum));
        }
        return (int) (res % MOD);
    }

    private long dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }
        long sum = root.val + dfs(root.left) + dfs(root.right);
        sums.add(sum);
        return sum;
    }
}
```

### [655. 输出二叉树](https://leetcode-cn.com/problems/print-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824221606.png" alt="image-20210824221606034" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824221616.png" alt="image-20210824221616602" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824221629.png" alt="image-20210824221629667" style="zoom:80%;" />

思路：DFS先序遍历。先获得二叉树的深度，再用String二维数组提前构造好结果。DFS先序遍历，每次在数组的中间位置加入当前节点的值。最后再把String二维数组转为list。

```java
class Solution {
    public List<List<String>> printTree(TreeNode root) {
        int depth = getDepth(root);
        String[][] res = new String[depth][(1 << depth) - 1];
        for (String[] arr : res) {
            Arrays.fill(arr, "");
        }

        dfs(res, root, 0, 0, res[0].length - 1);

        List<List<String>> list = new ArrayList<>();
        for (String[] arr : res) {
            list.add(Arrays.asList(arr));
        }
        return list;
    }

    private void dfs(String[][] res, TreeNode root, int depth, int left, int right) {
        if (root == null) {
            return;
        }

        int mid = (left + right) / 2;
        res[depth][mid] = String.valueOf(root.val);

        dfs(res, root.left, depth + 1, left, mid - 1);
        dfs(res, root.right, depth + 1, mid + 1, right);
    }

    private int getDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMaxDepth = getDepth(root.left);
        int rightMaxDepth = getDepth(root.right);
        return 1 + Math.max(leftMaxDepth, rightMaxDepth);
    }
}
```





# 递归

### [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210924171934.png" alt="image-20210924171934020" style="zoom:80%;" />

思路：从 1 开始递归往后推。记录有相同字母的字符串长度。如果当前字符与下一个字符相同，那就count++。否则，向结果中添加count和当前字符。

```java
public String countAndSay(int n) {
    if (n == 1) return "1";
    String pre = countAndSay(n - 1);
    StringBuilder res = new StringBuilder();
    int count = 1;                      // 有相同字母的字符串长度
    for (int i = 0; i < pre.length(); i++) {
        if (i + 1 < pre.length() && pre.charAt(i) == pre.charAt(i + 1)) {
            count++;
        } else {
            res.append(count).append(pre.charAt(i));
            count = 1;
        }
    }
    return res.toString();
}
```





# 链表

## 删除

### [237. 浅删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804103958.png" alt="image-20210804103958258" style="zoom:80%;" />

```java
public void deleteNode(ListNode node) {
    node.val = node.next.val;
    node.next = node.next.next;
}
```

### [1171. 从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804111712.png" alt="image-20210804111712716" style="zoom:80%;" />

思路：前缀和，第一次遍历，哈希集合保存 <前缀和，最后一次出现的节点>。第二次遍历，如果当前节点的前缀和在哈希表中，则直接跳到最后一次这个之出现的位置。为了也能删除第一个节点，节点应该从 newHead 开始遍历。

```java
public ListNode removeZeroSumSublists1(ListNode head) {
    ListNode newHead = new ListNode(0, head);
    Map<Integer, ListNode> map = new HashMap<>();

    int sum = 0;
    for (ListNode cur = newHead; cur != null; cur = cur.next) {
        sum += cur.val;
        map.put(sum, cur);
    }

    sum = 0;
    for (ListNode cur = newHead; cur != null; cur = cur.next) {
        sum += cur.val;
        if (map.containsKey(sum)) {
            cur.next = map.get(sum).next;
        }
    }
    return newHead.next;
}
```

## 修改

### [1669. 合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804115559.png" alt="image-20210804115559619" style="zoom:80%;" />

```java
public ListNode mergeInBetween(ListNode node1, int a, int b, ListNode node2) {
    ListNode newHead = new ListNode(0, node1);
    ListNode leftNodePre = newHead;
    for (int i = 0; i < a; i++) {
        leftNodePre = leftNodePre.next;
    }

    ListNode rightNode = newHead;
    for (int i = 0; i <= b; i++) {
        rightNode = rightNode.next;
    }
    ListNode rightNodeNext = rightNode.next;

    leftNodePre.next = node2;
    ListNode cur = node2;
    while (cur.next != null) {
        cur = cur.next;
    }
    cur.next = rightNodeNext;

    return newHead.next;
}
```

### [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804235312.png" alt="image-20210804235312825" style="zoom:80%;" />

对于示例2：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804235514.png" alt="image-20210804235514360" style="zoom: 67%;" />

思路：每个部分的节点个数为 N / k，前 N % k 个部分有一个额外的结点。

```java
public ListNode[] splitListToParts(ListNode head, int k) {
    // 计算链表长度N
    int N = 0;
    ListNode cur = head;
    while (cur != null) {
        N++;
        cur = cur.next;
    }

    // 计算每个部分的节点个数N/k，前N%k部分有一个额外的结点
    int width = N / k;
    int remainder = N % k;      // remainder: 余数

    ListNode[] res = new ListNode[k];
    cur = head;
    for (int i = 0; i < k; i++) {
        res[i] = cur;
        for (int j = 1; j < width + (i < remainder ? 1 : 0); j++) {
            if (cur != null) {
                cur = cur.next;
            } else {
                break;
            }
        }
        if (cur != null) {
            ListNode pre = cur;
            cur = cur.next;
            pre.next = null;
        }
    }
    return res;
}
```

### [1721. 交换链表中的节点的值](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210805123048.png" alt="image-20210805123048382" style="zoom:80%;" />

思路：快慢指针。

```java
public ListNode swapNodes(ListNode head, int k) {
    if (head.next == null) {
        return head;
    }

    ListNode newHead = new ListNode(0, head);
    ListNode leftNode = newHead;
    for (int i = 0; i < k; i++) {
        leftNode = leftNode.next;
    }

    ListNode fast = leftNode;
    ListNode slow = newHead;
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }

    int temp = slow.val;
    slow.val = leftNode.val;
    leftNode.val = temp;

    return newHead.next;
}
```

## 设计

### [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210805065810.png" alt="image-20210805065810627" style="zoom:80%;" />

只会用单链表，双链表速度更快。

```java
class ListNode {
    int val;
    ListNode next;

    ListNode() { }
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class MyLinkedList {

    int size;
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode();      // 虚假头节点
    }

    // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。下标从0开始计算。
    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode cur = head;
        for (int i = 0; i <= index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }

    // 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    // 将值为 val 的节点追加到链表的最后一个元素。
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    // 在链表中的第 index 个节点之前添加值为 val 的节点。
    // 如果 index 等于链表的长度，则该节点将附加到链表的末尾。
    // 如果 index 大于链表长度，则不会插入节点。
    // 如果 index 小于0，则在头部插入节点。
    public void addAtIndex(int index, int val) {
        if (index == size) {
            ListNode cur = head;
            while (cur.next != null) {
                cur = cur.next;
            }
            cur.next = new ListNode(val);
            size++;
        } else if (index > size) {
            return;
        } else if (index <= 0) {
            ListNode next = head.next;
            head.next = new ListNode(val, next);
            size++;
        } else {
            ListNode cur = head;
            for (int i = 0; i < index; i++) {
                cur = cur.next;
            }
            ListNode next = cur.next;
            cur.next = new ListNode(val, next);
            size++;
        }
    }

    // 如果索引 index 有效，则删除链表中的第 index 个节点。
    public void deleteAtIndex(int index) {
        if (index >= 0 && index < size) {
            ListNode cur = head;
            for (int i = 0; i < index; i++) {
                cur = cur.next;
            }
            cur.next = cur.next.next;
            size--;
        }
    }
}
```

### [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210805091323.png" alt="image-20210805091323403"  />

[题解](https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter.md)

放弃了，太难了。

2021.08.05 再次放弃

### [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

思路1：暴力。

```java
class Solution {

    ListNode head;
    Random random;

    public Solution(ListNode head) {
        this.head = head;
        this.random = new Random();
    }

    public int getRandom() {
        ListNode cur = head;

        int N = 0;
        while (cur != null) {
            cur = cur.next;
            N++;
        }

        int index = random.nextInt(N);
        cur = head;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }
}
```

思路2：蓄水池抽样。遇到再说吧。

```java
class Solution {
    
    ListNode head;
    Random random;
    
    public Solution(ListNode head) {
        this.head = head;
        this.random = new Random();
    }
    
    public int getRandom() {
        int reserve = 0;
        int N = 0;
        ListNode cur = head;
        while(cur != null){
            N++;
            int rand = random.nextInt(N) + 1;
            if(rand == N){
                reserve = cur.val;
            }
            cur = cur.next;
        }
        return reserve;
    }
}
```

## 非字节题库

### [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210805121705.png" alt="image-20210805121705628" style="zoom:80%;" />

输入的多级列表如下图所示：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png" alt="img" style="zoom: 80%;" />

扁平化后的链表如下图：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png)

不会，[B站题解视频](https://www.bilibili.com/video/BV1MZ4y1F7p6?p=2)

思路：写代码的时候，一开始不定义尾节点，后面再加。

```java
class Solution {
    Node tail = null;
    public Node flatten(Node head) {
        if (head == null) {
            return null;
        }

        Node cur = head;
        while (cur != null) {
            if (cur.next == null) {
                tail = cur;
            }

            if (cur.child != null) {
                Node temp = cur.next;
                Node child = flatten(cur.child);

                cur.next = child;
                child.prev = cur;
                cur.child = null;

                if (tail != null && temp != null) {
                    tail.next = temp;
                    temp.prev = tail;
                    tail = null;
                }
            } else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

### [708. 循环有序列表的插入](https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210805142650.png" alt="image-20210805142650229"  />

不会。

```java
public Node insert(Node head, int insertVal) {
    if (head == null) {
        head = new Node(insertVal);
        head.next = head;
        return head;
    }

    Node cur = head;
    while (cur.next != head) {
        if (cur.val <= insertVal && insertVal <= cur.next.val) {
            // insertVal不是最值
            break;
        } else if (cur.val < insertVal && cur.next.val < insertVal && cur.val > cur.next.val) {
            // insertVal是最大值
            break;
        } else if (cur.val > insertVal && cur.next.val > insertVal && cur.val > cur.next.val) {
            // insertVal是最小值
            break;
        } else {
            cur = cur.next;
        }
    }
    Node temp = cur.next;
    cur.next = new Node(insertVal, temp);

    return head;
}
```

## 哈希表

### [817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210918170602.png" alt="image-20210918170602262" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210918170653.png" alt="image-20210918170653794" style="zoom:80%;" />

思路：哈希表保存 `num` 中的所有元素。如果当前节点在哈希表中，而下个节点不在哈希表中或者是空，那组件个数+1

```java
public int numComponents(ListNode head, int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) {
        set.add(num);
    }

    int res = 0;
    for (ListNode cur = head; cur != null; cur = cur.next) {
        if (set.contains(cur.val) &&
            (cur.next == null || !set.contains(cur.next.val))) {
            res++;
        }
    }
    return res;
}
```











# 图

## Bellman-Ford 算法（放弃）

### [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

放弃。

最短路径问题

思路：Bellman Ford算法。

# 最小生成树（放弃）

## K算法、P算法

### [1489. 找到最小生成树里的关键边和伪关键边](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)



### [1135. 最低成本联通所有城市](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/)

[题解](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/solution/java-kruskal-suan-fa-27ms-by-jzj1993/)



# 多源最短路径算法（放弃）

## Floyd 算法





# 笔记

## 关键路径算法

**AOE网**：在带权有向图中，用顶点表示事件，**有向边表示活动**。AOE网 只有一个入度为0的顶点，称为**源点**；只有一个出度为0的顶点，称为**汇点**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210706030121531.png" alt="image-20210706030121531" style="zoom: 67%;" />

**关键路径**：从源点到汇点的所有路径中，具有**最大路径长度的路径**。

关键活动：关键路径上的活动。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210706030628522.png" alt="image-20210706030628522" style="zoom: 67%;" />

**算法思想**：

1. 对AOE网进行**拓扑排序**，求得每个**顶点的最早开始时间**；
2. 然后，对AOE网进行**逆拓扑排序**，求得每个**顶点的最晚开始时间**；
3. 最后，求每条**边**的**最早开始时间**和**最晚开始时间**，**如果二者相等，则这是个关键活动，将其加入关键路径中**。

## 最小生成树

### 生成树

#### 深度优先生成树

**对图进行DFS生成的树**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210705174248521.png" alt="image-20210705174248521" style="zoom: 50%;" />

#### 广度优先生成树

**对图进行BFS生成的树**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210705174326631.png" alt="image-20210705174326631" style="zoom:50%;" />

### 最小生成树

生成树：包含图中全部顶点的一个极小连通子图。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210704172927564.png" alt="image-20210704172927564" style="zoom: 50%;" />

**最小生成树**，Minimum Spanning Tree，简称 **MST**。

定义：**路径上的权重和最小**。（可能有多个）

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210705191302775.png" alt="image-20210705191302775" style="zoom: 50%;" />

求最小生成树有两种算法：**P算法**，**K算法**。

#### K算法

<font color='cornflowerblue'>每次选择权值最小的一条边，如果加上这条边，图不会形成环，就加上，反之不加上。</font>

靠**并查集**实现。

```java
public static Set<Edge> kruskalMST(Graph graph) {
    UnionFind unionFind = new UnionFind();			// 并查集
    unionFind.makeSets(graph.nodes.values());		// 把点集的值都加入并查集

    // 从小的边到大的边，依次弹出，小根堆！
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new Comparator<Edge>() {
        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.weight - o2.weight;
        }
    });

    // 把所有的边都加入优先队列
    for (Edge edge : graph.edges) {
        priorityQueue.add(edge);
    }
    Set<Edge> result = new HashSet<>();
    
    while (!priorityQueue.isEmpty()) {
        Edge edge = priorityQueue.remove();
        // 每次弹出，如果源点和汇点不属于同一个集合
        if (!unionFind.isSameSet(edge.from, edge.to)) {
            result.add(edge);		// 更新结果
            unionFind.union(edge.from, edge.to);	// 把源点和汇点添加到一个集合中
        }
    }
    return result;
}
```

#### P算法

<font color='cornflowerblue'>从某一个顶点开始构建生成树，每次将权重最小的新顶点加入到生成树，直到所有节点都加入为止。</font>

靠**优先队列**实现 

## 最短路径

### 单源最短路径

##### Dijkstra 算法 

##### Bellman-Ford 算法

Bellman-Ford 算法的例子：套汇

如果我们说货币 A 到货币 B 的汇率是 10，意思就是 1 单位的货币 A 可以换 10 单位货币 B。如果我们把每种货币视为一幅图的顶点，货币之间的汇率视为加权有向边，那么整个汇率市场就是一幅「完全加权有向图」。比如：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210803084220.png" alt="image-20210803084220638" style="zoom: 50%;" />

图中的加权有向边代表汇率，我们可以发现如果把 100 单位的货币 A 换成 B，再换成 C，最后换回 A，就可以得到 100×0.9×0.8×1.4 = 100.8 单位的 A！如果交易的金额大一些的话，赚的钱是很可观的，这种空手套白狼的操作就是套汇。

现实中交易会有种种限制，而且市场瞬息万变，但是套汇的利润还是很高的，关键就在于如何**快速**找到这种套汇机会呢？

借助图的抽象，我们发现套汇机会其实就是一个环，且这个环上的权重之积大于 1，只要在顺着这个环交易一圈就能空手套白狼。

**Bellman-Ford 算法，可以用于寻找负权重环**。对于我们说的套汇问题，可以先把所有边的权重 w 替换成 -ln(w)，这样「寻找权重乘积大于 1 的环」就转化成了「寻找权重和小于 0 的环」，就可以使用 Bellman-Ford 算法在 O(EV) 的时间内寻找负权重环，也就是寻找套汇机会。

#### 多源最短路径

##### Floyd算法

用于无权图和有权图，不适用于带有“负权环”的图。 

思想：**动态规划**。<font color='cornflowerblue'>对于每一对顶点 u 和 v，查看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是就更新它。</font>

```java
# 初始: 不允许在其他顶点中转，最短路径是？
# 0:   若允许在V0中转，最短路径是？
# 1:   若允许在V0、V1中转，最短路径是？  
......
# n-1: 若允许在V0、V1...Vn-2中转，最短路径是？  
```





















