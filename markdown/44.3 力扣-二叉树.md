[toc]

# 二叉树

* 前序遍历：根左右
* 中序遍历：左根右
* 后序遍历：左右根

```java
//  树节点的定义
public class TreeNode {

    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() { }

    TreeNode(int val) { this.val = val; }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 深度优先遍历(DFS)

面试也会手撕前序、中序、后序遍历。只用掌握递归和迭代即可。

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom: 50%;" />

```java
输入：root = [1,null,2,3]		// 层序遍历
输出：[1,2,3]					// 前序遍历
```

思路1：递归

```java
List<Integer> res = new ArrayList<>();

public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) return res;
    res.add(root.val);
    preorderTraversal(root.left);
    preorderTraversal(root.right);
    return res;
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入左节点，如果左节点非空的话
    * 加入中节点，加入 null
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```
// 栈非空，就取出栈顶节点
// 如果栈顶节点非空，则加入右左 根(当前节点)，根后面加null；
// 如果栈顶节点为空，则弹出现在的栈顶节点，把它加入到结果中
```

```java
public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
            stack.push(node);
            stack.push(null);
        } else {
            res.add(stack.pop().val);
        }
    }
    return res;
}
```

思路3：莫里斯（Morris）算法。

不做了解。

* 时间：O(N)

* 空间：O(1)

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

思路1：递归。

```java
List<Integer> res = new ArrayList<>();

public List<Integer> inorderTraversal(TreeNode root) {
    if (root == null) return res;
    inorderTraversal(root.left);
    res.add(root.val);
    inorderTraversal(root.right);
    return res;
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入中节点，加入 null
    * 加入左节点，如果左节点非空的话
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```java
public List<Integer> inorderTraversal(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            if (node.right != null) stack.push(node.right);
            stack.push(node);
            stack.push(null);
            if (node.left != null) stack.push(node.left);
        } else {
            res.add(stack.pop().val);
        }
    }
    return res;
}
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

思路1：递归。

```java
List<Integer> res = new ArrayList<>();

public List<Integer> postorderTraversal(TreeNode root) {
    if (root == null) return res;
    postorderTraversal(root.left);
    postorderTraversal(root.right);
    res.add(root.val);
    return res;
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入左节点，如果左节点非空的话
    * 加入中节点，加入 null
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```java
public List<Integer> postorderTraversal(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            stack.push(node);
            stack.push(null);
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        } else {
            res.add(stack.pop().val);
        }
    }
    return res;
}
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822140247.png" alt="image-20210822140247300" style="zoom:80%;" />

不会 * 2

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210629235724713.png" alt="image-20210629235724713" style="zoom: 67%;" />

`pIndex` 是中序遍历根节点的下标，全称是 `pivotIndex`

* HashMap 记录 **<中序遍历的值，中序遍历的下标>**

1. 终止条件：越界，前序遍历左边界 > 前序遍历右边界 或者 中序遍历左边界 > 中序遍历右边界
2. 前序遍历：获得根节点的值，新建根节点，从 map 中取出中序遍历中根节点的下标
3. 返回：root

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210629235750307.png" alt="image-20210629235750307" style="zoom:67%;" />


```java
class Solution {
    int[] preorder;
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(0, preorder.length - 1,
                         0, inorder.length - 1);
    }

    // 前序遍历数组的左/右边界，中序遍历数组的左/右边界
    public TreeNode buildTree(int preLeft, int preRight,
                              int inLeft, int inRight) {
        if (preLeft > preRight || inLeft > inRight) {
            return null;
        }

        int rootValue = preorder[preLeft];
        int pIndex = map.get(rootValue);
        TreeNode root = new TreeNode(rootValue);

        root.left = buildTree(preLeft + 1, preLeft + pIndex - inLeft,
                              inLeft, pIndex - 1);
        root.right = buildTree(preLeft + pIndex - inLeft + 1, preRight,
                               pIndex + 1, inRight);

        return root;
    }
}
```

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822144254.png" alt="image-20210822144254265" style="zoom:80%;" />

* HashMap 记录 **<中序遍历的值，中序遍历的下标>**

1. 终止条件：越界，前序遍历左边界 > 前序遍历右边界 或者 中序遍历左边界 > 中序遍历右边界
2. 前序遍历：获得根节点的值，从 map 中取出中序遍历中根节点的下标，新建根节点
3. 返回：root

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210630005310209.png" alt="image-20210630005310209" style="zoom:80%;" />

```java
class Solution {
    int[] postorder;
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(0, inorder.length - 1,
                         0, postorder.length - 1);
    }

    private TreeNode buildTree(int inLeft, int inRight, int postLeft, int postRight) {
        if (inLeft > inRight || postLeft > postRight) {
            return null;
        }

        int rootValue = postorder[postRight];
        int pIndex = map.get(rootValue);
        TreeNode root = new TreeNode(rootValue);

        root.left = buildTree(inLeft, pIndex - 1,
                              postLeft,  postRight - (inRight - pIndex + 1));
        root.right = buildTree(pIndex + 1, inRight,
                               postRight - (inRight - pIndex), postRight - 1);

        return root;
    }
}
```

### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822152609.png" alt="image-20210822152609037" style="zoom: 80%;" />

不会 * 3

思路：**使用前序遍历来构建Tree**，然后通过**后续遍历来检验当前树是否构建完毕**。

首先我们创建一个节点作为 `root`，`root = TreeNode(pre[preIndex])`。

如果 `root.val == post[posIndex] `, 意味着我们已经构建完毕了当前子树，返回 root。

如果当前子树没有构建完毕，那么我们就递归的构建左右子树。

```java
class Solution {
    int preIndex = 0;
    int postIndex = 0;

    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        TreeNode root = new TreeNode(pre[preIndex]);
        preIndex++;

        if (root.val != post[postIndex]) {
            root.left = constructFromPrePost(pre, post);
        }
        if (root.val != post[postIndex]) {
            root.right = constructFromPrePost(pre, post);
        }
        postIndex++;

        return root;
    }
}
```

## 广度优先遍历(BFS)

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822112950.png" alt="image-20210822112949959" style="zoom: 80%;" />

思路：BFS。

<img src="https://pic.leetcode-cn.com/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img" style="zoom: 33%;" />

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<List<Integer>> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);

    while (!deque.isEmpty()) {
        int size = deque.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            level.add(node.val);
            if (node.left != null) deque.addLast(node.left);
            if (node.right != null) deque.addLast(node.right);
        }
        res.add(level);
    }
    return res;
}
```

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822113735.png" alt="image-20210822113735004" style="zoom:80%;" />

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<List<Integer>> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);

    while (!deque.isEmpty()) {
        int size = deque.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            level.add(node.val);
            if (node.left != null) deque.addLast(node.left);
            if (node.right != null) deque.addLast(node.right);
        }
        res.add(0, level);
    }
    return res;
}
```

### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822115033.png" alt="image-20210822115033169" style="zoom:80%;" />

思路：在 [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) 的基础上，加入flag，flag为true从左向右，flag为false从右向左，每层结束之后要反转 flag。

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    if (root == null) return new ArrayList<>();

    List<List<Integer>> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);
    boolean flag = true;        // flag为true从左向右，flag为false从右向左

    while (!deque.isEmpty()) {
        int size = deque.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            if (flag) level.add(node.val);
            else level.add(0, node.val);
            if (node.left != null) deque.addLast(node.left);
            if (node.right != null) deque.addLast(node.right);
        }
        res.add(level);
        flag = !flag;
    }
    return res;
}
```

## BFS的应用

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822124351.png" alt="image-20210822124351831" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822124401.png" alt="image-20210822124401411" style="zoom:80%;" />

时间：$O(N)$ ，空间：$O(1)$

思路：BFS 的思想，但是不使用队列，使用指针遍历。

用一个指针 father 遍历父节点，下一层新建一个虚拟头节点，如果父节点的子节点不为空，则添加到下一层的最后面。重复上述操作。

```java
public Node connect(Node root) {
    if (root == null) {
        return null;
    }

    Node father = root;
    while (father != null) {
        Node newHead = new Node(0);
        Node cur = newHead;

        while (father != null) {
            if (father.left != null) {
                cur.next = father.left;
                cur = cur.next;
            }
            if (father.right != null) {
                cur.next = father.right;
                cur = cur.next;
            }
            father = father.next;
        }
        father = newHead.next;
    }
    return root;
}
```

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822124826.png" alt="image-20210822124826650" style="zoom:80%;" />

时间：$O(N)$ ，空间：$O(N)$

思路：BFS，每次遍历把队列中的最后一个元素 加入到结果集中。

```java
public List<Integer> rightSideView(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);
    List<Integer> res = new ArrayList<>();

    while (!deque.isEmpty()) {
        int size = deque.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            if (node.left != null) deque.addLast(node.left);
            if (node.right != null) deque.addLast(node.right);
            if (i == size - 1) res.add(node.val);
        }
    }
    return res;
}
```

### [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823160644.png" alt="image-20210823160627598" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823160648.png" alt="image-20210823160637139" style="zoom:80%;" />

思路：BFS。使用双端队列保存二叉树的下标，与节点一一对应，从 1 开始保存。

```java
public int widthOfBinaryTree(TreeNode root) {
    if (root == null) {
        return 0;
    }

    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);
    Deque<Integer> index = new ArrayDeque<>();
    index.addLast(1);

    int res = 1;
    while (!deque.isEmpty()) {
        int size = deque.size();

        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            int nowIndex = index.removeFirst();
            if (node.left != null) {
                deque.addLast(node.left);
                index.addLast(nowIndex * 2);
            }
            if (node.right != null) {
                deque.addLast(node.right);
                index.addLast(nowIndex * 2 + 1);
            }
        }
        if (!index.isEmpty()) {
            res = Math.max(res, index.getLast() - index.getFirst() + 1);
        }
    }
    return res;
}
```

## 属性

### [100. 相同二叉树](https://leetcode-cn.com/problems/same-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823152932.png" alt="image-20210823152932380" style="zoom:80%;" />

思路：DFS先序遍历。两个节点都空，则返回。两个节点有一个空，则不同。两个节点的值要相等。

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }

    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821135247.png" alt="image-20210821135247428" style="zoom:80%;" />

思路：**DFS先序遍历**。判断当前的两个节点是不是对称的。

**1. 确定递归函数的参数和返回值**：输入左子节点 和 右子节点，输出布尔值

**2. 确定终止条件**：如果左子节点为空 并且 右子节点为空，返回 true；如果其中一个为空，返回false。

```java
class Solution {

    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetric(root.left, root.right);
    }

    private boolean isSymmetric(TreeNode node1, TreeNode node2) {
        if (node1 == null && node2 == null) {
            return true;
        }
        if (node1 == null || node2 == null) {
            return false;
        }

        return node1.val == node2.val && 
            isSymmetric(node1.left, node2.right) && 
            isSymmetric(node1.right, node2.left);
    }
}
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821135439.png" alt="image-20210821135439091" style="zoom:80%;" />

思路：DFS**先序遍历**。1 + 左右子树的最大深度。

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821135621.png" alt="image-20210821135621610" style="zoom:80%;" />

思路：如果当前节点的左右子树深度差超过 1，那就不是平衡二叉树。

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }

        if (Math.abs(maxDepth(root.left) - maxDepth(root.right)) > 1) {
            return false;
        }

        return isBalanced(root.left) && isBalanced(root.right);
    }

    private int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821141338.png" alt="image-20210821141338629" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821141348.png" alt="image-20210821141348641" style="zoom:80%;" />

思路：返回当前节点的左右子树最小深度 + 1。如果根节点为空，深度就是 0。如果当前节点的左右节点都为空，那这个节点的射弩的就是 1；如果它的左节点为空，则当前节点的最小深度是子树的最小深度 + 1；右节点为空，也是相同的道理。

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }
    if (root.left == null) {
        return minDepth(root.right) + 1;
    }
    if (root.right == null) {
        return minDepth(root.left) + 1;
    }

    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821180813.png" alt="image-20210821180813065" style="zoom:80%;" />

直径：左子树高度 + 右子树的高度

思路：在求每个节点的最大深度的过程中，计算节点的直径。

```java
class Solution {
    
    int max = -1;

    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        maxDepth(root);
        return max;
    }

    private int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        max = Math.max(max, leftDepth + rightDepth);

        return 1 + Math.max(leftDepth, rightDepth);
    }
}
```

### [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821210513.png" alt="image-20210821210513727" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821210522.png" alt="image-20210821210522573" style="zoom:80%;" />

思路：要找的节点分两种情况，一种情况是该节点是目标节点的子节点，另一种情况是该节点在目标节点的上面。第一种情况，很好找。第二种情况，就交换目标节点和它的父节点，同时距离 K - 1。

具体做法：找到目标节点。把目标节点做为单独的一棵树的根节点。把目标节点的父节点，做为一棵树的根节点。在目标节点的子树里找距离根节点为 K 的节点。在目标节点的父节点的子树里找距离根节点为 K - 1 的节点。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822105413.png" alt="image-20210822105412951" style="zoom: 67%;" />

```java
class Solution {

    List<Integer> res = new ArrayList<>();
    TreeNode father = null;         // 目标节点的父节点

    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        splitTree(root, target, null);
        search(target, 0, K);
        search(father, 0, K - 1);
        return res;
    }

    // 如果当前节点是目标节点说明找到了，那么父亲节点要更新。
    // 如果当前节点的左儿子是目标节点，则当前节点的左儿子变成它的父亲。
    // 如果当前节点的右儿子是目标节点，则当前节点的右儿子变成它的父亲。
    public boolean splitTree(TreeNode root, TreeNode target, TreeNode father) {
        if (root == null) {
            return false;
        }

        if (root == target) {
            this.father = father;
            return true;
        }

        if (splitTree(root.left, target, root)) {
            root.left = father;
            return true;
        }
        if (splitTree(root.right, target, root)) {
            root.right = father;
            return true;
        }
        return false;
    }

    // 向下找所有深度为K的节点
    public void search (TreeNode root, int depth, int K) {
        if (root == null) {
            return;
        }
        if (depth == K) {
            res.add(root.val);
        }
        search(root.left, depth + 1, K);
        search(root.right, depth + 1, K);
    }
}
```

## 修改

### [226. 左右翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210821104537724.png" alt="image-20210821104537724" style="zoom:80%;" />

时间：$O(N)$，空间：$O(N)$

思路：交换左右节点。

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```

### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821132851.png" alt="image-20210821132851206" style="zoom:80%;" />

思路：DFS**前序遍历**。如果根节点1为空，那根节点1的值为0；如果根节点2为空，那根节点2的值为0。最后加上这两个节点的值。

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) {
        return null;
    }

    if (root1 == null) root1 = new TreeNode(0);
    if (root2 == null) root2 = new TreeNode(0);
    TreeNode root = new TreeNode(root1.val + root2.val);

    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);

    return root;
}
```

## 子树

### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821182724.png" alt="image-20210821182724050" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821182734.png" alt="image-20210821182733884" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821182755.png" alt="image-20210821182755795" style="zoom:80%;" />

思路：判断当前节点的子树是否和 B 相同。如果不同就判断 A 的左右子树是否和 B 相同。

```java
class Solution {
    public boolean isSubtree(TreeNode A, TreeNode B) {
        if (A == null && B == null) {
            return true;
        }
        if (A == null || B == null) {
            return false;
        }

        return isSameTree(A, B) || isSubtree(A.left, B) || isSubtree(A.right, B);
    }

    private boolean isSameTree(TreeNode A, TreeNode B) {
        if (A == null && B == null) {
            return true;
        }
        if (A == null || B == null) {
            return false;
        }

        return A.val == B.val && isSameTree(A.left, B.left) && isSameTree(A.right, B.right);
    }
}
```

## 路径

### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821153641.png" alt="image-20210821153641293" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821153652.png" alt="image-20210821153652397" style="zoom:80%;" />

思路：当前节点是叶子节点，并且值等于 sum，就是我们要找的节点。

```java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) {
        return false;
    }

    if (root.left == null && root.right == null) {
        return root.val == sum;
    }

    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
```

### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821160454.png" alt="image-20210821160454602" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821160505.png" alt="image-20210821160505473" style="zoom:80%;" />

思路：回溯。如果叶子节点的值等于 target，就把这一段路径加入到结果集中。

1. 更新路径、目标值
2. 更新结果
3. 递归
4. 回溯

代码：正确做法：**`res.add(new ArrayList<>(path))`** ，相当于复制了一个 path 并加入到 res 。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> pathSum(TreeNode root, int target) {
        List<Integer> path = new ArrayList<>();
        dfs(root, target);
        return res;
    }

    public void dfs(TreeNode root, int target) {
        if (root == null) {
            return;
        }

        if (root.left == null && root.right == null && root.val == target) {
            path.add(root.val);
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
        }

        path.add(root.val);
        dfs(root.left, target - root.val);
        dfs(root.right, target - root.val);
        path.remove(path.size() - 1);
    } 
}
```

### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928000828.png" alt="image-20210928000828456" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928000843.png" alt="image-20210928000843071" style="zoom:80%;" />

不会 * 3

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821165244.png" alt="image-20210821165244265" style="zoom:80%;" />

思路：用哈希映射构建前缀和树，哈希映射保存 **<前缀和，前缀和出现的次数>**。更新路径上的和 `sum`，然后去哈希映射中找 `sum - target` ，更新哈希表。后序遍历。回溯。

```java
class Solution {

    int res = 0;
    Map<Integer, Integer> freq =  new HashMap<>();       // <前缀和，前缀和出现的次数>

    public int pathSum(TreeNode root, int target) {
        freq.put(0, 1);
        dfs(root, target, 0);
        return res;
    }
	
    // root，target，当前路径上的和sum
    private void dfs(TreeNode root, int target, int sum) {
        if (root == null) return;

        sum += root.val;
        res += freq.getOrDefault(sum - target, 0);
        
        freq.put(sum, freq.getOrDefault(sum, 0) + 1);
        dfs(root.left, target, sum);
        dfs(root.right, target, sum);
        freq.put(sum, freq.getOrDefault(sum, 0) - 1);
    }
}
```

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821170904.png" alt="image-20210821170904778" style="zoom:80%;" />

思路：DFS**前序遍历**。添加当前节点到当前路径中，如果当前节点是叶结点就就把路径添加到结果集中，如果不是叶结点要添加 `->` ，递归左/右节点。

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        createPath(root, res, "");
        return res;
    }

    private void createPath(TreeNode root, List<String> res, String path) {
        if (root == null) {
            return;
        }

        path += root.val;
        if (root.left == null && root.right == null) {
            res.add(path);
        } else {
            path += "->";
            createPath(root.left, res, path);
            createPath(root.right, res, path);
        }
    }
}
```

### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211104201110.png" alt="image-20211104201110424" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211104201027.png" alt="image-20211104201027643" style="zoom:80%;" />

思路：计算当前节点做为起始点的和最大的路径，在这个过程中计算左路径+当前节点+右路径的最大值。

```java
class Solution {

    int max = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        getMaxPath(root);
        return max;
    }

    public int getMaxPath(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftMaxSum = Math.max(0, getMaxPath(root.left));
        int rightMaxSum = Math.max(0, getMaxPath(root.right));

        max = Math.max(max, leftMaxSum + root.val + rightMaxSum);

        return root.val + Math.max(leftMaxSum, rightMaxSum);
    }
}
```

### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823152231.png" alt="image-20210823152231775" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823152242.png" alt="image-20210823152242416" style="zoom:80%;" />

思路：DFS前序遍历。

```java
class Solution {

    int res = 0;

    public int sumNumbers(TreeNode root) {
        dfs(root, 0);
        return res;
    }

    public void dfs(TreeNode root, int sum) {
        if (root == null) {
            return;
        }

        sum = sum * 10 + root.val;
        if (root.left == null && root.right == null) {
            res += sum;
        }
        dfs(root.left, sum);
        dfs(root.right, sum);
    }
}
```

## 公共祖先 

### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822110118.png" alt="image-20210822110118348" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822110241.png" alt="image-20210822110241886" style="zoom:80%;" />

思路：DFS**后序遍历**。**只要root的值在p和q的中间，就找到了**。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    return root;
}
```

### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822110721.png" alt="image-20210822110721492" style="zoom:80%;" />

思路：一共三种情况。

1. p 和 q 在 root 的两侧
2. q 在 p 的子树里
3. p 在 q 的子树里r

不会 * 5。

思路：

1. 如果当前节点越界，返回空
2. 如果当前节点是 p 或 q，就返回当前节点
3. 得到 p，q 在左子树中的公共祖先，得到 p，q 在右子树中的公共祖先
4. 当 left 和 right 同时为空：说明 root 的 左/右子树没有 p 和 q 的公共祖先，返回 null
5. 当 left 为空，而 right 不为空：说明 p，q 都不在左子树中，返回 right，具体可分为两种情况：
   1. p，q 其中一个节点是 right ，另一个在 right 的子树中
   2. p，q 两个节点都在 right 的子树中，此时，right 是 最近公共祖先节点
6. 当 left 不为空，而 right 为空：与 情况3 类似
7. 当 left 和 right 同时不为空：说明 p，q 分别位于 root 的异侧，返回 root

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNodre q) {
    if (root == null) {
        return null;
    }
    if (root == p || root == q) {
        return root;
    }

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if (left == null && right == null) {
        return null;
    }
    if (left == null) {
        return right;
    }
    if (right == null) {
        return left;
    }
    return root;
}
```

## 序列化与反序列化

### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823094057.png" alt="image-20210823094050280" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823094113.png" alt="image-20210823094113649" style="zoom:80%;" />

思路：

* 序列化：**BFS**。队列使用 `LinkedList` ，可以保存 `null`
* 反序列化：由BFS数组构造二叉树。二叉树使用**队列构造**，**`index` 遍历BFS数组**。

```java
public class Codec {

    public String serialize(TreeNode root) {
        if (root == null) {
            return "[]";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Deque<TreeNode> deque = new LinkedList<>();
        deque.addLast(root);

        while (!deque.isEmpty()) {
            TreeNode node = deque.removeFirst();
            if (node != null) {
                sb.append(node.val + ",");
                deque.addLast(node.left);
                deque.addLast(node.right);
            } else {
                sb.append("null,");
            }
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.append("]");

        return sb.toString();
    }

    public TreeNode deserialize(String data) {
        if (data.equals("[]")) {
            return null;
        }
        data = data.substring(1, data.length() - 1);            // 去除两端的括号
        String[] arr = data.split(",");

        TreeNode root = new TreeNode(Integer.valueOf(arr[0]));
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.addLast(root);

        int index = 1;
        while (!deque.isEmpty()) {
            TreeNode node = deque.removeFirst();

            if (!arr[index].equals("null")) {
                node.left = new TreeNode(Integer.valueOf(arr[index]));
                deque.addLast(node.left);
            }
            index++;
            if (!arr[index].equals("null")) {
                node.right = new TreeNode(Integer.valueOf(arr[index]));
                deque.addLast(node.right);
            }
            index++;
        }
        return root;
    }
}
```

## 完全二叉树

### [958. 二叉树是否是完全二叉树](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823164128.png" alt="image-20210823164128678" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823164135.png" alt="image-20210823164135774" style="zoom:80%;" />

思路：BFS。如果遇到null之后，还遇到别的数字，就说明这不是完全二叉树。

```java
public boolean isCompleteTree(TreeNode root) {
    if (root == null) {
        return false;
    }

    Deque<TreeNode> deque = new LinkedList<>();
    deque.addLast(root);
    boolean flag = false;		// 是否遇到null

    while (!deque.isEmpty()) {
        int size = deque.size();

        for (int i = 0; i < size; i++) {
            TreeNode node = deque.removeFirst();
            if (node != null) {
                deque.addLast(node.left);
                deque.addLast(node.right);
                if (flag) return false;
            } else {
                flag = true;
            }
        }
    }
    return true;
}
```

### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821165523.png" alt="image-20210821165523637" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210821165537.png" alt="image-20210821165537408" style="zoom:80%;" />

不会 * 3

思路：获得当前节点的左子树深度和右子树深度。

如果左子树深度等于右子树深度，说明左子树是满二叉树，左子树的节点个数 + 根节点 = 2 ^ 左子树深度，右子树的节点要递归计算。

<img src="https://pic.leetcode-cn.com/178498e9ec32fd5f32617bf3ca6a25014f7661c5065a3a120057b6eadf1ab22b" alt="left == right" style="zoom:67%;" />

如果左子树深度大于右子树深度，说明右子树是满二叉树，递归计算左子树的节点个数，右子树的节点个数 + 根节点 = 2 ^ 右子树深度。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210628113148624.png" alt="image-20210628113148624" style="zoom: 50%;" />

* 时间复杂度：$O(logN * logN)$
* 空间复杂度：$O(logN)$

```java
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = maxDepth(root.left);        // 左/右子树深度
        int rightDepth = maxDepth(root.right);

        int leftCount = 0;
        int rightCount = 0;
        if (leftDepth == rightDepth) {
            leftCount = 1 << leftDepth;              // 左子树节点个数 + 根节点
            rightCount = countNodes(root.right);     // 右子树节点个数
        } else if (leftDepth > rightDepth) {
            leftCount = countNodes(root.left);       // 左子树节点个数
            rightCount = 1 << rightDepth;            // 右子树节点个数 + 根节点
        }

        return leftCount + rightCount;
    }

    // 计算子树的深度
    private int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

# 二叉搜索树

## 二叉搜索树

思路：<font color='red'>中序遍历</font> + 设置一个 <font color='red'>pre</font>

### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822200412.png" alt="image-20210822200411988" style="zoom:80%;" />

不会 

时间：$O(N^{2})$ ，空间：$O(N)$

思路：动态规划。

**1. 确定DP数组和下标的含义**：`dp[j]` 表示 j 个节点能构成的不同二叉搜索树的个数

**2. 确定递推公式**：$dp(j)=\sum_{i=0}^{j - 1}dp(i)*dp(j-i-1) = dp(0)*dp(j-1)+dp(1)*dp(j-2)+...+dp(j-1)*dp(0)$

**3. DP数组初始化**：`dp[0] = 1`  ， `dp[1] = 1`

```java
public int numTrees(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int j = 2; j <= N; j++) {
        for (int i = 0; i < j; i++) {
            dp[j] += dp[i] * dp[j - i - 1];
        }
    }
    return dp[N];
}
```

### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823172001.png" alt="image-20210823172001714" style="zoom:80%;" />

不会 * 2

时间：每次操作均摊为 $O(1)$ ，空间：$O(H)$ ，`H` 是二叉搜索树的高度

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823193515.png" alt="image-20210823193515642" style="zoom: 67%;" />

思路：初始化的时候把根节点和根节点的所有左方向上的所有节点都入栈。next() 就返回当前栈顶节点的值，并把当前节点的右子节点的左方向上的所有节点都入栈。

```java
class BSTIterator {

    Deque<TreeNode> stack = new ArrayDeque<>();         // 右边是栈顶

    public BSTIterator(TreeNode root) {
        stackAddLeft(root);
    }

    private void stackAddLeft(TreeNode root) {
        while (root != null) {
            stack.addLast(root);
            root = root.left;
        }
    }

    public int next() {
        TreeNode root = stack.removeLast();
        stackAddLeft(root.right);
        return root.val;
    }

    public boolean hasNext() {
        return !stack.isEmpty();
    }
}
```

### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20211012155550764.png" alt="image-20211012155550764" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20211012155600194.png" alt="image-20211012155600194" style="zoom:80%;" />

时间：$O(N)$  ，空间：$O(N)$

思路1：中序遍历。

```java
class Solution {
    TreeNode res;
    int k;

    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return res.val;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        dfs(root.left);
        k--;
        if (k == 0) {
            res = root;
            return;
        }
        dfs(root.right);
    }
}
```

不会 * 2

思路2：迭代。

时间：$O(H + k)$  ，空间：$O(H+k)$  ，H是树的深度。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824012140.png" alt="image-20210824012140891" style="zoom:80%;" />

思路：把根节点和根节点左方向上的所有节点都入栈。然后弹出栈顶元素，每次弹出 k 就减 1，k 为 0 就返回这个值。然后把栈顶元素右儿子的左方向的节点都入栈。

```java
public int kthSmallest(TreeNode root, int k) {
    Deque<TreeNode> stack = new ArrayDeque<>();
    while (true) {
        while (root != null) {
            stack.addLast(root);
            root = root.left;
        }
        root = stack.removeLast();
        k--;
        if (k == 0) return root.val;
        root = root.right;
    }
}
```

### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822210857.png" alt="image-20210822210857681" style="zoom:80%;" />

思路：相邻两个节点的差的绝对值肯定最小的。中序遍历。设置上一个节点 pre，一个结果 min。

```java
class Solution {
    TreeNode pre = null;
    int min = Integer.MAX_VALUE;

    public int getMinimumDifference(TreeNode root) {
        if (root == null) {
            return 0;
        }

        getMinimumDifference(root.left);
        if (pre != null) {
            min = Math.min(min, Math.abs(pre.val - root.val));
        }
        pre = root;
        getMinimumDifference(root.right);

        return min;
    }
}
```

### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823120516.png" alt="image-20210823120516171" style="zoom:80%;" />

使用迭代

思路1：递归。

```java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }

    if (val == root.val) {
        return root;
    } else if (val < root.val) {
        return searchBST(root.left, val);
    } else {
        return searchBST(root.right, val);
    }
}
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210630030104715.png" alt="image-20210630030104715" style="zoom:80%;" />

思路2：**迭代**

```java
public TreeNode searchBST1(TreeNode root, int val) {
    while (root != null) {
        if (root.val == val) {
            return root;
        } else if (val < root.val) {
            root = root.left;
        } else {
            root = root.right;
        }
    }
    return null;
}
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210630030619233.png" alt="image-20210630030619233" style="zoom:80%;" />

## 二叉搜索树的增删改

### [701. 二叉搜索树的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822225845.png" alt="image-20210822225845024" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822225900.png" alt="image-20210822225900067" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822225915.png" alt="image-20210822225915727" style="zoom:80%;" />

不会 * 3

思路：DFS先序遍历。如果根节点为空，说明当前节点是我们需要插入的节点。

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }

    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    }
    if (root.val < val) {
        root.right = insertIntoBST(root.right, val);
    }

    return root;
}
```

### [450. 二叉搜索树的删除操作](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822222609.png" alt="image-20210822222609266" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822222621.png" alt="image-20210822222621592" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822222633.png" alt="image-20210822222633424" style="zoom:80%;" />

不会 * 2

思路：DFS后序遍历，找到这个需要删除的节点。关于这个节点的子节点，有三种情况：

1. 这个节点没有左子节点，那就用它的右子节点代替它。
2. 这个节点没有右子节点，那就用它的左子节点代替它。
3. 这个节点既有左子节点，又有右子节点，只需把它的左子树放到右子树最后一层最左边的节点的左子树上。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210630115318382.png" alt="image-20210630115318382" style="zoom: 50%;" />

```java
public TreeNode deleteNode(TreeNode root, int val) {
    if (root == null) {
        return null;
    }

    if (val < root.val) {
        root.left = deleteNode(root.left, val);
    } else if (root.val < val) {
        root.right = deleteNode(root.right, val);
    } else {
        if (root.left == null) {
            return root.right;
        } else if (root.right == null) {
            return root.left;
        } else {
            TreeNode cur = root.right;
            while (cur.left != null) {
                cur = cur.left;
            }
            cur.left = root.left;
            return root.right;
        }
    }
    return root;
}
```

### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823221701.png" alt="image-20210823221701126" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823221727.png" alt="image-20210823221727857" style="zoom:80%;" />

不会 * 2

时间：$O(N)$  ，空间：$O(H)$，H是树的高度

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824010101.png" alt="image-20210824010101774" style="zoom:80%;" />

思路：中序遍历二叉搜索树，找第一个错误节点和第二个错误节点。保存上一个节点 pre，每次对比当前节点和上一个节点。第一个错误节点保存 pre，第二个错误节点保存 root。

```java
class Solution {
    TreeNode first = null;
    TreeNode second = null;
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {
        dfs(root);
        int temp = first.val;
        first.val = second.val;
        second.val = temp;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        if (first == null && pre.val > root.val) first = pre;
        if (first != null && pre.val > root.val) second = root;
        pre = root;
        dfs(root.right);
    }
}
```

## 验证二叉搜索树

### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822202356.png" alt="image-20210822202355936" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210822202412.png" alt="image-20210822202412115" style="zoom:80%;" />

不会 * 3，时间：$O(N)$ ，空间：$O(N)$

思路：DFS中序遍历。全局变量保存上次处理的节点，如果上次处理的节点值比当前节点的值大，那就不是二叉搜索树。

```java
class Solution {
    TreeNode pre = null;

    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }

        if (!isValidBST(root.left)) {
            return false;
        }

        if (pre != null && pre.val >= root.val) {
            return false;
        }
        pre = root;

        return isValidBST(root.right);
    }
}
```

### [255. 验证二叉搜索树的前序遍历序列](https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824155032.png" alt="image-20210824155032754" style="zoom:80%;" />

不会 * 2

思路：按照**根左右**的顺序枚举数组，用**单调栈**保存左子树的元素，**栈顶最小，栈底最大，栈底是根节点**。在遍历右子树的时候，出现了比根节点小的值，说明这不是二叉搜索树的先序遍历。**所以用一个变量保存，当前节点不能低于的最小值**。

```java
public boolean verifyPreorder(int[] preorder) {
    Deque<Integer> stack = new ArrayDeque<>();          // 栈顶在右边，栈顶最大
    int minValue = Integer.MIN_VALUE;
    for (int i = 0; i < preorder.length; i++) {
        if (preorder[i] < minValue) {
            return false;
        }
        while (!stack.isEmpty() && preorder[i] > stack.getLast()) {
            minValue = stack.removeLast();
        }
        stack.addLast(preorder[i]);
    }
    return true;
}
```

### [剑指 Offer 33. 验证二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823120557.png" alt="image-20210823120557334" style="zoom:80%;" />

不会 * 2

时间：$O(N)$，空间：$O(N)$

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823134235.gif" alt="剑指 Offer 33. 二叉搜索树的后序遍历序列" style="zoom: 50%;" />

思路：按照**根右左**的顺序枚举数组，用**单调栈**保存右子树元素，**栈顶最大，栈底最小，栈底是根节点**。在遍历左子树的时候，出现了比根节点大的值，说明这不是二叉搜索树的后序遍历。**所以用一个变量保存，当前节点不能超过的最大值**。

```java
public boolean verifyPostorder(int[] postorder) {
    Deque<Integer> stack = new ArrayDeque<>();      // 右边是栈顶，栈顶最大
    int maxValue = Integer.MAX_VALUE;               // 当前节点不能超过的最大值
    for (int i = postorder.length - 1; i >= 0; i--) {
        if (postorder[i] > maxValue) {
            return false;
        }
        while (!stack.isEmpty() && postorder[i] < stack.getLast()) {
            maxValue = stack.removeLast();
        }
        stack.addLast(postorder[i]);
    }
    return true;
}
```

# N叉树

### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824013538.png" alt="image-20210824013538884" style="zoom:80%;" />

思路：层序遍历。添加儿子节点可以使用 addAll()

```java
public List<List<Integer>> levelOrder(Node root) {
    if (root == null) return new ArrayList<>();

    List<List<Integer>> res = new ArrayList<>();
    Deque<Node> deque = new ArrayDeque<>();
    deque.addLast(root);

    while (!deque.isEmpty()) {
        int size = deque.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            Node node = deque.removeFirst();
            level.add(node.val);
            deque.addAll(node.children);
        }
        res.add(level);
    }
    return res;
}
```

### [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824013323.png" alt="image-20210824013323134" style="zoom:80%;" />

思路：枚举下层的所有节点，递归下去，返回当前节点的子节点的最大深度 + 1。

```java
public int maxDepth(Node root) {
    if (root == null) {
        return 0;
    }
    int max = 0;
    for (Node node : root.children) {
        max = Math.max(max, maxDepth(node));
    }
    return max + 1;
}
```

### [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824012813.png" alt="image-20210824012813564" style="zoom:80%;" />

**单层递归的逻辑**：先加入当前节点，再递归当前节点的儿子。

```java
List<Integer> res = new ArrayList<>();

public List<Integer> preorder(Node root) {
    if (root == null) return res;

    res.add(root.val);
    for (Node children : root.children) {
        preorder(children);
    }
    return res;
}
```

### [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210824013015.png" alt="image-20210824013015445" style="zoom:80%;" />

**单层递归的逻辑**：先递归当前节点的儿子，再加入当前节点。

```java
List<Integer> res = new ArrayList<>();

public List<Integer> postorder(Node root) {
    if (root == null) return res;
    for (Node children : root.children) {
        postorder(children);
    }
    res.add(root.val);
    return res;
}
```

ps: N叉树不存在中序遍历，因为N叉树不存在中间节点。

# 树型DP

### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210823150050.png" alt="image-20210823150050827" style="zoom:80%;" />

不会 * 3

思路：树型dp，后序遍历。`dp0`不偷，`dp1`偷当前节点。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210731095844.png" alt="image-20210731095844251" style="zoom:67%;" />

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = dfs(root);
        return Math.max(res[0], res[1]);
    }

    private int[] dfs(TreeNode root) {
        if (root == null) {
            return new int[] {0,0};
        }

        int[] left = dfs(root.left);
        int[] right = dfs(root.right);

        int dp0 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        int dp1 = root.val + left[0] + right[0];
        return new int[] {dp0, dp1};
    }
}
```

