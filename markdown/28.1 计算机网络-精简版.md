[TOC]

# 一、概述

## 主机之间的通信方式

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210421162311071.png" alt="image-20210421162311071" style="zoom: 33%;" />

- 对等（P2P）：不区分客户和服务器。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210421162248534.png" alt="image-20210421162248534" style="zoom: 33%;" />

## 往返时延 RTT

Round-Trip Time，从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时延。

## 计算机网络体系结构

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210426154051181.png" alt="image-20210426154051181" style="zoom:67%;" />

### 1. 五层协议

- **应用层** ：为特定**应用程序**提供**数据传输服务**，例如 **HTTP、DNS 、FTP等协议**。数据单位为报文。

- **传输层** ：为**进程**提供数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：**传输控制协议 TCP**，提供面向连接、可靠的数据传输服务，数据单位为报文段；**用户数据报协议 UDP**，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

- **网络层** ：为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的**报文段**封装成**数据报**。协议：**IP、ARP、ICMP**。

- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为**同一链路的主机**提供数据传输服务。数据链路层把网络层传下来的**数据报**封装成**帧**。协议：Ethernet、PPP。

- **物理层** ：考虑的是如何在物理媒体上**传输数据比特流**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210428145600473.png" alt="image-20210428145600473" style="zoom:80%;" />

### 2. OSI

其中表示层和会话层用途如下： 

- **表示层** ：**数据压缩、加密**以及**数据格式变化**，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：**建立及管理会话**。 

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

简称：物链网输会示用（<font color='red'>物联网淑惠试用</font>）

### 3. TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为**网络接口层**。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210421174113634.png" alt="image-20210421174113634" style="zoom:80%;" />

### 4. 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

# 二、物理层

考虑的是如何在物理媒体上**传输数据比特流**。

# 三、链路层

## 封装成帧

将网络层传下来的数据报添加首部和尾部，用于标记帧的开始和结束。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423133608466.png" alt="image-20210423133608466" style="zoom:80%;" />

## MAC 地址

MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423134153606.png" alt="image-20210423134153606" style="zoom: 67%;" />

## 交换机

**依靠 MAC 地址 转发数据**，交换机内有一张 **MAC 表**，里面存放着和它相连的所有设备的 MAC 地址，它会根据收到的**数据帧**的首部信息内的目的 MAC 地址在自己的表中查找，如果有就转发，如果没有就放弃。

# 四、网络层

## IP 数据报格式

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423140613579.png" alt="image-20210423140613579" style="zoom:67%;" />

- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 TCP、UDP 、ICMP等。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423140914057.png" alt="image-20210423140914057" style="zoom:67%;" />

## IP 地址编址方式

IP 地址的编址方式经历了三个历史阶段：

- 分类

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210428111158964.png" alt="image-20210428111158964" style="zoom:67%;" />

1. HTTP 中的 IP 有多少位，范围？	（32位，每8位用 "." 隔开）

   A 类 IP 地址范围 1.0.0.1 到 127.255.255.255。

   B 类 IP 地址范围 128.0.0.1 到 191.255.255.255。

   C 类 IP 地址范围 192.0.0.1到 223.255.255.255。

   D 类 IP 地址范围 224.0.0.1 到 239.255.255.255。

   E 类 IP 地址 保留用于将来和实验使用。

2. "10." 开头的 IP 是什么？		（B类地址）

- 子网划分
- 无分类

## 地址解析协议 ARP

ARP 实现**由 IP 地址得到 MAC 地址**。

Address Resolution Protocol.

## 网际控制报文协议 ICMP

ICMP 是为了**更有效地转发 IP 数据报**和**提高交付成功的机会**。它封装在 IP 数据报中，但是不属于高层协议。

Internet Control Message Protocol.

### 1. Ping

Ping 是 ICMP 的一个重要应用，主要用来**测试两台主机是否连通**。

### 2. Traceroute

Traceroute 是 ICMP 的另一个应用，用来**跟踪一个数据报从起点到终点的路径**。

## 网络地址转换 NAT

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来**将本地 IP 转换为全球 IP**。

## 路由选择协议

1. 内部网关协议 RIP

2. 内部网关协议 OSPF

3. 外部网关协议 BGP

## 路由器

**依靠 IP 地址 转发数据**，路由器内有一份**路由表**，里面有它的寻址信息（就像是一张地图），它收到网络层的**数据报**后，会根据路由表和选路算法将数据报转发到下一站（可能是路由器、交换机、目的主机）。

### 交换机与路由器的区别

交换机：工作在链路层，依靠 MAC 地址 转发数据。

路由器：工作在网络层，依靠 IP 地址 转发数据。

### 交换机与路由器的联系

假设你使用电脑访问www.baidu.com
过程大致如下：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425145151370.png" alt="image-20210425145151370" style="zoom:67%;" />

1. 你的电脑先在应用层打包一个 HTTP报文（报文），然后在传输层在打包成 TCP报文（报文段），然后再根据 DNS 查到的 IP 在网络层打包成 IP数据报，然后在通过链路层打包成以太网数据帧（帧），发送给你的交换机：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425145335069.png" alt="image-20210425145335069" style="zoom:80%;" />

2. 你的交换机收到后，重新包装数据帧，再发送给你的路由器：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425145419308.png" alt="image-20210425145419308" style="zoom:80%;" />

3. 你的路由器利用 NAT，将你的主机IP（局域网IP）转换为外网IP，还会修改端口号，对外完全隐藏你的主机，再根据路由表选择一条合适的路径进行转发：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425145504108.png" alt="image-20210425145504108" style="zoom:80%;" />

4. 在接下来的过程中，每个节点都只改变 MAC 地址，然后在网络中一路向着目的地发送。

# 五、传输层

## UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。**不可靠，无连接，时延小，适用于小文件。使用场景：QQ消息。**
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。**可靠，面向连接，时延大，适用于大文件。使用场景：浏览器。**

## UDP 首部格式

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423145959155.png" alt="image-20210423145959155" style="zoom: 67%;" />

首部字段只有 **8 个字节**，包括**源端口、目的端口、长度、检验和**。12 字节的伪首部是为了计算检验和临时添加的。

## TCP 首部格式

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423171123594.png" alt="image-20210423171123594" style="zoom:67%;" />

- **序号 seq**：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号 ack**：**期望收到的下一个报文段的序号。**例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：首部的长度。
- 紧急位 URG ：当 URG = 1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，需配合紧急指针使用。
- **确认位 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1，<font color='red'>Ack</font>nowledge。
- 推送位 PSH。
- 复位位 RST。
- **同步位 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<font color='red'>Syn</font>chronize。
- **终止位 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<font color='red'>Fin</font>ish。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## TCP 的三次握手 

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423172821296.png" alt="image-20210423172821296" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210429154500452.png" alt="image-20210429154500452" style="zoom: 33%;" />

### 三次握手过程 

* 客户端——发送带有 SYN 标志的报文——服务端 **一次握手** 客户端进入SYN-SENT状态。
* 服务端——发送带有 SYN/ACK 标志的报文——客户端 **二次握手** 服务端进入SYN-RCVD状态。
* 客户端——发送带有 ACK 标志的报文——服务端 **三次握手** 连接就进入ESTABLISHED状态。

三步握手：
​	A：“喂，你能听到我说话吗？”
​	B：“我能听到，你能听到我说话吗？”
​	A：“我能听到你说话，今天balabala…”。

两步握手：
	A：“喂，你能听到我说话吗？”
	B：“我能听到！”
	A：“喂喂，你能听到我说话吗？”
	B：“我能听到！”
	A：“你TM到底能不能听到我说话啊？”
	B：“…”

四步握手：
	A：“喂，你能听到我说话吗？”
	B：“我能听到，你能听到我说话吗？”
	A：“我能听到，你能听到我说话吗？”
	B：“…人类的本质是复读机？”

### **为什么三次**

防止失效的连接请求到达服务器，建立了多余的链接，浪费资源。

### **为什么两次不行**

1. 防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。

2. 两次握手只能保证单向连接是畅通的。

### SYN 洪范攻击

又称为 DoS 攻击。

攻击者发送SYN，SYN是TCP三次握手中的第一个数据包，当服务器返回ACK，攻击者就不回应ACK，那这个TCP连接就一直处于挂起状态。服务器收不到ACK，就会重复发送ACK给攻击者，这会浪费服务器的资源。攻击者发送大量的这种TCP连接，最后服务可能会死机。

解决方法：设置 SYN cookie

## TCP 的四次挥手

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210423193423558.png" alt="image-20210423193423558" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210429155200839.png" alt="image-20210429155200839" style="zoom: 25%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210429154402485.png" alt="image-20210429154402485" style="zoom:80%;" />

### 四次挥手过程

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。每一个 SYN 的 ACK 中的确认号就是 SYN 的初始序列号 + 1，每一个 FIN 的 ACK 中的确认号就是 FIN 序列号 + 1。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

* 客户端——发送带有 FIN 标志的报文——服务端，关闭与服务端的连接 。一次挥手，客户端进入FIN-WAIT-1状态。
* 服务端——发送带有 ACK 标志的报文——客户端。二次挥手，服务端进入了CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。
* 服务端——发送带有 FIN/ACK 标志的报文——客户端，关闭与客户端的连接。三次挥手，服务端进入LAST-ACK状态。
* 客户端——发送带有 ACK 标志的报文——服务端。四次挥手，客户端进入TIME-WAIT状态，等待 2 MSL（最大报文存活时间）后释放连接。服务端收到客户端的确认后释放连接。

四步挥手：
	A：“喂，我不说了！”
	B：“我知道了！等下，上一句还没说完，balabala…”
	B：“好了，说完了，我也不说了！”
	A：“我知道了！”

### **为什么四次**

 因为需要确保客户端与服务端的数据能够完成传输。

### CLOSE-WAIT

 这种状态的含义其实是表示在**等待关闭**。

### TIME-WAIT

**TIME-WAIT的作用？**

为了解决网络的丢包和网络不稳定所带来的其他问题，**确保客户端能在一定的时间范围内，关闭自己的连接。**

**如何查看TIME-WAIT状态的链接数量？** 

```shell
netstat -anp | grep TIME_WAIT | wc -l 			# 查看连接数等待time_wait状态连接数。
```

**为什么会TIME-WAIT过多？解决方法是怎样的？**

**可能原因：** 服务器有太多的高并发短连接的 TCP 连接

**解决：**负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接。

## TCP 可靠传输

1. 校验和
2. 序列号 + 确认应答
4. 超时重传：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段

5. 流量控制
6. 拥塞控制

## TCP 滑动窗口

滑动窗口是发送的请求队列，**如果滑动窗口左部的字节的已经发送并且收到了确认位 ACK ，则窗口移动。**

## TCP 流量控制

流量控制是为了**控制发送方的发送速率，保证接收方来得及接收。**

**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。**将窗口字段设置为 0，则发送方不能发送数据。

## TCP 拥塞控制

出现拥塞的条件：**如果网络出现拥塞，数据报将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。**

拥塞控制：**控制发送方的发送速率**。

流量控制与拥塞控制的区别：流量控制是为了让接收方能来得及接收，而拥塞控制是为了**降低整个网络的拥塞程度**。

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

### 1. 慢开始与拥塞避免

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210424174231199.png" alt="image-20210424174231199" style="zoom:67%;" />

设拥塞窗口是 cwnd，慢开始门限是 ssthresh。

发送开始执行慢开始，从发送方只能**发送 1 个报文段**开始，**收到确认**之后，**翻倍发送报文段**：2、4、8 ...

每次发送的报文段都翻倍，可能会导致拥塞。设置一个**慢开始门限 ssthresh**，当 发送的报文段 >= 慢开始门限 时，进入**拥塞避免**，**每次发送的报文段 + 1**。

如果出现了**超时**，则令 **慢开始门限 = 发送的报文段 / 2**，然后**重新执行慢开始**。

### 2. 快重传与快恢复

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210424214522643.png" alt="image-20210424214522643" style="zoom: 67%;" />

在发送方，**如果收到三个重复的确认，就执行快重传，立即重传下一个报文段。**

执行**快恢复**，令 **慢开始门限 = 发送的报文段 / 2** ，令 **即将要发送的报文段 = 慢开始门限**，此时**直接进入拥塞避免**。

## TCP 心跳包

### 为什么存在 TCP 心跳包

它像心跳一样每隔一段时间发送一次，以此告诉服务器，客户端还活着。

### 心跳包的内容

没有特别规定，一般都是很小的包，或者只包含包头的一个空包。

## 应用层粘包

也称之为 TCP 粘包，但是这种说法是错的，称之为应用层粘包更好。UDP 不会出现粘包的现象。这里的包是报文的含义。

### 应用层粘包问题

包的头紧接着前一包的尾。

### 造成应用层粘包的原因

发送方：使用 **Nagle 算法**会出现粘包问题。

接收方：接收**包到缓存的速度大于应用程序从缓存中读取包的速度**，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

### 如何处理粘包现象

发送方：**关闭 Nagle 算法**，使用 `TCP_NODELAY` 选项来关闭算法。

接收方：在包头加上包体长度。

# 六、应用层

## 域名系统

DNS（Domain Name System），DNS 是一个**分布式数据库**，实现了 **域名** 和 **IP 地址** 的转换。这里的分布式数据库是指，d。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425163358151.png" alt="image-20210425163358151" style="zoom:67%;" />

域名具有层次结构，从上到下依次为：根域名、一级域名、二级域名。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425150818991.png" alt="image-20210425150818991" style="zoom: 67%;" />

域名：www.yifang.com，一般根域名会自动省去。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425151103238.png" alt="image-20210425151103238" style="zoom: 50%;" />

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。

**大多数情况下 DNS 使用 UDP 进行传输**，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。

**在两种情况下会使用 TCP 进行传输**：

- 如果**返回的响应超过的 512 字节**（UDP 最大只支持 512 字节的数据）。
- **区域传送**（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

### 域名解析过程

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210425170403942.png" alt="image-20210425170403942" style="zoom: 67%;" />

本机向本地域名服务器采用**递归查询**，本地域名服务器向根域名服务器查询采用**迭代查询**，根域名服务器会告知一级域名服务器的地址，一级域名服务器告知下一步应该向哪个权限域名服务器进行查询，最后权限域名服务器返回 需要查找的 IP 地址。

## 文件传送协议

**FTP**（File Transfer Protocol）**使用 TCP ，传送一个文件需要控制连接和数据连接**：

- **控制连接**：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。用来**传送命令**。
- **数据连接**：用来**传送文件数据**。

## 远程登录协议

**TELNET 使用 TCP ，用于远程主机登录，远程主机的输出会显示到本地主机上。**

## 电子邮件协议

邮件协议包含发送协议和读取协议。

**发送协议**： **SMTP**

**读取协议**： **POP3** 和 **IMAP**。

## 常用端口

看看就行

| 应用           | 应用层协议 | 端口号 | 传输层协议 | 备注                        |
| -------------- | ---------- | ------ | ---------- | --------------------------- |
| 域名解析       | **DNS**    | 53     | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 文件传送协议   | **FTP**    | 20/21  | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议   | **TELNET** | 23     | TCP        |                             |
| 超文本传送协议 | **HTTP**   | 80     | TCP        |                             |

## Web 页面请求过程

Web 页面请求过程（在浏览器中输入 URL 到显示页面的过程、HTTP 的连接过程）

1. 浏览器**解析 URL**，解析出域名
2. 浏览器请求 **DNS 解析域名**，DNS  **解析出 IP 地址**
3. 浏览器发起 **TCP 的 三次握手**，浏览器与服务器建立 TCP 连接
4. 浏览器**发出 HTTP 请求**
5. 服务器**响应 HTTP 请求**
6. 浏览器**解析 HTTP 报文**，**抽取出 Web 页面内容**，之后进行**渲染**，**显示** Web 页面。
7. 浏览器发起 **TCP 的四次挥手**，断开 TCP 连接

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210428163216988.png" alt="image-20210428163216988" style="zoom: 67%;" />

# 七、一些问题

1. TCP 三步握手中第一步握手的序号如何产生？
	
	* seq = C + H (源IP地址，源端口，目的IP地址，目的端口)。其中，C 是一个计时器，每隔一段时间值就会变大，H 是消息摘要算法，输入是一个四元组（源IP地址，源端口，目的IP地址，目的端口）。
	
	* 消息摘要算法：MD5，SHA-256。
	
2. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？

   * 65536 - 1024

   * 因为 TCP 的报文头部中源端口号和目的端口号的长度是 16 位。2 ^ 16 = 65536。0 到 1023 是知名服务端口，所以要减少 1024 个端口号。
   * 而对于服务端来说，可以打开的端口号与 Linux可以打开的文件数量 有关，并且可以通过 MaxUserPort 来进行配置。

3.  说一下 TCP 的 封包 和 拆包 ？

   * 封包：封包就是在发送报文段的时候为每个报文段加上一个包头，将数据报分为 **包头** 和 **包体** 两个部分。包头是一个**固定长度的结构体**，里面包含该**数据报的总长度**。 

   * 拆包：接收方**提取包头**，**解析数据报**。

4. 为什么说 UDP 协议 是 无连接协议？
   * 不能保证最终到达的目的地。

