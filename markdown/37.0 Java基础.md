[toc]

## 一、Java语言基础

### Java预备知识

Java区分大小写。

Java是静态语言。但是 Java 有反射机制，所以具有动态语言的特性。写代码的时候必须指定每个变量的类型。但是 Java 10 开始，局部变量可以使用 var。

包（package）的本质就是文件夹，一般利用公司域名倒置作为包名。

Java中的引用就是地址。

Java中的**所有函数都是某个类的方法**。Java中的方法可以没有参数，但即使**没有参数**，**也需要使用括号**。

字段是fileds。

#### 平台无关

**JVM：** 编译器生成与计算机体系结构无关的字节码，字节码文件不仅能在任何机器解释执行，还能动态转换成本地机器码，转换由 JVM 实现。JVM 是平台相关的，屏蔽了不同操作系统的差异。

**语言规范：** 基本数据类型大小有明确规定，如 int 永远 32 位，而 C/C++ 可能是 16 位、32 位，或编译器开发商指定的其他大小。数值类型有固定字节数，字符串用标准 Unicode 格式。

#### JDK、JRE、JVM

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211001124659.png" alt="image-20211001124659452" style="zoom: 67%;" />

* JDK: Java Development Kit，Java开发工具包，提供了 Java 的开发及运行环境。JDK 集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。

* JRE: Java Runtime Environment，Java运行时环境。运行 Java 程序的必要环境，主要包括了 JVM 和一些 Java 基核心类库。

* JVM: Java Virtual Machine，Java虚拟机。

**JDK、JRE、JVM的区别：**

https://zhuanlan.zhihu.com/p/48285067

#### 命名规范

1. **类**：驼峰命名，首字母大写。				    MaxValue

2. **变量，方法**：驼峰命名，首字母小写。	maxValue

3. **常量**：大写 + 下划线。							   MAX_VALUE

#### 注释

```java
// 一共有三种注释方法

/*
	这是第二种
*/

/**
 *  这种是文档注释
 */
```

### 数据类型

#### 1. 基本数据类型

|  类型   | 大小（byte） |
| :-----: | :----------: |
|  byte   |      1       |
|  char   |      2       |
|  short  |      2       |
|   int   |      4       |
|  float  |      4       |
|  long   |      8       |
| double  |      8       |
| boolean |   没有规定   |

**float 与 double**

Java 不能隐式执行向下转型，因为这会使得精度降低。

1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。

```java
// float f = 1.1;		// 这会报错
```

1.1f 字面量才是 float 类型。

```java
float f = 1.1f;
```

**隐式类型转换**

```java
int x = 50;
float y = x;		// y的值为50
```

问题：int n =  'a'; 这样写对吗？                                （对，隐式类型转换）

**显式类型转换**

```java
int a = (int) 45.23;			// a的值为45
```

#### 2. 引用数据类型

```java
Object obj = new Object();
```

##### 包装类型

基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。

| Primitive type | Wrapper class |
| -------------- | ------------- |
| boolean        | Boolean       |
| byte           | Byte          |
| char           | Character     |
| float          | Float         |
| int            | Integer       |
| long           | Long          |
| short          | Short         |
| double         | Double        |

###### 默认值

```java
int a;			// int的默认是0
boolean b;		// boolean的默认值是false
Integer c;		// 实例化对象的默认值是null
```

###### 自动装箱、自动拆箱

在 JDK 1.5 之后，引入新特性：自动装箱、自动拆箱，基本数据类型 和 引用数据类型 之间 可以相互转换。

```java
Integer i = 0;				// 自动装箱   	int --> Integer		编译器会在自动装箱过程调用 Integer.valueOf()方法
int j = new Integer(0);		// 自动拆箱		Integer --> int
```

###### 基本类型、包装类、String 之间的相互转换

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20211001170235.png" alt="image-20210531180027240" style="zoom:80%;" />

```java
String.valueOf(i);
Integer.valueOf(str);
```

###### Integer API

```java
Integer.valueOf("123");
Integer.MAX_VALUE;
Integer.MIN_VALUE;
```

#### 3. 常量池（缓存池）

new Integer(123) 与 Integer.valueOf(123) 的区别：

- new Integer(123) 会在堆里新建一个对象；
- Integer.valueOf(123) 会使用常量池中的对象，如果常量池没有，则会在常量池中新建对象，第二次开始调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    		// false
```

```java
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   		// true
```

Integer.valueOf(i) 的实现方法：

判断 i 是否在常量池范围之中，不在的话，在堆中创建 Integer 对象，也就是 new Integer(i)。再判断常量池内是否有 Integer 对象 i，在的话，直接返回常量池中的 Integer 对象 i；不在的话，在常量池中新建 Integer 对象 i，再返回常量池中的 Integer 对象 i。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210531201630902.png" alt="image-20210531201630902" style="zoom: 80%;" />

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在 Java 8 中，Integer 常量池的大小默认为 -128~127。常量池大小可更改。

```java
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j);		// false
```

```java
Integer i = 123;
Integer j = 123;
System.out.println(i == j); 	// true
```

```java
Integer i = 133;
Integer j = 133;
System.out.println(i == j); 	// false
```

#### 4. 数值比较

问题：**两个 int 如何比较？**                            （使用 == 即可）

问题：**int 和 Integer 如何比较？**

（使用 == 即可，比较的时候 Integer 会自动拆箱 int）

问题：**两个 Integer 如何比较，使用 == 还是 equals() ？**

（ 在 -128 ~ 127 范围之内，使用 == 和 equals() 比较都可以，== 比较的是 Integer 常量池中的地址。超过这个范围，使用 equals() 进行比较）

**int 与 Integer 的区别**

* int 是 Java 的基本数据类型；Integer 是 包装类型
* int 直接存储值；Integer 是对象的引用
* int 的默认值是 0；Integer 的默认值是 null

问题：负数的除法和余数的结果是什么？  

* 表达式 a/b 的商会向 0 取整。余数的例子：-14/3 和 14/-3 的商都是 -4，但 -14 % 3 是 -2，而 14 % -3 是 2  

### 变量、常量、字面量


#### 1. 变量

* 可以在一行中声明多个变量

```java
int i, j;
```

* 但是不提倡这种风格，逐一声明可提高代码的可读性。

```java
int i;
int j;
```

* 从 Java 10 开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型了。

```java
var age = 22;			// age是int
var name = "yifang";	// name是String
```

##### 变量按照在类中声明的位置分类

* 成员变量
  * 类变量（静态变量）：类变量被所有实例共用。
  * 实例变量

* 局部变量

```java
public class test {
	public static int a = 0;	// 类变量（静态变量）
    public String nameString;	// 实例变量
	
	public void test() {
		int temp = 1;		// 局部变量
		System.out.println(temp);
	}
}
```

|              |       静态变量       |    实例变量    |           局部变量           |
| :----------: | :------------------: | :------------: | :--------------------------: |
| **定义位置** |    在类中，方法外    | 在类中，方法外 | 方法中，或者是方法的形式参数 |
|   调用方式   | 类名调用、对象名调用 |   对象名调用   |              -               |
| **存储位置** |        方法区        |       堆       |              栈              |
| **生命周期** |      与类共存亡      |  与对象共存亡  |         与方法共存亡         |

#### 2. 常量

* 常量使用 final 关键字，一旦被赋值了，就不能再被更改了

```java
final int MAX_VALUE = 10;
```

* 使用 static final 设置一个类常量，同一个类的其他方法也可以使用这个常量。public 称为 限定修饰符。

```java
public static final int MAX_VALUE = 10;
```

#### 3. 字面量

字面量是出现在 ”=“ 右边不变的内容。

```java
int age = 22;			// 22是字面量
String name = "yifang";	// "yifang"是字面量
```

### 运算符

**运算符优先级**

* `* / %` 优于 `+ -`
* `!` 优于 `&&` 优于 `||`

**隐式赋值**

```java
x += 4;
```

```java
x++;		// 在工程中不建议使用
x--;
```

**逻辑运算符的短路求值法则**：表达式从左向右求值，一旦整个表达式的值已知则停止求值

### 方法

#### 静态方法和实例方法的区别

* **静态方法**：只能使用 **静态变量** or **静态方法**
* **实例方法**：能使用 **静态变量**、**静态方法**，**实例变量**、**实例方法**

### 参数传递

**Java的参数**是以**值传递**的形式**传入方法**中。

* 如果方法的参数是**基本数据类型**（Primitive Data Type Arguments）：在调用函数时，**传递的是值**。**如果在函数中对参数进行修改，将不会影响到实际参数**。
* 如果方法的参数是**引用数据类型**（Reference Data Type Arguments）：在调用函数时，传递的是**引用的值**。如果在函数中对参数内部的值进行修改，将**会影响到实际参数**。Integer等包装类不会改变内部的值。

```java
public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
```

**在方法中改变对象的字段值会改变原对象该字段值**，因为引用的是同一个对象。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

但是**在方法中将指针引用了其它对象**，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对**另一个指针所指向的对象没有影响**。也就是说外部是外部的指针，内部是内部的指针，内部无法更改外部的指针，但是可以修改指针所指对象的字段值。

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```

## 二、流程控制

条件语句

if

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210529123529431.png" alt="image-20210529123529431" style="zoom: 80%;" />

```java
if () {
    
} else if () {
    
} else {
    
}
```

switch

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210529123704538.png" alt="image-20210529123704538" style="zoom:80%;" />

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch 条件判断语句支持什么对象？ **switch 支持 char、int、String。**

循环语句

for

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210529124538136.png" alt="image-20210529124538136" style="zoom:80%;" />

```java
for (<initialize>; <boolean expression>; <increment>) {	// 循环条件是true，就执行语句
    <block statements>
}
```

for-each

```java
for (对象的元素类型 局部变量: 对象){
    <block statements>
}
```

while

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210529124558746.png" alt="image-20210529124558746" style="zoom:80%;" />

```java
<initialize>;
while (<boolean expression>) {		// 条件是true，就执行语句。
    <block statements>
	<increment>;
}
```

do-while

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210611234112132.png" alt="image-20210611234112132" style="zoom: 50%;" />

```java
do {
    执行语句;
} while(条件表达式);
```

循环控制

break

跳出 循环体 或 switch

continue

跳过本次循环

**break 和 continue 的区别？**

* break：跳出 循环体 或 switch
* continue：跳过本次循环

## 三、数组

### 数组

声明、创建：

```java
int[] arr = new int[3];
```

初始化：

```java
int[] arr = new int[3];
for (int i = 0; i < 3; i++) {
    arr[i] = i;
}
```

声明、创建、初始化：

```java
int[] arr = new int[3] {1, 2, 3};
```

声明、初始化：

```java
int[] arr = {1, 2, 3};
```

创建一个数字数组：所有的元素都初始化为**0**。

创建一个**Boolean数组**：所有的元素都初始化为**false**。

创建一个**对象数组**：所有的元素都初始化为**null**，表示这些元素还未存放任何对象。

* for each 循环：

```java
for (int a : arr) {
	System.out.println(a);
}
```
* 声明、创建二维数组

```java
int[][] arr = new int[3][3];
```

* 起别名：也称为浅拷贝，就是复制数组的地址

```java
int[] a = {1,2,3};
int[] b = a;	// b就是a的浅拷贝
```

* 深拷贝：

```java
int[] a = {1,2,3};
int[] b = a.clone();	// b就是a的深拷贝
```

数组也是对象。

### Arrays API

Arrays 是 数组的工具类

```java
import java.util.*;
System.out.println(Arrays.toString(nums));
arr1 = Arrays.copyOf(arr, 0, arr.length);
Arrays.sort(arr);							// arr排序		Arrays.sort(arr, new Comparator<>() {});
Arrays.binarySearch(arr, 0, arr.length, 要查的数字);
Arrays.fill(arr, 要填充的数字);
Arrays.equals(arr, arr1);
Arrays.asList(arr);							// Arrays转List
Arrays.toString(arr);
```

```java
java.util.Arrays
String toString(xxx[] arr)
copyOf(xxx[] arr, int start, int end)						// 复制start到end-1的元素
void sort(xxx[] arr)
void sort(T[] a, Comparator<? super T> c) 
int binarySearch(xxx[] arr, int start, int end, xxx v)		// 二分查找，返回下标
void fill(xxx[] arr, xxx v)
boolean equals(xxx[] arr1, xxx[] arr2)
static <T> List<T> asList(T... a)  
```

## 四、String

### 1. String API

```java
java.lang.String
char charAt(int index)
boolean equals(Object other)
int indexOf(String str)
int lastIndexOf(String str)
int length()
String substring(int beginIndex, int endIndex)
String valueOf(int i)
```

```java
import java.lang.*;
str.charAt(i);
str1.equals(str2);			// 值比较，"=="是地址比较
str.indexOf("a");			// 从前往后"a"的第一个位置
str.lastIndexOf("a");		// 从后往前"a"的第一个位置
str.length();
str.substring(0, str.length());	// 返回str
String.valueOf(i);				// int转String
```

String 值和数字之间相互转换的 API  ：

```java
public class Integer {
    static int parseInt(String s) 		// 将字符串 s 转换为整数
	static String toString(int i) 		// 将整数 i 转换为字符串
}
```

```java
public class Double {
    static double parseDouble(String s) 	// 将字符串 s 转换为浮点数
	static String toString(double x) 		//将浮点数 x 转换为字符串
}
```

### 2. 概览

String 被声明为 final，所以它**不可被继承**。(Integer 等**包装类也不能被继承**）

在 JDK 1.8 中，String 内部使用 **char 数组**存储数据。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```

在 JDK 1.9 之后，String 类的实现改用 **byte 数组**存储字符串，同时使用 `coder` 来标识使用了哪种编码。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

value 数组被声明为 final，这表明 value 数组初始化之后就不能再被改变了。并且 String 内部没有改变 value 数组的方法，因此可以保证 **String 不可变**。

问题：基本数据类型 与 String 的区别？

String 是引用数据类型，默认值是 null，初始化后，String是不可变的。

### 3. 不可变的好处

**1. 可以缓存 hash 值**

String 的 hash 值也不可变，只需要计算一次 hash 值即可。 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。

**2. String Pool 的需要**

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中获取。只有 String 是不可变的，才可能使用 String Pool。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210519094842492.png" alt="image-20210519094842492" style="zoom: 50%;" />

**3. 安全性**

String 经常作为参数，String 不可变性可以**保证参数不可变**。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。

**4. 线程安全**

String 可以**在多个线程中安全地使用**。

### 4. String, StringBuffer and StringBuilder的区别

- String 不可变，线程安全
- StringBuffer 可变，线程安全，内部使用 synchronized 同步
- StringBuilder 可变，线程不安全

在大部分情况下，速度对比，**StringBuilder** > StringBuffer > String。

JDK 1.8 之前，这三者，底层都使用 char[] 存储。

### 5. StringBuffer/StringBuilder API

```java
import java.lang.*;
java.lang.StringBuilder
StringBuilder()			// 空的StringBuilder构造器
int length()
    
StringBuilder append(String str)			// 增：追加一个字符串，并返回this
StringBuilder delete(int startIndex, int endIndex)	// 删：删除startIndex到endIndex-1的代码单元并返回this
void setCharAt(int i, char c)				// 改：将第i个代码单元设置为c
char charAt(int i)							// 查：查询第i个char
StringBuilder insert(int offset, String str)	// 插：在offset的位置插入字符串str并返回this
```

```java
sb.reverse();
sb.setLength(0);			// sb设置为""
sb.deleteCharAt(index);
```

### 6. String Pool（字符串池）

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528152228514.png" alt="image-20210528152228514" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528152209281.png" alt="image-20210528152209281" style="zoom:80%;" />

#### String Pool 的位置演进

在 Java 7 中，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 **OutOfMemoryError** 错误。

优点：节省内存，节省创建相同字符串的时间

缺点：JVM 在 String Pool 中遍历需要时间，不过比创建相同字符串的时间短很多

### 7. 创建String的方式

1. 采用 **new** 关键字新建一个字符串对象
2. 采用 **字面值** 的方式赋值
3. 采用 **intern()** 函数

**方式一：采用 new 关键字新建一个字符串对象**

```java
String str1 = new String("aaa");
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528155307291.png" alt="image-20210528155307291" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528160755582.png" alt="image-20210528160755582" style="zoom: 67%;" />

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "aaa" 字符串对象）。

- "aaa" 属于字符串字面值，在编译的时候会在 String Pool 中创建一个字符串对象，保存这个 "aaa" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象，指向 String Pool 中的字符串对象，返回的是堆中字符串对象的引用。

如果 String Pool 已经有 "aaa" 字符串对象，直接在堆中创建一个字符串对象，指向 String Pool 中的 "aaa" 字符串对象，返回的是堆中字符串对象的引用。

**方式二：采用字面值的方式赋值**

```java
String str2 = "bbb";
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528155349000.png" alt="image-20210528155349000" style="zoom:50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528160816874.png" alt="image-20210528160816874" style="zoom: 67%;" />

如果是采用 "bbb" 这种字面值的方式赋值，如果 "bbb" 不在String Pool 中，会自动地将 "bbb" 放入 String Pool 中。返回的是 String Pool 中的字符串对象的引用。

**方式三：采用 intern() 函数**

```java
String str3 = "ccc".intern();
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528155404058.png" alt="image-20210528155404058" style="zoom:50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210528160830834.png" alt="image-20210528160830834" style="zoom:67%;" />

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加这个新的字符串，并返回这个新字符串的引用。

#### String的地址比较

实例变量和字面量的比较（"=="），结果永远是false。实例变量保存在堆中，字面量保存在 String Pool 中。

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);           // true
```

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  			// true
```

```java
String str1 = new String("aaa");
String str2 = str1.intern();
System.out.println(str1 == str2);		// false
```

```java
String str3 = new String("aaa");
String str4 = "aaa".intern();
System.out.println(str3 == str4);		// false
```

```java
String str5 = "aaa";
String str6 = "aaa".intern();
System.out.println(str5 == str6);		// true
```

```java
String str7 = "a" + "a" + "a";
String str8 = "aaa";
System.out.println(str7 == str8);		// true
```

```java
String str9 = "a" + "a" + new String("a");
String str10 = "aaa";
System.out.println(str9 == str10);		// false
```

String的地址比较：分 JDK6 与 JDK7/8

```java
String s1 = new String("1") 
s3.intern();
String s2 = "1";
System.out.println(s1 == s2);		// JDK6: false;		JDK7/8: false
```

```java
// JDK6: 	不会在String Pool中创建"11";
// JDK7/8:	会在String Pool中创建"11";
String s3 = new String("1") + new String("1");	
s3.intern();
String s4 = "11";
System.out.println(s3 == s4);		// JDK6: false;		JDK7/8: true
```

问题：说说字符串的编码和解码？

* 编码：String ➡ 字节
* 解码：字节 ➡ String

问题：说说日期的格式化？

* 格式化：日期 ➡ String
* 解析：String ➡ 日期

## 五、关键字

### final

#### 1. 数据

常量使用 final 关键字，一旦被赋值了，就不能再被更改了

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

#### 2. 方法

声明方法不能被子类重写。private 方法隐式地被指定为 final。

#### 3. 类

声明类不允许被继承。

### static

#### 1. 静态变量

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。

- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

```java
public class A {
	
    public static int y;  // 静态变量
    public int x;         // 实例变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
```

#### 2. 静态方法

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。

```java
public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
```

**静态方法和实例方法的作用**

* **静态方法**的主要作用是**实现函数**

* 非静态**（实例）方法**的主要作用是**实现数据类型的操作**  

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210803103419.png" alt="image-20210803103419566"  />

#### 3. 静态语句块

静态语句块在类初始化时运行一次。

```java
public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
```

```java
123
```

#### 4. 静态内部类

非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

静态内部类不能访问外部类的非静态的变量和方法。

```java
public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

#### 5. 静态导包

在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低，不建议使用。

```java
import static com.xxx.ClassName.*
```

#### 6. 初始化顺序

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

```java
public static String staticField = "静态变量";
```

```java
static {
    System.out.println("静态语句块");
}
```

```java
public String field = "实例变量";
```

```java
{
    System.out.println("普通语句块");
}
```

最后才是构造函数的初始化。

```java
public InitialOrderTest() {
    System.out.println("构造函数");
}
```

存在继承的情况下，初始化顺序为：

- 父类（类变量、static语句块）
- 子类（类变量、static语句块）
- 父类（实例变量、普通语句块）
- 父类（构造方法）
- 子类（实例变量、普通语句块）
- 子类（构造方法）

## 六、常用的类

### 数学

#### 1. Math API

```java
import java.math.*;
Math.max(a, b);
Math.min(a, b);
Math.abs(a);
Math.round(a);		// 四舍五入
Math.ceil(a);		// 向上取整
Math.floor(a);		// 向下取整
Math.random();		// 返回0~1的double
```

**2. Random API**

**3. BigInteger API**

不可变的任意精度的整数。

**4. BigDecimal API**

不可变的任意精度的小数。

涉及精度很高的工作，如银行，应该使用 BigDecimal 。

### 日期

#### 1. LocalDate API

```java
import java.time.*;
LocalDate date = LocalDate.now();
LocalDate birthday = LocalDate.of(1998, 8, 26);
System.out.println(date.getYear());
System.out.println(date.getMonthValue());
System.out.println(date.getDayOfMonth());
System.out.println(date.getDayOfWeek());
```

```java
java.time.LocalDate
static LocalDate now()
static LocalDate of(int year, int month, int day)
int getYear()			
int getMonthValue()		// 当前的月
int getDayOfMonth()		// 当前的日
DayOfWeek getDayOfWeek()	// 星期几
```

#### 2. LocalTime API

```java
java.time.LocalTime
static LocalTime now()
static LocalTime of(int hour, int minute, int second)
int getHour()
int getMinute()
int getSecond()
```

#### 3. LocalDateTime API

LocalDateTime = LocalDate + LocalTime

```java
java.time.LocalDateTime
static LocalDateTime now()
static LocalDateTime of(int year, int month, int day, int hour, int minute, int second)
int getYear()			
int getMonthValue()		// 当前的月
int getDayOfMonth()		// 当前的日
DayOfWeek getDayOfWeek()	// 星期几
int getHour()
int getMinute()
int getSecond()
```

### 比较器

Java 对象之间的比较只能使用 == 或 != ，不能使用 > 或 < 。要对多个对象进行排序，需要实现接口 Comparable 并重写 compareTo(obj)

或者 使用 Comparator 并重写 compare(obj1, obj2)

#### 1. Comparable API

Comparable API 模板：

```java
 public interface Comparable<T> {
    public int compareTo(T o);
 }
```

例子：

```java
public class Student implements Comparable{

    public int age;
    public String name;

    public Student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public int compareTo(Object o) {
        if (o instanceof Student) {
            Student student = (Student) o;

            if (this.age > student.age) {
                return 1;
            } else if (this.age < student.age) {
                return -1;
            } else {
                return 0;
            }
        } else {
            throw new RuntimeException("传入的数据类型不一致!");
        }
    }
}
```

```java
public class test {
    public static void main( String[] args )
    {
        Student[] students = new Student[2];
        students[0] = new Student(22,"yifang");
        students[1] = new Student(20,"Mikasa");

        Arrays.sort(students);
        System.out.println(Arrays.toString(students));
    }
}
```

```java
// 输出结果
[Student{age=20, name='Mikasa'}, Student{age=22, name='yifang'}]
```

#### 2. Comparator API

Comparator API 模板：

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
    boolean equals(Object obj);
}
```

例子：

```java
String[] arr = new String[]{"DD", "NN", "AA"};
Arrays.sort(arr);
System.out.println(Arrays.toString(arr));
```

```java
// 输出正序
[AA, DD, NN]
```
使用 Comparator 

```java
String[] arr = new String[]{"DD", "NN", "AA"};
Arrays.sort(arr, new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        return o2.compareTo(o1);				// 基本类型使用 o2 - o1，实现逆序
    }
});
System.out.println(Arrays.toString(arr));
```

```java
// 输出逆序
[NN, DD, AA]
```

#### Comparable与Comparator对比

* **Comparable**：需要比较的对象**实现 Comparable 接口**，并**重写 compareTo()** 方法。耦合度更高。
* **Comparator**：在对象外比较，需要**重写 compare()** 方法。耦合度更低，更加灵活。

### Scanner API

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String args[]) throws Exception {
        Scanner cin = new Scanner(System.in);
        var a = cin.nextInt();
        var b = cin.nextInt();
        System.out.println(a + b);
    }
}
```

### System API

```java
java.lang.System 
static long currentTimeMillis()	     	// 返回当前GMT(格林威治)时间，以毫秒为单位
static void gc()						// gc, 调用垃圾回收器
    
System.out.println(data);
```

### Random API

```java
Random random = new Random();
random.nextInt(10);		// 随机生成一个[0,10)的数
```

## 七、对象和类

### OOP

OOP: object-oriented programming，**面向对象编程**：将数据类型的值封装在对象中。

**对象**：任何存在的事物。如：小饼干。

**类**：封装对象属性和方法的载体。想象成制作小饼干的模具。

**实例化**：对象的创建。            				                               Date date = new Date();

属性（字段）：对象中的数据（变量）。							int a = 10;

方法：操作数据的过程（行为）。		                                Arrays.sort(arr);

如何识别类：名词多半是类，而动词多半是方法。

问题：介绍一下OOP。

### Java特性

#### 1. 封装

**封装对象的属性和方法，对外仅公开接口。**

优点：避免对象内部被更改，提高类的可用性

原则：属性私有，设置 getter/setter

问题：什么是封装？封装的原则是什么？哪它有什么优点呢？

#### 2. 继承

**子类获取到父类的所有属性和方法。**

优点：继承能够复用旧代码，减少不必要的代码量。

**子类能否继承父类的私有属性方法？** 

（能，子类继承了父类的所有属性和方法，但是private属性和方法，子类没有权限调用而已）

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 **向上转型** 。

```java
Animal animal = new Cat();
```

#### 3. 多态

多态分为编译时多态和运行时多态:

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件:

- 继承
- 覆盖(重写)
- 向上转型

**重载和重写的区别？**

问题：Java的三大特性是什么？

### 类图

UML类图：继承是实线；实线是虚线。

#### 泛化关系 (Generalization)

用来描述继承关系，在 Java 中使用 extends 关键字。

![img](https://www.pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png)

```java
@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical <|-- Car
Vihical <|-- Trunck

@enduml
```

#### 实现关系 (Realization)

用来实现一个接口，在 Java 中使用 implement 关键字。

![img](https://www.pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png)

```java
@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior <|.. Fly
MoveBehavior <|.. Run

@enduml
```

#### 聚合关系 (Aggregation)

表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。

![img](https://www.pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png)

```java
@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@enduml
```

####  组合关系 (Composition)

和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。

![img](https://www.pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png)

```java
@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@enduml
```

#### 关联关系 (Association)

表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。

```java
@startuml

title Association

class School
class Student

School "1" - "n" Student

@enduml
```

#### 依赖关系 (Dependency)

和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:

- A 类是 B 类中的(某中方法的)局部变量；
- A 类是 B 类方法当中的一个参数；
- A 类向 B 类发送消息，从而影响 B 类发生变化；

![img](https://www.pdai.tech/_images/pics/LOun2W9134NxVugmbJPp15d4LalxC4O.png)

```java
@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note "MoveBehavior.move()" as N

Vihicle ..> MoveBehavior

Vihicle .. N

@enduml
```





### 类

类就是对象

#### 1. 变量（属性）

变量按照在类中声明的位置分类

* 成员变量
  * 类变量（静态变量）：所有实例公用一个类变量。
  * 实例变量
* 局部变量

```java
public class test {
	public static int a = 0;	// 类变量（静态变量）
    public String nameString;	// 实例变量
	
	public void test() {
		int temp = 1;		// 局部变量
		System.out.println(temp);
	}
}
```

|          |      静态变量      |    实例变量    |           局部变量           |
| :------: | :----------------: | :------------: | :--------------------------: |
| 定义位置 |   在类中，方法外   | 在类中，方法外 | 方法中，或者是方法的形式参数 |
| 调用方式 | 对象调用、类名调用 |    对象调用    |              -               |
| 存储位置 |       方法区       |       堆       |              栈              |
| 生命周期 |     与类共存亡     |  与对象共存亡  |         与方法共存亡         |

问题：变量的存储位置和生命周期？

#### 2. 方法

```java
权限修饰符 返回值类型 方法名 (参数类型 参数名) {
    方法体;
    return 返回值;
}
```

#### 3. 权限修饰符

​	外部类
​		public
​			同一个项目可见
​		不加权限修饰符
​			package-private（仅同一个包下的类可见）
​	内部类、属性、方法
​		public
​			同一个项目可见
​		不加权限修饰符
​			等同于protected
​				package-private（仅同一个包下的类可见）
​		private
​			仅本类可见

问题：权限修饰符的区别？

#### 4. this

当前类的引用。

#### 5. 构造器

作用：实例化一个对象，初始化对象的属性。

一个类至少有一个构造器。

分为无参构造器和有参构造器。

如果类没有定义构造器，则系统会自动创建一个无参构造器。如果定义了构造器（无参和有参都可以），则系统不会自动创建无参构造器。

```java
public class Student {

	private int age;
	private String name;
	
    // 无参构造器
	public Student() {
	}
	
    // 有参构造器
	public Student(int age, String name) {
		this.age = age;
		this.name = name;
	}
	
	public Student getStudent() {
		return this;	// 返回Student对象
	}
	
	public static void main(String[] args) {
		Student student = new Student();
		System.out.println(student.age + " " + student.name);
	}
}
```

#### 6. 主方法

```java
public static void main(String[] args){
    // 方法体
}
```

### 对象

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210530194140688.png" alt="image-20210530194140688" style="zoom: 67%;" />



### 创建对象的方式

https://www.cnblogs.com/wxd0108/p/5685817.html

#### new

#### 反射

#### 反序列化

#### clone()

#### 动态代理

1. new

```java
Student student1 = new Student();
```

2. Class类的newInstance方法

反射

```java
Student student2 = Student.class.newInstance();
```

3. Constructor类的newInstance方法

反射

```java
Constructor<Student> constructor = Student.class.getConstructor();
Student student3 = constructor.newInstance();
```

4. clone()方法

要使用clone方法，我们需要先实现**Cloneable**接口并实现其定义的clone方法。

```java
Student student4 = (Student) student3.clone();
```

5. 反序列化

为了反序列化一个对象，我们需要让我们的类实现**Serializable**接口。

```java
ObjectInputStream in = new ObjectInputStream(new FileInputStream("test.txt"));
Student student5 = (Student) in.readObject();
```

### **Object 通用方法**

```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

#### equals()

##### 1. 与 null 比较

与 null 的比较，对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false

```java
x.equals(null); 	// false;
```

##### 2. equals() 和 == 的区别

1. 对于 == ，如果比较的是基本数据类型，那么直接比较值；如果比较的是引用类型，比较的是对象的地址。
2. 对于 equals()，不能用于比较基本数据类型。比较引用类型，如果没有对 equals() 方法进行重写，比较的是对象的地址；如果对equals() 方法进行重写（比如 String、Date），比较的是对象的值。

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); 	// true
System.out.println(x == y);     	// false
```

##### 3. equals() 和 hashCode() 重写

* 判断：两个对象的地址是否相同
* 判断：两个对象是否是同一个类
* 判断：两个对象内部的值是否相同

```java
public class Person {

    private String name;
    private int age;

    public Person() { }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

```java
public static int hash(Object... values) {
    return Arrays.hashCode(values);
}
```

```java
public static int hashCode(Object a[]) {
    if (a == null)
        return 0;

    int result = 1;

    for (Object element : a)
        result = 31 * result + (element == null ? 0 : element.hashCode());

    return result;
}
```

String.hashCode()

```java
public int hashCode() {
    int h = hash;		// Default to 0
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

Integer.hashCode()

```java
public static int hashCode(int value) {
    return value;
}
```

Double.hashCode()

```java
@Override
public int hashCode() {
    return Double.hashCode(value);
}

public static int hashCode(double value) {
    long bits = doubleToLongBits(value);
    return (int)(bits ^ (bits >>> 32));
}

public static long doubleToLongBits(double value) {
    long result = doubleToRawLongBits(value);
    // Check for NaN based on values of bit fields, maximum
    // exponent and nonzero significand.
    if ( ((result & DoubleConsts.EXP_BIT_MASK) ==
          DoubleConsts.EXP_BIT_MASK) &&
        (result & DoubleConsts.SIGNIF_BIT_MASK) != 0L)
        result = 0x7ff8000000000000L;
    return result;
}
```

#### hashCode()

##### 1. hash值的随机性

等价的两个对象 hash值 一定相同，但是 hash值 相同的两个对象不一定等价。这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

##### 2. equals() 和 hashCode() 的区别

* equals() 没有重写的话，就是是用来比较两个对象的值是否相等

* hashCode() 返回哈希值

##### 3. equals() 和 hashCode() 的源码

equals() 源码：

```java
public boolean equals(Object obj) {
    return (this == obj);			// 比较地址是否相等
}
```

hashCode() 源码：

```java
public native int hashCode();		// 返回hash值
```

##### 4. hashCode() 重写

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210919144334.png" alt="image-20210919144333962" style="zoom: 50%;" />

```java
@Override
public int hashCode() {
    return 31 * (31 * 17 + x) + y;
}
```

#### toString()

默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。

```java
public class ToStringExample {

    private int num;

    public ToStringExample(int num) {
        this.num = num;
    }
}
```

```java
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());		// 输出: ToStringExample@4554617c
```

#### clone()

对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现对象属性的拷贝。

**1. cloneable**

clone() 是 Object 的 protected 方法，一个类需要**重写 clone()**，并**实现 Cloneable 接口**，**其它类才能调用该类实例的 clone() 方法**。

```java
public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();	// 浅拷贝
    }
}
```

```java
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
```

**2. 浅拷贝**

拷贝对象和原始对象的引用类型 引用的是同一个对象。

**3. 深拷贝**

拷贝对象和原始对象的引用类型 引用的不是同一个对象。

**4. clone() 的替代方案**

使用**拷贝构造函数**或者**拷贝工厂**来拷贝一个对象。

### JavaBean

JavaBean的规则：

* 类是 public
* 有一个 public 的 无参构造器
* 实例变量是 private
* 提供 getter/setter

## 八、封装，继承，多态

### 1. 封装

封装对象的属性和方法，对外仅公开接口。

优点：避免对象内部被更改，提高类的可用性

原则：属性私有，设置 getter/setter

问题：什么是封装？封装的原则是什么？哪它有什么优点呢？

### 2. 继承

子类获取到父类的所有属性和方法。

**子类能否继承父类的私有属性方法？** 

（不能，也可以说能，子类继承了父类的所有属性和方法，但是private属性和方法，子类不能直接调用而已）

继承有两种实现方式：抽象类（abstract）和 接口（interface）。

#### 抽象类与接口

##### 1. 抽象类 abstract

抽象类和抽象方法都使用 **abstract** 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

抽象类和普通类的区别：抽象类不能被实例化，只能被继承（**extends**）。

```java
public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println("func2");
    }
}
```

```java
public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
public static void main(String[] args) {
    // AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
    AbstractClassExample ac2 = new AbstractExtendClassExample();
    ac2.func1();
}
```

##### 2. 接口 interface

接口的字段默认都是 static 和 final 的。

类使用 **implements** 实现接口。

```java
public interface InterfaceExample {

    void func1();

    default void func2(){
        System.out.println("func2");
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
```

```java
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

##### 3. 抽象类和接口的区别

| 语法维度 |       抽象类       |                             接口                             |
| :------: | :----------------: | :----------------------------------------------------------: |
|   关系   |        IS-A        |                            LIKE-A                            |
| 构造方法 |     有构造方法     |                         没有构造方法                         |
| 成员变量 |    没有特殊要求    |               默认是 public static final 常量                |
|   方法   |    没有特殊要求    | 默认是 public abstract，JDK 8 支持 static，JDK 9 支持 private |
|   继承   | 只能继承一个抽象类 |                       可以实现多个接口                       |

- 抽象类是 IS-A 关系，子类对象必须能够替换掉所有父类对象。而接口是 LIKE-A 关系，它只是提供一种方法实现契约。
- 抽象类可以有构造方法，接口没有构造方法。
- 接口的**成员变量** 默认是 public static final 常量。
- 接口的**方法**默认是 **public abstract**  的，JDK 8 支持 static，JDK 9 支持 private。
- 一个类只能继承一个抽象类，但可以实现多个接口。

最好使用接口！

#### super

super代表父类的引用。super可以使用父类的方法和变量。子类构造器中会默认有 super() 存在（默认隐藏，父类构造器），显式使用的话，super() 必须放在第一行。

```java
super.方法();
super.变量;
```

##### this与super的区别

|   区别   |           this           |           super           |
| :------: | :----------------------: | :-----------------------: |
| 引用对象 |       当前类的引用       |        父类的引用         |
|   继承   |        不需要继承        |   需要继承，需要有父类    |
| 构造函数 | this(); 是本类的构造函数 | super(); 是父类的构造函数 |

相同点：super() 和 this() 都必须放在构造器内的第一行

构造器：

- **super(参数)**：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
- **this(参数)**：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

```java
class Person { 
    public static void prt(String s) { 
       System.out.println(s); 
    } 
   
    Person() { 
       prt("父类·无参数构造方法： "+"A Person."); 
    }//构造方法(1) 
    
    Person(String name) { 
       prt("父类·含一个参数的构造方法： "+"A person's name is " + name); 
    }//构造方法(2) 
} 
    
public class Chinese extends Person { 
    Chinese() { 
       super(); // 调用父类构造方法（1） 
       prt("子类·调用父类"无参数构造方法"： "+"A chinese coder."); 
    } 
    
    Chinese(String name) { 
       super(name);// 调用父类具有相同形参的构造方法（2） 
       prt("子类·调用父类"含一个参数的构造方法"： "+"his name is " + name); 
    } 
    
    Chinese(String name, int age) { 
       this(name);// 调用具有相同形参的构造方法（3） 
       prt("子类：调用子类具有相同形参的构造方法：his age is " + age); 
    } 
    
    public static void main(String[] args) { 
       Chinese cn = new Chinese(); 
       cn = new Chinese("codersai"); 
       cn = new Chinese("codersai", 18); 
    } 
}
```

#### 初始化顺序

存在继承的情况下，代码执行的顺序为：

- 父类（static变量、static语句块）
- 子类（static变量、static语句块）
- 父类（实例变量、普通语句块）
- 父类（构造方法）
- 子类（实例变量、普通语句块）
- 子类（构造方法）

### 3. 多态

定义：一个方法有多种实现方式，重写（override）和 重载（overload）可以实现多态。

#### 对象类型的转换

##### 向上转型

子类对象实例化为父类对象。

定义格式：

```java
父类类型 变量名 = new 子类类型();
Person person = new Student();
```

##### 向下转型

父类对象实例化为子类对象。

必须使用显示类型转换，不然会报错。

```java
子类类型 子类变量名 = (子类类型) 父类变量名;

Person person = new Student();
Student student = (Student) person;			// person指向子类Student

// Person person = new Person();		
// Student student = (Student) person;		// 出错，person指向Person

// Person person = new Man();
// Woman woman = (Woman) person;			// 出错
```

#### instanceof

用于判断实例对象是否属于一个类。为了保证强制类型转换不出现异常，可以使用instanceof判断。

```java
实例对象 instanceof 类;

A a = null;
System.out.println(a instanceof A);			// 输出true

// 如果B是A的父类，则 (a instanceof B) 也输出true
System.out.println(a instanceof B);			// 输出true
```

#### 重写与重载

##### 1. 重写 Override

定义：子类声明一个与父类完全相同的方法。

规则：

- 子类方法的**访问权限**（限定修饰符）必须大于等于父类方法；
- 子类方法的**返回类型**必须是父类方法返回类型或为其子类型；
- 子类方法抛出的**异常类型**必须是父类抛出异常类型或为其子类型。

使用 **@Override** 注解，让编译器检查代码是否满足上面的三个规则。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。

- 子类的返回类型为 ArrayList\<Integer>，是父类返回类型 List\<Integer> 的子类。

- 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。

```java
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

##### 2. 重载 Overload

定义：在同一个类中，声明一个已经存在的方法，但是 **参数、返回类型** 至少有一个不同。

应该注意的是，返回值不同，其它都相同不算是重载。

```java
class OverloadingExample {
    public void show(int x) {
        System.out.println(x);
    }

    public void show(int x, String y) {
        System.out.println(x + " " + y);
    }
}
```

```java
public static void main(String[] args) {
    OverloadingExample example = new OverloadingExample();
    example.show(1);
    example.show(1, "2");
}
```

#### 重写和重载的区别

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210530185436890.png" alt="image-20210530185436890" style="zoom: 33%;" />

1. 重写（override）
   * 子类声明一个与父类完全相同的方法
   * 子类方法的**访问权限**（限定修饰符）必须大于等于父类方法；
   * 子类方法的**返回类型**必须是父类方法返回类型或为其子类型；
   * 子类方法抛出的**异常类型**必须是父类抛出异常类型或为其子类型；
   * 在运行时，才能确定调用的方法。
2. 重载（overload）
   * 在同一个类中，声明一个已经存在的方法，但是**参数类型、个数**至少有一个不同。
   * 在编译时，已经确定好了调用的方法。

#### 重写式多态

也叫运行时多态。这种多态通过动态绑定实现，只有程序运行起来，你才知道调用的是哪个子类的方法。

三个必要条件：

* 继承（抽象类、接口）
* 重写
* 向上转型，父类实例变量的引用指向子类对象（栈➡堆）

##### 重写式多态的特点

1. 多态成员变量：编译运行看左边

```java
Person person = new Student();
System.out.println(person.name); 		// person是Person中的值，只能取到父类中的值
```

   2.多态成员方法：编译看左边，运行看右边

```java
Person person = new Student();
System.out.println(person.getName());	// person门面类型是Person，但实际类型是Student，所以调用的是重写后的方法
```

总结：变量是父类，方法是子类。

##### 虚拟方法

也称为虚方法，是重写式多态的体现。

定义：编译的时候，调用父类的方法；运行的时候，执行子类重写父类的方法。

##### 动态绑定

定义：在运行时根据具体对象的类型进行绑定，也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。

#### 重载式多态

也叫编译时多态。这种多态通过静态绑定实现，即这种多态在编译时已经确定好要调用的方法。

问题：重写式多态是编译时行为还是运行时行为？                                                                                （是运行时行为）

## 九、异常

Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： **Error** 和 **Exception**。

其中 Error 是 JVM 无法处理的错误。

Exception 分为两种：

- **编译时异常**（非运行时异常、检查性异常）：可以用 **try...catch...finall...**语句 **捕获异常**并**处理异常**，程序可以从异常中**恢复**；
- **运行时异常**（非检查性异常）：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210531220316437.png" alt="image-20210531220316437" style="zoom:80%;" />

throws + 异常名称：用于抛出异常。父类抛出异常的范围一定要大于等于子类抛出异常的范围。（类似于甩锅）。

-------------

手动抛出异常：

```java
throw new Exception("异常！");
```

自定义异常：

```java
public class MyException extends RuntimeException{
    
    static final long serialVersionUID = -15616516515485465L;	// 随便输的
    
    public MyException() {}
    
    public MyException(String msg) {
        super(msg);
    }
}
```

---

Java 7 的 try-with-resource 语法

类实现 **AutoCloseable** 接口，当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。



异常进行文档说明

当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。

在 **Javadoc** 添加 **@throws** 声明，并且描述抛出异常的场景。

```java
/**
* Method description
* 
* @throws MyBusinessException - businuess exception description
*/
public void doSomething(String input) throws MyBusinessException {
   // ...
}
```













问题：异常需要继承哪个类？                                            （Throwable）

问题：异常的分类？                                                           （异常 分为 Error 和 Exception，Exception 又分为 编译时异常 和  运行时异常）

问题：Error 举例？

问题：Exception 举例？

问题：开发中如何选择使用 try-catch-finally 还是 throws + 异常名称？

1.  父类没有 throws，则子类只能用 try-catch-finally
2. 在方法A中，会先后执行几个另外的方法，这几个方法是递进关系，这几个方法建议使用throws，而方法A建议使用try-catch-finally

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210531225543643.png" alt="image-20210531225543643" style="zoom: 50%;" />

问题：throw 与 throws 的区别？  

* throw 在方法体内部，用于抛出异常；throws 用于声明方法可能要抛出的异常。

```java
public void MyMethod1() {
    throw new Exception("异常！");
}

public void MyMethod2() throws Exception{
    
}
```

**final、finally、finalize() 的区别**

**1. final**

* 常量使用 final 关键字，一旦被赋值了，就不能再被更改了
* final 声明方法不能被子类重写
* final 声明类不允许被继承

**2. finally**

跟在 try-catch 后面，无论异常是否发生，都会执行 finally 里的代码。finally 里主要实现资源的释放（如 关闭 数据库连接 和 Socket，）

**3. finalize()**

finalize() 在垃圾回收器回收对象之前调用，可以让对象重新被引用。但只能使用一次。

## 十、反射

反射机制，使得 Java语言 拥有了动态语言的属性。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210604093857372.png" alt="image-20210604093857372" style="zoom: 80%;" />



## 十一、枚举类与注解

### 枚举类 Enum

定义：类中的对象个数是有限个。

若枚举类只有一个对象，则可以作为单例模式的实现方式。

枚举类实现接口，需要重写接口。接口可由枚举类的对象重写，也可以由类重写。

枚举类的方法：类名称.values();   类名称.valueOf("对象名");

```java
// 这是一般的创建方法
public enum Color { 
	RED, GREEN, BLUE; 
}
```

```java
public class test {

    public interface Info {
        void show();
    }
    
	// 枚举类实现接口，重写接口。接口可由枚举类的对象重写，可以由类重写。
    public enum Student implements Info {
        YIFANG(1, "yifang"){
            @Override
            public void show() {
                System.out.println("调用yifang");
            }
        },
        MIKASA(2, "Mikasa"){
            @Override
            public void show() {
                System.out.println("调用Mikasa");
            }
        };

        int id;
        String name;

        Student(int id, String name) {
            this.id = id;
            this.name = name;
        }
        
        // getter/setter
        
        @Override
        public void show() {
            System.out.println("");
        }
    }

    public static void main( String[] args )
    {
        System.out.println(Student.YIFANG);				// 输出：YIFANG
        
        Student[] values = Student.values();			
        System.out.println(Arrays.toString(values));	// 输出：[YIFANG, MIKASA]
        
        Student yifang = Student.valueOf("YIFANG"); // 输入对象名，返回这个对象；没有这个对象名，会报错
        System.out.println(yifang); 	// 输出：YIFANG
        
        values[0].show();				// 输出：调用yifang
    }
}
```

#### Enum的方法

```java
类名称.values();			// 返回类的数组			
Student[] values = Student.values();

类名称.valueOf("对象名");		// 输入对象名，返回这个对象
Student.valueOf("YIFANG")
```

问题：什么是枚举类？枚举类的关键字是什么？枚举类的接口实现？枚举类的方法？

### 注解 Annotation

注解的原理：待更新。

框架 = 注解 + 反射 + 设计模式

#### 1. 文档注解

```java
/**
 * @BelongsProject: test1
 * @BelongsPackage: com.yifang
 * @Author: xuyifang
 * @CreateTime: 2021-06-01 12:59
 * @Description:
 */
```

#### 2. 方法相关的注解

```java
/**
 * @param o
 * @return
 * @throws Exception
 */
```

#### 3. JDK 内置注解

|   JDK 内置注解    |       说明       |
| :---------------: | :--------------: |
|     @Override     | 子类重写父类方法 |
|    @Deprecated    |  类、方法已过时  |
| @SuppressWarnings |  去除编译器警告  |

#### 4. 自定义注解

* 注解声明：使用 @interface
* 内部成员：通常使用 String value();
* 指定成员默认值：default
* 如果自定义注解没有成员，那这个注解起到标识作用

```java
public @interface MyAnnotation {
    String value() default "hello";
}
```

```java
@MyAnnotation(value = "hi")
public static void main( String[] args ) {
	// 方法体
}
```

#### 5. JDK 元注解

JDK 的元注解用于修饰其他注解。

| JDK 元注解  |                    说明                     |
| :---------: | :-----------------------------------------: |
| @Retention  |          用于指定该注解的生命周期           |
|   @Target   |       指定被修饰的注解能修饰哪些元素        |
| @Documented | 被它修饰的注解在被 javadoc 解析时，保留下来 |
| @Inherited  |         被它修饰的注解 将具有继承性         |

**@Retention()**：有三个参数，SOURCE，CLASS，RUNTIME。

* SOURCE：源文件中有效，编译器直接丢弃这种注解。
* CLASS：class文件中有效，运行Java程序时，JVM 不会保留注解。是 @Retention() 的默认值。
* RUNTIME：运行时有效，运行Java程序时，JVM 会保留注解。程序可通过反射获取该注释。

**@Target()**：TYPE，FIELD（字段），METHOD，PARAMETER，CONSTRUCTOR，LOCAL_VARIABLE，ANNOTATION_TYPE，PACKAGE，TYPE_PARAMETER，TYPE_USE。见注解类型。

#### 6. JDK8 引入的注解

**可重复注解**

```java
@Repeatable()
```

**注解类型**

```java
public enum ElementType { 
/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/ 
　　TYPE,

/** 标明该注解可以用于字段(域)声明，包括enum实例 */ 
　　FIELD, 

/** 标明该注解可以用于方法声明 */ 
　　METHOD, 

/** 标明该注解可以用于参数声明 */ 
　　PARAMETER, 

/** 标明注解可以用于构造函数声明 */ 
　　CONSTRUCTOR, 

/** 标明注解可以用于局部变量声明 */ 
　　LOCAL_VARIABLE, 

/** 标明注解可以用于注解声明(应用于另一个注解上)*/ 
　　ANNOTATION_TYPE, 

/** 标明注解可以用于包声明 */ 
　　PACKAGE, 

/** * 标明注解可以用于类型参数声明（1.8新加入） * @since 1.8 */ 
　　TYPE_PARAMETER, 

/** * 类型使用声明（1.8新加入) * @since 1.8 */ 
　　TYPE_USE 
}
```

问题：什么是元注解？说说 @Retention 和 @Target 的作用？

## 十二、泛型

### 泛型基础

问题：为什么会使用泛型？（泛型的优点？）

1. 避免 类型不安全（比如所有类型都可以添加到集合中）
2. 避免 强转时，会出现 ClassCastException

泛型的定义：**参数化类型**，就是**将具体的类型参数化**，**在使用时传入具体的类型**。

一些规则：

1. 泛型只能是引用数据类型，不能是基本数据类型。

2. T、E、K、V等形式的参数常用于表示泛型形参。

3. 实例化的时候，没有指明泛型的类型，则默认是 java.lang.Object 类型。

4. 泛型不同的引用不能相互赋值

```java
public void test() {
    ArrayList<String> list1 = null;
    ArrayList<Integer> list2 = null;

    // list1 = list2;       // 错误，泛型不同的引用不能相互赋值
}
```

5. 异常类不能是泛型

6. 不能使用 new T[]，但是可以使用 T[] t = (T[]) new Object[10];

```java
// T t = new T;		报错
T t = (T) new Object();

// T[] t = new T[];		报错
T[] t = (T[]) new Object[10];
```

### 泛型使用

* 泛型类
* 泛型接口
* 泛型方法

#### 1. 泛型类

```java
 // T stands for "Type"
public class GenericClass <T> {
    
    private T t;
    
	public GenericClass(T t) {
        this.t = t;
    }
    
    public T getT() { return t; }			// getter
    public void setT(T t) { this.t = t; }	// setter
}
```

#### 2. 泛型接口

```java
public interface Generator <T> {
    public T next();
}
```

#### 3. 泛型方法

```java
/**
 * 泛型方法的基本介绍
 * @param tClass 传入的泛型实参
 * @return T 返回值为T类型
 * 说明：
 *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。
 *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 */
public <T> T genericMethod(Class<T> t) throws InstantiationException, IllegalAccessException {
	T instance = t.newInstance();
	return instance;
}
```

在静态方法中不能使用类的泛型，因为静态方法最先初始化。除非静态方法自己也定义为泛型方法。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210603150249377.png" alt="image-20210603150249377" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210603155903485.png" alt="image-20210603155903485" style="zoom:80%;" />

### 类型擦除

定义：编译器在编译时去掉了泛型的所有类型信息。（ Integer 和 String 就是类型信息）

Eg：可以看到 `ArrayList<Integer>` 和`ArrayList<String>` 的原始类型是相同，在编译成字节码文件后都会变成`ArrayList`，JVM 看到的只有 `List` ，看不到泛型的类型，这就是泛型的类型擦除。

```java
ArrayList<String> list1 = new ArrayList<>();
ArrayList<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass());		// 输出：true
```

问题：Java的泛型是如何工作的 ? 什么是类型擦除 ?

* 泛型是通过**类型擦除**来实现的，编译器在编译时去掉了泛型的所有类型信息，所以在运行时不存在任何类型信息。例如List\<String>在运行时仅用一个List来表示。

问题：既然存在类型擦除，那么Java是如何保证在`ArrayList<integer>`添加字符串会报错呢？

* 编译器会先检查代码中泛型的类型信息，然后进行类型擦除，最后再进行编译。

问题：泛型有哪些使用场景？

* DAO层，增删改查

### 泛型继承

放弃

### 泛型通配符

什么时候使用？

* 当类型不确定的时候，**?** 通配符代表 **任意类型**。

Tips：**？**是类型实参，而不是类型形参。

Eg：A 是 B 的父类，G\<A> 和 G\<B> 是没有关系的，二者共同的父类是 G<?>

```java
List<Object> list1 = null;
List<String> list2 = null;

List<?> list = null;
list = list1;           // 不报错

// list1 = list2;          //  报错
```

#### 上界通配符

**<? extends T>**

表示 传入的类型 是 T类型 或 T的子类。

#### 下界通配符

**<? super T>**

表示 传入的类型 是 T类型 或 T的父类。

---

问题：什么是泛型中的限定通配符和非限定通配符 ?

* 限定通配符是上界通配符和下界通配符
* 非限定通配符是\<?>，\<?> 代表 **任意类型**

问题：List<? extends T> 和 List <? super T> 之间有什么区别 ?

* List<? extends T> 可以是 T类型 或 T的子类 的 List。
* List<? super T> 可以是 T类型 或 T的父类 的 List。比如 List<? extends Number> 可以是 List\<Integer> 或 List\<Float>。

问题：编写一个泛型方法，让它能接受泛型参数并返回泛型类型。

```java
public <T> T genericMethod(Class<T> tClass) {
	T t = tClass.newInstance();
	return t;
}
```

问题：编写一段泛型程序来实现LRU缓存？

问题：你可以把 List\<String> 传递给一个接受 List\<Object> 参数的方法吗？                   （不行，会报错，泛型不同的引用不能相互赋值）

```java
List<String> list1 = null;
List<Object> list2 = null;

// list2 = list1;			// 报错
```

问题：Array中可以用泛型吗？                                                         （不可以，Effective Java一书中建议使用 List 来代替 Array）

---

#### List，List\<Object>，List<?>之间的区别

* List：没有限定。
* List\<Object>：用法与List一样，但是在**接受其他泛型赋值时**会出现编译错误。
* List<?>：是一个**泛型**，在没有赋值前，可以接受任何类型的集合赋值，但赋值之后不能往里面随便添加元素，但可以remove和clear。

## 十三、IO流

### 1.  输入流

```java
import java.util.*;
Scanner scanner = new Scanner(System.in);
if (scanner.hasNext()) {
    String str = scanner.next();
    System.out.println("输出的内容" + str);
}
scanner.close();   // IO流如果不关闭的话，会一直占用资源
```

* scanner.hasNext()，读取输入的下一个单词，识别空格，以空格作为分割
* scanner.hasNextLine()，读取输入的下一行，识别回车，以回车作为分割

### 2. Scanner API

```java
import java.util.*;
java.util.Scanner
Scanner(InputStream in)			// 用给定的输入流创建一个Scanner对象
String next()
String nextLine()
int nextInt()
Double nextDouble()
boolean hasNext()				// 检测输入中是否还有其他单词
boolean hasInt()
boolean nextDouble()
```

### 3. 输出流

```java
System.out.println("这是输出流！")
```

### 4. 文件读写 API

```java
import java.io.*;

// 文件读取
BufferedReader br = new BufferedReader(new FileReader("test.txt"));
String str;
while ((str = br.readLine()) != null) {
	System.out.println(str);
}
System.out.println(str);

// 文件写入
BufferedWriter bw = new BufferedWriter(new FileWriter("test.txt"));
bw.write("Freedom is not free!");
bw.close();
System.out.println("文件创建成功！");
```

## 十四、特性



## 一些问题

1. JDK、JRE、JVM的区别？
2. Open JDK 和 普通JDK 的区别？                                                                                                                      （Open JDK 是 开源的 JDK）
3. 讲讲命名规范？类、方法、变量、常量
4. Java的注释有哪几种？
5. 基本数据类型有哪几种？                                                                                                                                                     （八大数据类型）
6. 引用数据类型是什么？
7. 按照在类中声明的位置分类，变量可分为哪几种？
8. 这几种变量在 JVM 中的存储位置和生命周期？
9. 常量如何定义？字面量又是什么？
10. Java 的 Math API 知道哪些？
11. Java 的 String API 知道哪些？
12. 介绍一下 String，以及 String 的内部结构？
13. String 不可变的优点？（String 为什么要设置为不可变？）
14. String, StringBuffer and StringBuilder 的区别？
15. String Pool 的位置演进？（String Pool 在哪？）
16. String Pool 的优缺点？
17. 讲一讲 Java 中创建 String 的三种方式？
18. String s = new String("a");   创建了几个对象？分别在哪？
19. String中的+号拼接低层是什么样的？                                    （str = str + “a”; 就是 new StringBuilder().append(str).append("a");   ）
20. StringBuilder 的 append 比 String 中的 +号拼接更慢吗？ （ +号拼接的效率并不比append慢，只是+号不能用在循环结构里面 ）
21. 项目如何实现用户唯一性检验？                                             （给每一位用户生成独特的UID，常用Snowflake算法）

