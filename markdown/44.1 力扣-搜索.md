[toc]

# 小岛问题

小岛问题的：

* 时间复杂度：$O(MN)$
* 空间复杂度：$O(MN)$，如果算栈的递归空间。

```java
// 四连通
int[][] dirs = {
    {-1, 0}, {1, 0},    // 上下
    {0, -1}, {0 , 1}    // 左右
};

// 八连通
int[][] dirs = {
    {-1, -1}, {-1, 0}, {-1, 1},     
    {0, -1},           {0, 1},      
    {1, -1}, {1, 0}, {1, 1}       
};
```

### [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902214712.png" alt="image-20210827005706020" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827010812.png" alt="image-20210827010812527" style="zoom:50%;" />

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},    // 上下
        {0, -1}, {0 , 1}    // 左右
    };

    int[][] mat;
    int M;
    int N;

    public int[][] floodFill(int[][] mat, int sr, int sc, int newColor) {
        this.mat = mat;
        this.M = mat.length;
        this.N = mat[0].length;

        int oldColor = mat[sr][sc];
        if (oldColor == newColor) {
            return mat;
        }

        dfs(sr, sc, oldColor, newColor);
        return mat;
    }

    private void dfs(int x, int y, int oldColor, int newColor) {
        if (x < 0 || x >= M) {
            return;
        }
        if (y < 0 || y >= N) {
            return;
        }

        if (mat[x][y] == oldColor) {
            mat[x][y] = newColor;
            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                dfs(nextX, nextY, oldColor, newColor);
            }
        }
    }
}
```

### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827011904.png" alt="image-20210827011904652" style="zoom:80%;" />

思路：小岛问题 + DFS。每个访问过的土地设置为 0。

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},    // 上下
        {0, -1}, {0 , 1}    // 左右
    };

    int[][] mat;
    int M;
    int N;

    public int maxAreaOfIsland(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        int max = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                int res = dfs(x, y);
                max = Math.max(max, res);
            }
        }
        return max;
    }

    private int dfs(int x, int y) {
        if (x < 0 || x >= M) {
            return 0;
        }
        if (y < 0 || y >= N) {
            return 0;
        }

        int count = 0;
        if (mat[x][y] == 1) {
            mat[x][y] = 0;
            count++;
            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                count += dfs(nextX, nextY);
            }
        }
        return count;
    }
}
```

### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827013145.png" alt="image-20210827013145187" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827013200.png" alt="image-20210827013200124" style="zoom:80%;" />

思路：在 [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/) 的基础上，找连通分量的个数。

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},    // 上下
        {0, -1}, {0 , 1}    // 左右
    };

    char[][] mat;
    int M;
    int N;

    public int numIslands(char[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        int count = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == '1') {
                    dfs(x, y);
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(int x, int y) {
        if (x < 0 || x >= M) {
            return;
        }
        if (y < 0 || y >= N) {
            return;
        }

        if (mat[x][y] == '1') {
            mat[x][y] = '0';
            for (int[] dir : dirs) {
                dfs(x + dir[0], y + dir[1]);
            }
        }
    }
}
```

### [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827021847.png" alt="image-20210827021847137" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827021905.png" alt="image-20210827021905115" style="zoom:80%;" />

思路：越界 + 1，遇到海水 + 1，遇到陆地置为 2，并DFS上下左右。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827023330.png" alt="image-20210827023329989" style="zoom: 67%;" />

```java
class Solution {
    int[][] dirs = {
            {-1, 0}, {1, 0},    // 上下
            {0, -1}, {0 , 1}    // 左右
    };

    int[][] mat;
    int M;
    int N;

    public int islandPerimeter(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    return dfs(x, y);       // 只有一个岛屿
                }
            }
        }
        return 0;
    }

    private int dfs(int x, int y) {
        if (x < 0 || x >= M || y < 0 || y >= N) {
            return 1;
        }
        if (mat[x][y] == 0) {
            return 1;
        }

        int count = 0;
        if (mat[x][y] == 1) {
            mat[x][y] = 2;
            for (int[] dir : dirs) {
                count += dfs(x + dir[0], y + dir[1]);
            }
        }
        return count;
    }
}
```

### [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827033405.png" alt="image-20210827033405759" style="zoom:80%;" />

思路： 对网格做两遍 DFS。

* 第一遍 DFS 遍历陆地格子，计算每个岛屿的面积并标记岛屿，从 2 开始标记。
* 第二遍 DFS 遍历海洋格子，观察每个海洋格子相邻的岛屿格子。

模拟过程：

0是海洋1是岛屿

<img src="https://pic.leetcode-cn.com/1608107427-fMJpJb-image.png" alt="image.png" style="zoom: 80%;" />

0是海洋，2，3，4，5，6是岛屿的序号

<img src="https://pic.leetcode-cn.com/1608107387-eQulJI-image.png" alt="image.png" style="zoom: 80%;" />

0是海洋，其他数字是岛屿的面积

<img src="https://pic.leetcode-cn.com/1608107447-sJPEQW-image.png" alt="image.png" style="zoom: 80%;" />

岛屿序号和面积的对应关系：

<img src="https://pic.leetcode-cn.com/1608107514-SqiEkB-image.png" alt="image.png" style="zoom:80%;" />

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},    // 上下
        {0, -1}, {0 , 1}    // 左右
    };

    int[][] mat;
    int M;
    int N;

    public int largestIsland(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        int res = 0;
        int index = 2;
        Map<Integer, Integer> indexAndAreas = new HashMap<>();
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    int area = getArea(x, y, index);
                    indexAndAreas.put(index, area);
                    index++;
                    res = Math.max(res, area);
                }
            }
        }
        if (res == 0) {
            return 1;
        }

        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 0) {       //遍历海洋格子
                    Set<Integer> set = findNeighbour(x, y);
                    if (!set.isEmpty()) {
                        int twoIsland = 1;
                        for (int i : set) twoIsland += indexAndAreas.get(i);
                        res = Math.max(res, twoIsland);
                    }
                }
            }
        }
        return res;
    }

    private HashSet<Integer> findNeighbour(int x, int y) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int dir[] : dirs) {
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            if (inArea(nextX, nextY) && mat[nextX][nextY] != 0) {
                hashSet.add(mat[nextX][nextY]);
            }
        }
        return hashSet;
    }

    private int getArea(int x, int y, int index) {
        if (!inArea(x, y)) {
            return 0;
        }

        int count = 0;
        if (mat[x][y] == 1) {
            mat[x][y] = index;
            count++;
            for (int[] dir : dirs) {
                count += getArea(x + dir[0], y + dir[1], index);
            }
        }
        return count;
    }

    private boolean inArea(int x, int y) {
        return 0 <= x && x < M && 0 <= y && y < N;
    }
}
```

### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827015204.png" alt="image-20210827015204017" style="zoom:80%;" />

思路：对所有边界做DFS，如果边界是陆地，则DFS相邻的陆地。最后矩阵中剩下的就是飞地。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827023948.png" alt="image-20210827023948695" style="zoom: 67%;" />

```java
class Solution {
    int[][] dirs = {
            {-1, 0}, {1, 0},    // 上下
            {0, -1}, {0 , 1}    // 左右
    };

    int[][] mat;
    int M;
    int N;

    public int numEnclaves(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        // 第一列和最后一列
        for (int x = 0; x < M; x++) {
            dfs(x, 0);
            dfs(x, N - 1);
        }
        // 第一行和最后一行
        for (int y = 0; y < N; y++) {
            dfs(0, y);
            dfs(M - 1, y);
        }

        int count = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(int x, int y) {
        if (x < 0 || x >= M) {
            return;
        }
        if (y < 0 || y >= N) {
            return;
        }

        if (mat[x][y] == 1) {
            mat[x][y] = 0;
            for (int[] dir : dirs) {
                dfs(x + dir[0], y + dir[1]);
            }
        }
    }
}
```

### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827015256.png" alt="image-20210827015256477" style="zoom:80%;" />

思路：遍历所有的边界，把边界上和 `O` 连通的点找到，赋值为 `B`。然后遍历整个 `board`，把 `O` 变成 `X`，最后把 `B` 变成 `O`。

<img src="https://pic.leetcode-cn.com/f6cc252beb78212f68d55136cf6093419c3a07cb2f2ccbcc53f8fc064d27708a-tmp.png" alt="tmp.png" style="zoom: 80%;" />

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},    // 上下
        {0, -1}, {0 , 1}    // 左右
    };

    char[][] mat;
    int M;
    int N;

    public void solve(char[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        // 遍历第0列和最后一列
        for (int x = 0; x < M; x++) {
            dfs(x, 0);
            dfs(x, N - 1);
        }
        // 遍历第0行和最后一行
        for (int y = 0; y < N; y++) {
            dfs(0, y);
            dfs(M - 1, y);
        }

        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 'O') {
                    mat[x][y] = 'X';
                } else if (mat[x][y] == 'B') {
                    mat[x][y] = 'O';
                }
            }
        }
    }

    private void dfs(int x, int y) {
        if (x < 0 || x >= M) {
            return;
        }
        if (y < 0 || y >= N) {
            return;
        }

        if (mat[x][y] == 'O') {
            mat[x][y] = 'B';
            for (int[] dir : dirs) {
                dfs(x + dir[0], y + dir[1]);
            }
        }
    }
}
```

### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830024605.png" alt="image-20210830024605476" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830024627.png" alt="image-20210830024627651" style="zoom:80%;" />

思路：遍历二维矩阵的边界，把与边界相邻所有陆地都填满水。再遍历不是边界的点，找连通分量个数。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    int[][] mat;
    int M;
    int N;

    public int closedIsland(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        // 第一列和最后一列
        for (int x = 0; x < M; x++) {
            dfs(x, 0);
            dfs(x, N - 1);
        }
        // 第一行和最后一行
        for (int y = 0; y < N; y++) {
            dfs(0, y);
            dfs(M - 1, y);
        }

        int count = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 0) {
                    dfs(x, y);
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(int x, int y) {
        if (x < 0 || x >= M || y < 0 || y >= N) {
            return;
        }
        if (mat[x][y] == 1) {
            return;
        }

        mat[x][y] = 1;
        for (int[] dir : dirs) {
            dfs(x + dir[0], y + dir[1]);
        }
    }
}
```

### [694. 不同岛屿的数量](https://leetcode-cn.com/problems/number-of-distinct-islands/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830030254.png" alt="image-20210830030254462" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210830030303.png" alt="image-20210830030303699" style="zoom:80%;" />

思路：哈希表 + DFS。如果DFS的路径是一样的，两个图形就是一样的。用哈希表保存DFS的路径。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    int[][] mat;
    int M;
    int N;

    public int numDistinctIslands(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        Set<String> path = new HashSet<>();
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    StringBuilder sb = new StringBuilder();
                    dfs(x, y, sb);
                    path.add(sb.toString());
                }
            }
        }
        return path.size();
    }

    private void dfs(int x, int y, StringBuilder sb) {
        if (x < 0 || x >= M || y < 0 || y >= N) {
            return;
        }
        if (mat[x][y] == 0) {
            return;
        }

        mat[x][y] = 0;
        dfs(x - 1, y, sb.append("up"));
        dfs(x + 1, y, sb.append("down"));
        dfs(x, y - 1, sb.append("left"));
        dfs(x, y + 1, sb.append("right"));
    }
}
```

### [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827122439.png" alt="image-20210827122439332" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827122520.png" alt="image-20210827122520512" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827122530.png" alt="image-20210827122530642" style="zoom:80%;" />

思路：八连通 + DFS。对当前位置做DFS：

* 如果当前位置是空（`E`），则统计当前节点周围的未引爆的地雷数量。如果有地雷，当前位置改为地雷数量，退出DFS。否则，当前位置改为`B`，对周围八个方向做DFS。
* 如果当前位置是未引爆的雷，改为引爆，退出DFS；
* 如果当前位置是引爆的雷，退出DFS；

```java
class Solution {
    int[][] dirs = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1}, {1, 0}, {1, 1}
    };

    char[][] mat;
    int M;
    int N;

    public char[][] updateBoard(char[][] mat, int[] click) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        dfs(click[0], click[1]);
        return mat;
    }

    private void dfs(int x, int y) {
        if (mat[x][y] == 'M') {
            mat[x][y] = 'X';
            return;
        }
        if (mat[x][y] == 'X') {
            return;
        }

        int count = 0;
        for (int[] dir : dirs) {
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            if (inArea(nextX, nextY) && mat[nextX][nextY] == 'M') {
                count++;
            }
        }
        if (count > 0) {
            mat[x][y] = (char) (count + '0');
            return;
        } else {
            mat[x][y] = 'B';
            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                if (inArea(nextX, nextY) && mat[nextX][nextY] == 'E') {
                    dfs(nextX, nextY);
                }
            }
        }
    }

    // 当前节点是否在矩阵里
    private boolean inArea(int x, int y) {
        return x >= 0 && x < M && y >= 0 && y < N;
    }
}
```

### [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902215245.png" alt="image-20210902215245824" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902220327.png" alt="image-20210902220327662" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902220339.png" alt="image-20210902220339865" style="zoom:50%;" />

不会。

思路：水从低处向高处流。从左边界和上边界出发，把所有能到达的点标记。再从右边界和下边界出发，找重合的点。

具体做法：用两个 visited数组 进行标记。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };
    int[][] mat;
    int M;
    int N;
    boolean[][] pVisited;
    boolean[][] aVisited;
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> pacificAtlantic(int[][] mat) {
        this.mat = mat;
        this.M = mat.length;
        this.N = mat[0].length;
        pVisited = new boolean[M][N];
        aVisited = new boolean[M][N];

        for (int y = 0; y < N; y++) {       // 第0行和最后一行
            dfs(pVisited, 0, y);
            dfs(aVisited, M - 1, y);
        }
        for (int x = 0; x < M; x++) {       // 第0列最后一列
            dfs(pVisited, x, 0);
            dfs(aVisited, x, N - 1);
        }
        return res;
    }

    private void dfs(boolean[][] visited, int x, int y) {
        if (visited[x][y]) {
            return;
        }

        visited[x][y] = true;
        if (pVisited[x][y] && aVisited[x][y]) {
            res.add(Arrays.asList(x, y));
        }
        for (int[] dir : dirs) {
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            if (inArea(nextX, nextY) && mat[nextX][nextY] >= mat[x][y]) {
                dfs(visited, nextX, nextY);
            }
        }
    }

    private boolean inArea(int x, int y) {
        return x >= 0 && x < M && y >= 0 && y < N;
    }
}
```

# 四连通 + DFS

### [778. 在水位上升的泳池中游泳](https://leetcode-cn.com/problems/swim-in-rising-water/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210813103236.png" alt="image-20210813102557082" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210813103232.png" alt="image-20210813102611700" style="zoom:80%;" />

不会。

时间：$O(N^{2}logN)$，DFS是 $O(N^{2})$，二分查找是$O(logN)$；空间：$O(N^{2})$

思路：**小岛问题 + 二分查找**。

* 越界，不行
* 当前位置高度大于水位，不行
* 已访问过，不行

```java
class Solution {
    boolean[][] visited;

    public int swimInWater(int[][] mat) {
        int N = mat.length;
        visited = new boolean[N][N];

        int max = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                max = Math.max(max, mat[i][j]);
            }
        }
        
        int left = 0;
        int right = max;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (possible(mat, mid, 0, 0)) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
            visited = new boolean[N][N];
        }
        return left;
    }
	
    // 是否能走到右下角，dfs
    private boolean possible(int[][] mat, int mid, int x, int y) {
        if (x < 0 || x >= mat.length || y < 0 || y >= mat.length) {       // 越界
            return false;
        }
        if (mat[x][y] > mid) {
            return false;
        }
        if (x == mat.length - 1 && y == mat.length - 1) {
            return true;
        }
        if (visited[x][y]) {
            return false;
        }
        visited[x][y] = true;
        return  possible(mat, mid, x - 1, y) ||
                possible(mat, mid, x + 1, y) ||
                possible(mat, mid, x, y - 1) ||
                possible(mat, mid, x, y + 1);
    }
}
```

### [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827142712.png" alt="image-20210827142712740" style="zoom:80%;" />

不会。

时间：$O(MN)$，M和N是矩阵的高宽

思路：**记忆化DFS + FloodFill**。同一个单元格对应的最长递增路径的长度是固定不变的，因此可以使用记忆化的方法进行优化。用矩阵 `visited[x][y]` 作为缓存矩阵，计算比 `visited[x][y]` 的最长递增路径长度。

当访问到一个单元格 `(x,y) ` 时，如果 `visited[x][y] != 0`，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果 `visited[x][y] == 0`，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。

遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。

```java
class Solution {
    int[][] dirs = {
        {-1, 0}, {1, 0},
        {0, -1}, {0, 1}
    };

    int[][] mat;
    int M;
    int N;
    int[][] visited;

    public int longestIncreasingPath(int[][] mat) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;
        visited = new int[M][N];

        int res = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (visited[x][y] == 0) {
                    res = Math.max(res, dfs(x, y));
                }
            }
        }
        return res;
    }

    public int dfs(int x, int y) {
        if (visited[x][y] == 0) {
            visited[x][y] = 1;
            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                if (inArea(nextX, nextY) && mat[nextX][nextY] > mat[x][y]) {
                    visited[x][y] = Math.max(visited[x][y], dfs(nextX, nextY) + 1);
                }
            }
        }
        return visited[x][y];
    }

    private boolean inArea(int x, int y) {
        return x >= 0 && x < M && y >= 0 && y < N;
    }
}
```

### [490. 迷宫](https://leetcode-cn.com/problems/the-maze/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828040530.png" alt="image-20210828040530726" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828040557.png" alt="image-20210828040557400" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210828040614.png" alt="image-20210828040613948" style="zoom:80%;" />

思路：DFS。访问到的节点设置为 -1，只要不碰壁就一直往一个方向走，如果没有访问过当前节点，就对当前节点做 DFS。

```java
class Solution {
    int[][] dirs = {
            {-1, 0}, {1, 0},
            {0, -1}, {0 , 1}
    };

    int[][] mat;
    int M;
    int N;

    public boolean hasPath(int[][] mat, int[] start, int[] target) {
        this.mat = mat;
        M = mat.length;
        N = mat[0].length;

        return dfs(start[0], start[1], target);
    }

    private boolean dfs(int x, int y, int[] target) {
        if (x == target[0] && y == target[1]) {
            return true;
        }

        mat[x][y] = -1;
        for (int[] dir : dirs) {
            int nextX = x;
            int nextY = y;

            while (inArea(nextX + dir[0], nextY + dir[1]) && mat[nextX + dir[0]][nextY + dir[1]] != 1) {
                nextX += dir[0];
                nextY += dir[1];
            }
            if (mat[nextX][nextY] != -1) {              // 没有访问过当前节点
                if (dfs(nextX, nextY, target)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean inArea(int x, int y) {
        return x >= 0 && x < M && y >= 0 && y < N;
    }
}
```

# DFS

### [386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902185103.png" alt="image-20210902185103509" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902190643.png" alt="image-20210902190643560" style="zoom: 67%;" />

思路：记录父节点的值。

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {
        List<Integer> res = new ArrayList<>();
        dfs(res, n, 0);
        return res;
    }

    // val是上一位的值
    private void dfs(List<Integer> res, int n, int val) {
        for (int i = 0; i <= 9; i++) {
            if (val == 0 && i == 0) {
                continue;
            }
            if (val * 10 + i > n) {
                return;
            }
            res.add(val * 10 + i);
            dfs(res, n, val * 10 + i);
        }
    }
}
```

### [365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902191933.png" alt="image-20210902191933160" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902191940.png" alt="image-20210902191940563" style="zoom:80%;" />

思路：由于DFS递归层数过多，本题使用栈模拟DFS，使用哈希表保存已经搜索过的状态。如果任意一个壶里的水为z升，或者加起来为z升，就返回。

任意时刻只有六种操作：

1. 把 X 壶的水灌进 Y 壶，直至灌满或倒空；
2. 把 Y 壶的水灌进 X 壶，直至灌满或倒空；
3. 把 X 壶灌满；
4. 把 Y 壶灌满；
5. 把 X 壶倒空；
6. 把 Y 壶倒空。

```java
class Solution {
    public boolean canMeasureWater(int x, int y, int target) {
        Deque<int[]> stack = new ArrayDeque<>();
        stack.addLast(new int[] {0, 0});
        Set<Long> used = new HashSet<>();

        while (!stack.isEmpty()) {
            if (used.contains(getHash(stack.getLast()))) {
                stack.removeLast();
                continue;
            }

            used.add(getHash(stack.getLast()));
            int[] water = stack.removeLast();
            int remainX = water[0];
            int remainY = water[1];
            if (remainX == target || remainY == target || remainX + remainY == target) {
                return true;
            }

            stack.addLast(new int[] {remainX - Math.min(remainX, y - remainY),
                    remainY + Math.min(remainX, y - remainY)});
            stack.addLast(new int[] {remainX + Math.min(remainY, x - remainX),
                    remainY - Math.min(remainY, x - remainX)});
            stack.addLast(new int[] {x , remainY});
            stack.addLast(new int[] {remainX, y});
            stack.addLast(new int[] {0, remainY});
            stack.addLast(new int[] {remainX, 0});
        }
        return false;
    }

    private Long getHash(int[] water) {
        return (long) water[0] * 10000000 + water[1];
    }
}
```

### [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902225244.png" alt="image-20210902225244300" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902225253.png" alt="image-20210902225253735" style="zoom:80%;" />

思路：DFS。用哈希表存放 <员工id，员工信息>。

```java
class Solution {
    int res = 0;

    public int getImportance(List<Employee> employees, int id) {
        Map<Integer, Employee> idAndInfo = new HashMap<>();
        for (Employee e : employees) {
            idAndInfo.put(e.id, e);
        }

        dfs(idAndInfo, id);
        return res;
    }

    private void dfs(Map<Integer, Employee> idAndInfo, int id) {
        Employee e = idAndInfo.get(id);
        res += e.importance;
        for (Integer subId : e.subordinates) {
            dfs(idAndInfo, subId);
        }
    }
}
```

### [5869. 两个回文子序列长度的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912121925.png" alt="image-20210912121856200" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912121923.png" alt="image-20210912121904342" style="zoom:80%;" />

思路：对于位置 i，两个子序列可以选择用或者不用

```java
int res = 0;

public int maxProduct(String ss) {
    char[] s = ss.toCharArray();
    dfs(s, 0, "", "");
    return res;
}

private void dfs(char[] s, int index, String s1, String s2) {
    if (isValid(s1) && isValid(s2)) {
        res = Math.max(res, s1.length() * s2.length());
    }
    if (index == s.length) {
        return;
    }
    dfs(s, index + 1, s1 + s[index], s2);
    dfs(s, index + 1, s1, s2 + s[index]);
    dfs(s, index + 1, s1, s2);
}

private boolean isValid(String s) {
    int left = 0;
    int right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```







# BFS

## 最短路径问题

整体思路：**多连通+ BFS**。用于解决**无权图的最短路径**问题。BFS是一层一层搜索，所以先搜索到的，就是最短的路径。

### [1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827150708.png" alt="image-20210827150708826" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827150733.png" alt="image-20210827150733167" style="zoom:80%;" />

不会 * 2

思路：**FloodFill + BFS**。

* 处理原点是 1，矩形长度为 1 的特殊情况
* BFS：找八个方向上点没有越界，没有访问过，而且值是 0 的点：
  * 标记该节点为已访问，更新距离
  * 如果到了终点，直接返回结果

```java
class Solution {
    int[][] dirs = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0, -1},           {0, 1},
        {1, -1}, {1, 0}, {1, 1}
    };

    public int shortestPathBinaryMatrix(int[][] mat) {
        int N = mat.length;
        boolean[][] visited = new boolean[N][N];
        int[][] dist = new int[N][N];           // 当前节点到原点的距离

        if (mat[0][0] == 1) {                   // 特殊情况
            return -1;
        }
        if (N == 1) {
            return 1;
        }

        Deque<int[]> deque = new ArrayDeque<>();
        deque.addLast(new int[] {0,0});
        visited[0][0] = true;
        dist[0][0] = 1;

        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                // 如果下个节点没有越界，没有访问过，而且值是0
                if (inArea(nextX, nextY, N) && !visited[nextX][nextY] && mat[nextX][nextY] == 0) {
                    visited[nextX][nextY] = true;
                    deque.addLast(new int[] {nextX, nextY});
                    dist[nextX][nextY] = dist[x][y] + 1;

                    if (nextX == N - 1 && nextY == N - 1) {
                        return dist[nextX][nextY];
                    }
                }
            }
        }
        return -1;
    }

    private boolean inArea(int x, int y, int N) {
        return x >= 0 && x < N && y >= 0 && y < N;
    }
}
```

### [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827155247.png" alt="image-20210827155247238" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827155259.png" alt="image-20210827155258999" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827155311.png" alt="image-20210827155311598" style="zoom:80%;" />

思路：BFS + FloodFill。HashSet 记录死亡数组，HashMap 记录 **<转盘锁上的数字，当前数字到 `0000 `的距离>**

* BFS：如果当前数字不是死亡数字，并且之前没有访问过这个数字：
  * 更新距离，更新队列
  * 如果这个节点是目标点，返回

```java
class Solution {
    public int openLock(String[] ds, String target) {
        Set<String> deadend = new HashSet<>();
        for (String d : ds) {
            deadend.add(d);
        }
		
        // 特殊情况
        if (deadend.contains("0000")) {
            return -1;
        }
        if (target.equals("0000")) {
            return 0;
        }

        Deque<String> deque = new ArrayDeque<>();
        Map<String, Integer> dist = new HashMap<>();    // <转盘锁上的数字，最短路径>
        deque.addLast("0000");
        dist.put("0000" , 0);

        while (!deque.isEmpty()) {
            String cur = deque.removeFirst();
            List<String> nextList = getNext(cur);

            for (String next : nextList) {
                // 如果当前数字不是死亡数字，并且之前没有访问过这个数字
                if (!deadend.contains(next) && !dist.containsKey(next)) {
                    dist.put(next, dist.get(cur) + 1);
                    deque.addLast(next);

                    if (next.equals(target)) {
                        return dist.get(next);
                    }
                }
            }
        }
        return -1;
    }

    private List<String> getNext(String cur) {
        List<String> nextList = new ArrayList<>();

        for (int i = 0; i < 4; i++) {
            // 加1
            char[] next = cur.toCharArray();
            next[i] = next[i] == '9' ? '0' : (char) (next[i] + 1);
            nextList.add(new String(next));
            // 减1
            next = cur.toCharArray();
            next[i] = next[i] == '0' ? '9' : (char) (next[i] - 1);
            nextList.add(new String(next));
        }
        return nextList;
    }
}
```

### [773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)

华容道

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827163525.png" alt="image-20210827163525819" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827163600.png" alt="image-20210827163600272" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210827163629.png" alt="image-20210827163629400" style="zoom:80%;" />

思路：**BFS + FloodFill**。**二维数组 `mat`使用字符串来表示**。哈希表 `visited` ：<`mat`的字符串表达式, 移动次数>

* BFS：遍历下一层的节点，如果没有访问过，就更新队列，更新`visited`；如果下个节点是目标值，就返回。

  ```java
  class Solution {
      int[][] neighbors = {
              {1, 3}, {0, 2, 4}, {1, 5},      // 第0行
              {0, 4}, {1, 3, 5}, {2, 4}       // 第1行
      };
  
      public int slidingPuzzle(int[][] mat) {
          int M = mat.length;
          int N = mat[0].length;
  
          StringBuilder sb = new StringBuilder();
          for (int i = 0; i < M; i++) {
              for (int j = 0; j < N; j++) {
                  char c = (char) (mat[i][j] + '0');
                  sb.append(c);
              }
          }
          String src = sb.toString();
          if (src.equals("123450")) {
              return 0;
          }
  
          Deque<String> deque = new ArrayDeque<>();
          deque.addLast(src);
          Map<String, Integer> visited = new HashMap();
          visited.put(src, 0);
  
          while (!deque.isEmpty()) {
              String cur = deque.removeFirst();
              List<String> nextList = getNext(cur);
  
              for (String next : nextList) {
                  if (!visited.containsKey(next)) {
                      deque.addLast(next);
                      visited.put(next, visited.get(cur) + 1);
  
                      if (next.equals("123450")) {
                          return visited.get(next);
                      }
                  }
              }
          }
          return -1;
      }
  
      public List<String> getNext(String cur) {
          List<String> nextList = new ArrayList<>();
          int i = cur.indexOf('0');
          for (int j : neighbors[i]) {
              char[] next = cur.toCharArray();
              swap(next, i, j);
              nextList.add(new String(next));
          }
          return nextList;
      }
  
      public void swap(char[] arr, int i, int j) {
          char temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
      }
  }
  ```

### [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903041031.png" alt="image-20210903041031734" style="zoom:80%;" />

思路：二维数组扩展为三维。visited数组保存：[位置i，位置j，还剩余k个消除障碍物的机会] 。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int shortestPath(int[][] mat, int k) {
        int M = mat.length;
        int N = mat[0].length;
        if (M == 1 && N == 1) {
            return 0;
        }

        boolean[][][] visited = new boolean[M][N][k + 1];        // 位置到达[i,j]，还剩余k个消除障碍物的机会
        visited[0][0][k] = true;
        Deque<int[]> deque = new ArrayDeque<>();
        deque.addLast(new int[] {0, 0, k});
        int minStep = 0;

        while (!deque.isEmpty()) {
            minStep++;

            int size = deque.size();
            for (int i = 0; i < size; i++) {
                int[] cur = deque.removeFirst();
                int x = cur[0];
                int y = cur[1];
                int remainCount = cur[2];       // 剩余次数

                for (int[] dir : dirs) {
                    int nextX = x + dir[0];
                    int nextY = y + dir[1];

                    if (!inArea(mat, nextX, nextY)) {       // 越界
                        continue;
                    }

                    if (mat[nextX][nextY] == 0 && !visited[nextX][nextY][remainCount]) {
                        if (nextX == M - 1 && nextY == N - 1) {
                            return minStep;
                        } else {
                            visited[nextX][nextY][remainCount] = true;
                            deque.addLast(new int[] {nextX, nextY, remainCount});
                        }
                    }
                    if (mat[nextX][nextY] == 1 && remainCount > 0 && !visited[nextX][nextY][remainCount - 1]) {
                        visited[nextX][nextY][remainCount - 1] = true;
                        deque.addLast(new int[] {nextX, nextY, remainCount - 1});
                    }
                }
            }
        }
        return -1;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903203044.png" alt="image-20210903203044430" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210903202933661.png" alt="image-20210903202933661" style="zoom:80%;" />

思路：用哈希表保存 `wordList`，哈希表查找的复杂度是 $O(1)$。哈希表 `visited` 保存是否访问过某个单词。队列加入起始单词，初始时，步数为1，BFS每向外扩一层，就+1。遍历队列中的单词，如果当前单词修改一位就与目标单词相同，就返回步数；如果修改后的单词在单词列表里，则把这个单词标记为已访问，加入队列。

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>(wordList);
        if (!wordSet.contains(endWord)) {
            return 0;
        }
        wordSet.remove(beginWord);

        Deque<String> deque = new ArrayDeque<>();
        Set<String> visited = new HashSet<>();
        deque.addLast(beginWord);
        visited.add(beginWord);

        int step = 1;
        while (!deque.isEmpty()) {
            step++;
            int size = deque.size();

            for (int i = 0; i < size; i++) {
                String curWord = deque.removeFirst();
                if (changeLetterIsEndWord(deque, visited, wordSet, endWord, curWord)) {
                    return step;
                }
            }
        }
        return 0;
    }

    private boolean changeLetterIsEndWord(Deque<String> deque, Set<String> visited,
                                          Set<String> wordSet, String endWord, String curWord) {

        char[] arr = curWord.toCharArray();
        for (int i = 0; i < arr.length; i++) {
            char originChar = arr[i];

            for (char c = 'a'; c <= 'z'; c++) {
                arr[i] = c;
                String nextWord = new String(arr);
                if (!wordSet.contains(nextWord)) {
                    continue;
                }

                if (nextWord.equals(endWord)) {
                    return true;
                }
                if (!visited.contains(nextWord)) {
                    visited.add(nextWord);
                    deque.addLast(nextWord);
                }
            }
            arr[i] = originChar;
        }
        return false;
    }
}
```

### [126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903210624.png" alt="image-20210903210624405" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903210635.png" alt="image-20210903210635564" style="zoom:80%;" />

不会。

<img src="https://pic.leetcode-cn.com/2a8ee4ecbccdcd06d1fb979c35c2db1cef7a8a2f369830dff5ac9db2453984cc.jpg" alt="img" style="zoom:50%;" />

思路：用哈希表保存单词集合，哈希表查找的复杂度是 $O(1)$。哈希表 `visited` 保存是否访问过某个单词。队列加入包含起始单词的列表。`path` 保存队列中的列表。由于本层中的目标节点可能有多个，所以我们要用额外的哈希表`levelVisited`，保存本层访问的节点，等访问过本层节点之后，再加入到 `visited` 中。也需要使用额外的 `isFound`，标记本层是否找到了目标单词，等本层结束之后，再返回结果。

```java
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet= new HashSet<>(wordList);
        if (!wordSet.contains(endWord)) {
            return new ArrayList<>();
        }

        List<List<String>> res = new ArrayList<>();
        Deque<List<String>> deque = new ArrayDeque<>();
        List<String> path = new ArrayList<>();
        path.add(beginWord);
        deque.add(path);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        boolean isFound = false;
        while (!deque.isEmpty()) {
            Set<String> levelVisited = new HashSet<>();         // 本层访问过的节点
            int size = deque.size();

            for (int i = 0; i < size; i++) {
                path = deque.removeFirst();
                String cur = path.get(path.size() - 1);             // 取最后一位
                List<String> nextList = getNext(wordSet, cur);

                for (String next : nextList) {
                    if (visited.contains(next)) {
                        continue;
                    }

                    path.add(next);
                    levelVisited.add(next);
                    deque.addLast(new ArrayList<>(path));
                    if (next.equals(endWord)) {
                        res.add(new ArrayList<>(path));
                        isFound = true;
                    }
                    path.remove(path.size() - 1);
                }
            }
            visited.addAll(levelVisited);
            if (isFound) {
                return res;
            }
        }
        return res;
    }

    private List<String> getNext(Set<String> wordSet, String cur) {
        List<String> nextList = new ArrayList<>();
        char[] arr = cur.toCharArray();
        for (int i = 0; i < arr.length; i++) {
            char originChar = arr[i];

            for (char c = 'a'; c <= 'z'; c++) {
                arr[i] = c;
                String next = new String(arr);
                if (wordSet.contains(next)) {
                    nextList.add(next);
                }
            }
            arr[i] = originChar;
        }
        return nextList;
    }
}
```

### [面试题 17.22. 单词转换](https://leetcode-cn.com/problems/word-transformer-lcci/)

![image-20210922145541666](https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210922145541.png)

思路：

### [815. 公交路线](https://leetcode-cn.com/problems/bus-routes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903233041.png" alt="image-20210903233041630" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903233053.png" alt="image-20210903233053525" style="zoom:80%;" />

思路：用哈希表 `map` 构建邻接矩阵，保存 <公交站台，这个站台能通过的达公交路线>。在用另外一个哈希表 `dist` 保存<公交路线，到达该公交路线的距离>。构建邻接矩阵，并把把源点的公交路线下标加入队列和 `dist`。再 BFS，每一从去找有没有目标节点，找到了返回。如果当前站台能到达的公交路线，没有被访问过，即没有出现在`dist `中，就把它加入到`dist `中，并加入队列。

```java
public int numBusesToDestination(int[][] routes, int s, int t) {
    if (s == t) {
        return 0;
    }

    Map<Integer, Set<Integer>> map = new HashMap<>();   // <公交站台，这个站台能通过的达公交路线>
    Map<Integer, Integer> dist = new HashMap<>();       // <公交路线，到达该公交路线的距离>
    Deque<Integer> deque = new ArrayDeque<>();

    for (int i = 0; i < routes.length; i++) {
        for (int station : routes[i]) {
            if (station == s) {
                deque.addLast(i);
                dist.put(i, 1);
            }
            Set<Integer> set = map.getOrDefault(station, new HashSet<>());
            set.add(i);
            map.put(station, set);
        }
    }

    while (!deque.isEmpty()) {
        int cur = deque.removeFirst();      // 当前公交路线的下标
        int step = dist.get(cur);           // 到达当前公交路线的距离

        for (int station : routes[cur]) {
            if (station == t) {
                return step;
            }

            Set<Integer> nextSet = map.getOrDefault(station, new HashSet<>());
            for (int next : nextSet) {
                if (!dist.containsKey(next)) {
                    dist.put(next, step + 1);
                    deque.addLast(next);
                }
            }
        }
    }
    return -1;
}
```

## 多源BFS

### [286. 墙与门](https://leetcode-cn.com/problems/walls-and-gates/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903013446.png" alt="image-20210903013446397" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903013421.png" alt="image-20210903013421494" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903013832.png" alt="image-20210903013832890" style="zoom:80%;" />

不会。时间：$O(M*N)$，每个点最多只被访问一次。空间：$O(M*N)$ 。

思路：找出所有的门，加入队列。从每个门出发，每次同时只走一步，再把当前位置加入队列。先到达的距离最短。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0, 1}
    };
    final int EMPTY = Integer.MAX_VALUE;

    public void wallsAndGates(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;

        Deque<int[]> deque = new ArrayDeque<>();
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 0) {
                    deque.addLast(new int[] {x, y});
                }
            }
        }

        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == EMPTY) {
                    mat[nextX][nextY] = mat[x][y] + 1;
                    deque.addLast(new int[] {nextX, nextY});
                }
            }
        }
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903015621.png" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903015550.png" alt="image-20210903015550014" style="zoom:80%;" />

时间：$O(M*N)$

思路：先统计所有新鲜橘子的数量。再把所有腐烂的橘子都加入到队列中，每次都同时走一步。用额外的数组`step`保存被腐烂需要的步数。最后看腐烂的橘子数是不是等于之前的新鲜橘子数，如果等于就返回腐烂步数的最大值。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int orangesRotting(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;

        Deque<int[]> deque = new ArrayDeque<>();
        int freshCount = 0;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    freshCount++;
                }
                if (mat[x][y] == 2) {
                    deque.addLast(new int[] {x, y});
                }
            }
        }

        int res = 0;
        int[][] step = new int[M][N];
        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == 1) {
                    mat[nextX][nextY] = 2;
                    step[nextX][nextY] = step[x][y] + 1;
                    res = Math.max(res, step[nextX][nextY]);
                    freshCount--;
                    deque.addLast(new int[] {nextX, nextY});
                }
            }
        }
        return freshCount == 0 ? res : -1;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903022821.png" alt="image-20210903022821290" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903022833.png" alt="image-20210903022833893" style="zoom:80%;" />

时间：$O(M*N)$

思路：和 [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/) 思路类似。把所有0点都加入到队列中，然后去找1，找到1就更新距离，需要用一个新的数组step保存。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int[][] updateMatrix(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;

        int[][] step = new int[M][N];
        Deque<int[]> deque = new ArrayDeque<>();
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 0) {
                    deque.addLast(new int[] {x, y});
                }
            }
        }

        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == 1) {
                    step[nextX][nextY] = step[x][y] + 1;
                    mat[nextX][nextY] = 0;
                    deque.addLast(new int[] {nextX, nextY});
                }
            }
        }
        return step;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903045958.png" alt="image-20210903045958316" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903050017.png" alt="image-20210903050017620" style="zoom:80%;" />

时间：$O(M*N)$

思路：找出所有1，加入到队列。每个位置走一次，更新距离。最后返回最大距离。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int maxDistance(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;


        int[][] dist = new int[M][N];
        Deque<int[]> deque = new ArrayDeque<>();
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (mat[x][y] == 1) {
                    deque.addLast(new int[] {x, y});
                }
            }
        }
        if (deque.size() == 0 || deque.size() == M * N) {
            return -1;
        }
        
        int res = 0;
        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == 0) {
                    dist[nextX][nextY] = dist[x][y] + 1;
                    mat[nextX][nextY] = 1;
                    deque.addLast(new int[] {nextX, nextY});
                    res = Math.max(res, dist[nextX][nextY]);
                }
            }
        }
        return res;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210903044653549.png" alt="image-20210903044653549" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210903044702274.png" alt="image-20210903044702274" style="zoom:80%;" />

不会。时间：$O(MNlogMN)$

思路：先确定木桶的外围，找到外围的最短板子后对其周围能填水的地方填水，然后更新木桶外围。

具体做法：优先队列保存：[x, y, 水的高度]，先把第一圈放进去。弹出最低的，然后看四个方向，没访问过的话能不能往里灌水。如果位置合法且没访问过，且如果外围这一圈中最小的比当前这个还高，那就说明能往里面灌水。更新结果，高度，标记为已访问。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int trapRainWater(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;

        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[2] - o2[2]);
        boolean[][] visited = new boolean[M][N];
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (x == 0 || x == M - 1 || y == 0 || y == N - 1) {
                    pq.add(new int[] {x, y, mat[x][y]});
                    visited[x][y] = true;
                }
            }
        }

        int res = 0;
        while (!pq.isEmpty()) {
            int[] cur = pq.remove();
            int x = cur[0];
            int y = cur[1];
            int h = cur[2];     // 高度

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && !visited[nextX][nextY]) {
                    if (mat[nextX][nextY] < h) {
                        res += h - mat[nextX][nextY];
                    }
                    pq.add(new int[] {nextX, nextY, Math.max(h, mat[nextX][nextY])});
                    visited[nextX][nextY] = true;
                }
            }
        }
        return res;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

### [317. 离建筑物最近的距离](https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903223545.png" alt="image-20210903223535859" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210903223557.png" alt="image-20210903223557876" style="zoom:80%;" />

不会。

思路：对每个建筑物做BFS，更新到空地的距离，最后把这些距离叠加，找最小值即可。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public int shortestDistance(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;

        int[][] totalDist = new int[M][N];
        int[][] dist = new int[M][N];
        for (int i = 0; i < M; i++) {
            totalDist[i] = Arrays.copyOf(mat[i], N);
            dist[i] = Arrays.copyOf(mat[i], N);
        }

        int val = 0;
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (mat[i][j] == 1) {
                    res = bfs(mat, totalDist, dist, i, j, val);
                    val--;
                }
            }
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }

    private int bfs(int[][] mat, int[][] totalDist, int[][] dist, int startX, int startY, int val) {
        int res = Integer.MAX_VALUE;
        Deque<int[]> deque = new ArrayDeque<>();
        deque.addLast(new int[] {startX, startY});

        while (!deque.isEmpty()) {
            int[] cur = deque.removeFirst();
            int x = cur[0];
            int y = cur[1];

            for (int[] dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];

                if (inArea(mat, nextX, nextY) && mat[nextX][nextY] == val) {
                    mat[nextX][nextY]--;
                    dist[nextX][nextY] = dist[x][y] + 1;
                    totalDist[nextX][nextY] += dist[nextX][nextY] - 1;
                    deque.addLast(new int[] {nextX, nextY});
                    res = Math.min(res, totalDist[nextX][nextY]);
                }
            }
        }
        return res;
    }

    private boolean inArea(int[][] mat, int x, int y) {
        return x >= 0 && x < mat.length && y >= 0 && y < mat[0].length;
    }
}
```

