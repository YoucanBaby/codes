[TOC]

# 一、概述

## 操作系统的基本特征

### 1. 并发

**并发**是指宏观上在**一段时间内能同时运行多个程序**。

而**并行**则指**同一时刻能运行多个程序**。

### 2. 共享

**共享**是指**系统中的资源可以被多个并发进程共同使用**。

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时分复用技术和空分复用技术。

常见的虚拟技术：虚拟内存。

### 4. 异步

**异步**指**进程不是一次性执行完毕**，而是走走停停，以不可知的速度向前推进。

## 操作系统的基本功能

* 内核的基本功能
* 系统调用

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 操作系统的运行机制

### 1. 两种指令

* **非特权指令**：如普通的运算指令。
* **特权指令**：不允许用户使用，如设备访问、物理内存分配、内存清零指令。

### 2. 两种处理器状态的区别

* **用户态**：只能执行非特权指令。
* **内核态**：非特权指令、特权指令都可执行

### 3. 两种程序

* 用户程序：只能执行非特权指令，运行在用户态。
* 内核程序：即能执行特权指令，也能执行非特权指令，运行在核心态。

### 4. 为什么分用户态和内核态

硬件上，CPU 厂商将指令集分为不同的特权等级从 Ring0 到 Ring3 ；软件上，Linux 将内核运行在 Ring0，用户进程运行在 Ring3，例如设备访问指令只能由内核进行，并给用户进程分配虚拟页表，否则用户进程能够越界访问其他进程的内存，不安全。

### 5. 用户态和内核态的转换

* **用户态--->内核态**：外中断、异常、系统调用
* 内核态--->用户态：设置程序状态字的标志位为“用户态”

## 内核

* **内核的定义**：**计算机上的低层软件**，是操作系统最基本、最核心的部分，负责硬件驱动与提供各种系统所需的内核功能。内核就是系统上的一个文件而已，包含了驱动主机各项硬件的检测程序与驱动模块。
* **内核的功能**：时钟管理、中断、原语、基本功能。

## 大内核和微内核

**大内核和微内核的区别**：

* 大内核：将操作系统的**主要功能模块**作为内核。
* 微内核：将操作系统的**最基本的功能**保留在内核。

**各自的优缺点**：

* 大内核：**高性能**，但难以维护。
* 微内核：**方便维护**，但需要频繁地在核心态和用户态之间切换，性能低。

## 中断

* **中断的定义**：CPU暂停正在执行的程序，保存现场后去处理中断的事件，处理完该事件后，再返回中断处继续执行原来的程序
* 中断的处理过程：
  1. 执行完每个指令之后，CPU都要检查当前是否有外部中断信号
  2. 如果有外部中断信号，就保护被中断进程的CPU环境
  3. 根据中断信号类型处理中断
  4. 退出中断并恢复原进程的CPU环境，继续执行原进程
* **中断的优点**：实现多道程序**并发**执行

## 中断分类

### 1. 外中断

由 CPU 执行指令以外的事件引起（**外部触发**），如 **I/O 完成中断**，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

### 2. 异常

由 CPU 执行指令的内部事件引起（**内部触发**），如**除0**、地址越界、算术溢出等，也称为内中断。

### 3. 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

## 原子操作（原语）

不可被中断的操作。

# 二、进程管理

## 进程、线程、协程

### 1. 进程

进程是**资源分配的基本单位**。

一段时间内运行的应用程序。

### 2. 线程

线程是**调度的基本单位**。

一个进程中可以有多个线程，它们共享进程资源。

### 3. 进程与线程的区别

Ⅰ 拥有**资源**

**进程是资源分配的基本单位**，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ **调度**

**线程是调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ **系统开销**

比如创建进程时，系统要为进程分配资源，所付出的开销远大于创建线程时的开销。

Ⅳ **通信**方面

**同一进程中的线程间**可以**直接通信**，但是**进程通信**需要借助 **IPC**。 

### 4. 协程

是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

## 进程的状态与转换

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408111923615.png" alt="image-20210408111923615" style="zoom: 80%;" />

created：创建

ready：就绪

running：运行

waiting：阻塞

terminated：终止

## 进程调度算法

### 1. 批处理系统

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照<font color='orange'>请求的顺序</font>进行调度。因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了**短作业等待时间过长**。

<font color='red'>有利于长作业，但不利于短作业</font>。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计<font color='orange'>运行时间最短的顺序</font>进行调度。

<font color='red'>长作业有可能会饿死</font>。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按<font color='orange'>剩余运行时间最短的顺序</font>进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**1.4 最高响应比优先 highest response ratio next (HRRN)**

非抢占式的调度算法，按<font color='orange'>响应比最高的顺序</font>进行调度。

### 2. 交互式系统

**2.1 时间片轮转 round-robin（RR）** 

将**所有进程按 FCFS 的原则排成一个队列**，每次调度时，**把 CPU 时间分配给队首的进程**，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往队尾，最后把 CPU 时间分配给队首的进程。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210408142737090.png" alt="image-20210408142737090" style="zoom:80%;" />



缺点：时间片轮转算法的效率和**时间片的大小**有很大关系：

- 如果**时间片太小**，**在进程切换上就会花过多时间**。
- 如果**时间片太大**，那么**实时性就不能得到保证**。

抢占式的调度算法，Windows和Linux使用时间片轮转的抢占式调度算法。

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度（饥饿），可以**随着时间的推移增加等待进程的优先级**。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列设置了多个队列，每个队列时间片大小都不同，例如 1, 2, 4, 8, 16, 32, 64。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

### 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者不能超时，后者可以容忍一定的超时。

## 进程同步

进程同步与进程通信的区别：

* 进程同步：多个进程按一定顺序执行；

* 进程通信：进程间传输信息。

### 1. 临界区

对临界资源进行访问的那段代码称为临界区。

### 2. 同步与互斥

- **同步**：**多个进程有一定的先后执行关系。**
- **互斥**：多个进程在**同一时刻只有一个进程能进入临界区**。

### 3. 信号量

信号量（Semaphore）是一个**int**，可以对其执行 **down 和 up 操作**，也就是常见的 **P 和 V 操作**。

- **down** : 如果信号量大于 0 ，则信号量 -1 ；如果信号量等于 0，进程挂起，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原子操作，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```java
int s = 1;

void down (int s) {
    while (s <= 0);
    s -= 1;
}

void up (int s) {
    s += 1;
}
```

**使用信号量实现生产者-消费者问题** 

```c++
semaphore mutex = 1;		// 互斥信号量，实现对缓冲区的互斥访问
semaphore empty = N;		// 同步信号量，表示空闲缓冲区的数量
semaphore full = 0;			// 同步信号量，表示产品的数量，即非空缓冲区的数量

producer() {
    while(1) {
        生产一个产品;
        down(empty);		// 空闲缓冲区-1
        down(mutex);		// 上锁
        把产品放入缓冲区;
        up(mutex);			// 解锁
        up(full);			// 产品+1
    }
}

consumer() {
    while(1) {
        down(full);			// 产品-1
        down(mutex);		// 上锁
        从缓冲区中取出一个产品;
        up(mutex);			// 解锁
        up(empty);			// 空闲缓冲区+1
        使用产品;
    }
}
```

## 经典同步问题  

### 1. 读者-写者问题  

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

```c++
semaphore count_mutex = 1;		// 用于对 count 加锁
semaphore data_mutex = 1;		// 用于对读写的数据加锁
int count = 0;					// 记录在对数据进行读操作的进程数量

reader() {
    while(1) {
        down(count_mutex);			// count加锁
        if(count == 0) 
            down(data_mutex); 		// 第一个读者“加锁”
        count++;					// 读者+1
        up(count_mutex);			// count解锁
       	读文件;
        down(count_mutex);			// count加锁
        count--;					// 读者-1
        if(count == 0) 
            up(data_mutex);			// 最后一个读者“解锁”
		up(count_mutex);			// count解锁
	}
}

writer() {
    while(1) {
        down(data_mutex);			// 写者加锁
       	写文件;
        up(data_mutex);				// 写者解锁
    }
}
```

* 上述方法只要有读进程在读，写进程就一直阻塞，可能“饿死”，因此优化代码可以让“写优先”

### 2. 哲学家进餐问题  

* 出现次数少

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210411112702468.png" alt="image-20210411112702468" style="zoom: 67%;" />

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。  

```c++
semaphore mutex = 1; 			// 临界区的互斥
semaphore chopstick[5] = {1,1,1,1,1}; 		// i号筷子

Pi() {	// i号哲学家的进程
    down(mutex);				// 加锁
    down(chopstick[i]);			// 拿左
    down(chopstick[(i+1)%5]);	// 拿右
    吃饭;
    up(mutex);					// 解锁
    up(chopstick[i]);			// 放左
    up(chopstick[(i+1)%5]);		// 放右
    思考;
}
```

* 以上方法会造成死锁，为了防止死锁的发生，可以设置两个条件：
  * 必须同时拿起左右两根筷子；
  * 只有在两个邻居都没有进餐的情况下才允许进餐。  

## 进程通信

进程同步与进程通信的区别：

* 进程同步：多个进程按一定顺序执行；

* 进程通信：进程间传输信息。


为了能够达到进程同步的目的，需要进程通信，传输进程同步所需要的信息。

### 1. 匿名管道

使用场景：在**父子进程**中实现**半双工通信**。

称为 **Pipe**，在内存中开辟一个大小固定的缓冲区，需要双方通信时，需要建立起两个管道。

### 2. 命名管道

使用场景：**客户-服务器应用程序中**

称为 **FIFO**

### 3. 消息队列

称为 **Message Queue**

使用场景（优点）：**解耦、异步、限流削峰**

* 解耦：降低模块之前的耦合度

* 异步：提高反应速度
* 限流削峰：<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413110523601.png" alt="image-20210413110523601" style="zoom: 50%;" />

缺点：

* 系统可用性降低：加入MQ后，系统崩溃
* 系统复杂度提高：如何防止消息丢失？如何保证消息传递的顺序性？
* 一致性问题： AB 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。

### 4. 共享内存

允许**多个进程共享给定的内存**，这是**最快**（效率最高）的一种 IPC 。

需要使用信号量用来同步对共享存储的访问。  

**多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存**。

称为 **Shared Memory**

### 5. 套接字（Socket）

### 6. 信号量（Semaphore）

## 守护进程、孤儿进程、僵尸进程

### 1. 守护进程

Daemon（守护进程）是**运行在后台的一种特殊进程**。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。**它不需要用户输入就能运行而且提供某种服务，这种服务可提供给整个系统or某个用户**。Linux系统的大多数服务器就是通过守护进程实现的。

### 2. 孤儿进程

一个**父进程退出**，而它的**子进程还在运行**，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 3. 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。

**子进程退出**，而**父进程并没有调用 wait() 或 waitpid()**，那么**子进程的进程描述符仍然保存在系统中**，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie），要消灭系统中大量的僵尸进程，只需要**将其父进程杀死**，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

# 三、死锁

## 死锁、饥饿、死循环

**死锁**：**各进程相互等待对方手里的资源，导致各进程都阻塞**的现象。

**饥饿**：**某进程长期得不到想要的资源**，**导致某进程无法向前推进**的现象，这个进程是阻塞态or就绪态。

## 死锁产生的必要条件  

* **互斥**：一个资源每次只能被一个进程使用。
* **持有申请**：已经得到了资源的进程可以再申请新的资源。
* **不可抢占**：一个资源已被进程占有，则不可被强行抢占
* **环路等待**：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 死锁的处理方法

主要有以下四种方法：

* 忽略
* 死锁检测与死锁恢复
* 死锁预防
* 死锁避免  

## 忽略  

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是**忽略它**。  

## 死锁检测与死锁恢复  

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。  

### 1. 死锁检测  

死锁检测：**检测有向图是否存在环**，从一个节点出发进行**深度优先搜索**，对访问过的节点进行标记，如果访问了已经标记的节点，就表示**有向图存在环，也就是检测到死锁的发生。**  

### 2. 死锁恢复  

* 利用**抢占恢复**：挂起部分死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
* 利用**回滚恢复**：让部分死锁进程回滚到足以避免死锁的地步。
* 通过**杀死进程恢复**：强制杀死部分死锁进程。

  记得方式即可

## 死锁预防  

在程序运行之前预防发生死锁。  

### 1. 破坏互斥条件  

例如**假脱机打印机技术**允许若干个进程同时输出，唯一真正请求物理打印机的进程是**打印机守护进程**。  

### 2. 破坏持有申请条件  

实现方法：所有进程在**开始执行前请求所需要的全部资源**。  

### 3. 破坏不可抢占条件  

一实现方法：当某个进程请求**新资源得不到**满足时，它必须立即**释放所有资源**。

### 4. 破坏环路等待  

给**资源编号**，进程只能**按编号顺序来请求资源**。  

## 死锁避免  

在程序运行时避免发生死锁。  

### 1. 安全状态  

定义：**不会发生死锁的状态。**

### 2. 安全序列

定义：系统按照这种序列分配资源，每个进程都能顺利完成，不会出现不安全状态

### 3. 银行家算法  

* 避免死锁的算法

* **银行家算法**步骤：

  1. 检查 Request <= Need
  2. 检查 Request <= Available
  3. **分配资源**
  4. **安全性算法检查**

* **安全性算法**步骤：

  **Need <= Available**？如果小于等于，就把该进程加入**安全序列**，并把该进程持有的**资源全部回收**。

  **重复上述过程**，看最终是否能将所有进程都加入安全序列。

# 四、内存管理

## 虚拟内存

**虚拟内存的定义**：虚拟内存使得**应用程序认为它拥有一段连续完整的内存空间**，这个空间通常被分为**多个物理内存碎片**，甚至有的部分存储在**外部磁盘存储器**上，需要的时候进行数据交换。

虚拟内存的目的：为了让**物理内存扩充成更大的逻辑内存**，从而让程序获得**更多的可用内存**。

虚拟内存实现方法：**操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个大小固定的块，每一块称为一页，每一页再与物理地址进行映射。**

虚拟内存**允许程序不用将地址空间中的每一页都映射到物理内存**，即**一个程序不需要全部调入内存就可以运行**。

优点： 

1. **扩大内存** 
2. 多次性，**允许作业被分成多次调入内存**。
3. 对换性，**允许在作业运行过程中，将作业换入、换出**

**局部性原理**：**时间局部性**，在一段时间内，整个程序的执行仅限于程序的某一部分；**空间局部性**，程序访问的存储空间局限于某一内存区域。

虚拟内存基于局部性原理设计的，采用分页技术。

## 虚拟地址与物理地址

### 虚拟地址

**页号➕偏移量**，在虚拟内存中分配给某一位置的地址使该位置可以被访问。

### 物理地址

页框号➕偏移量，物理内存的地址。

### 虚拟地址空间

进程的可用地址空间范围。

### 物理地址空间

实际可用的内存空间范围

### 地址空间

可用于某进程的内存地址范围。

## 分页

分页的做法：**把地址空间被分割成多个大小固定的页，每一页与物理地址进行映射。**

**页表**存储着**虚拟地址和物理地址的映射表**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210412202627400.png" alt="image-20210412202627400" style="zoom:67%;" />

## 分段

分段的做法：把**地址空间分成段**，一个段构成一个独立的地址空间。**每个段的长度可以不同**，并且可以**动态增长**。

解决了分页的覆盖问题。

优点：

1. 保护：进程不会访问超出该段的内存单元
2. 共享：一个段可以被多个进程使用

## 分页与分段的区别

- **对程序员的透明性**：**分页透明**，但是分段需要程序员显式划分每个段。
- **地址空间的维度**：分页是一维地址空间，分段是二维的。
- **大小是否可以改变**：页的大小不可变，段的大小可以动态改变。
- **出现的原因**：**分页**主要用于实现**虚拟内存**，从而获得更大的地址空间；**分段**主要是为了使程序和数据可以被划分为逻辑上的**独立地址空间**并且有助于**保护和共享**。

## 段页式

段页式的做法：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。

优点：这样既拥有分段系统的保护和共享，又拥有分页系统的虚拟内存功能。

### 段页式 实现虚拟地址转换为物理地址

**内存管理单元**（MMU）负责虚拟地址和物理地址的转换。

- **第一步，先将 *虚拟地址*  转换为 *逻辑地址* ：**根据**段号➕段偏移**，我们就能得到一个逻辑地址
- **第二步，再将 *逻辑地址* 转换为 *线型地址* ：**有了逻辑地址之后，我们需要将逻辑地址转换为线型地址（因为线型地址是逻辑地址转换到物理地址的一个中间层），只需要把**逻辑地址➕段的基地址**就能生成一个**线型地址**
- **第三步，再将 *线型地址*  再转换为 *物理地址* ：**
  - 如果启用了分页机制，最后根据**页号➕页偏移**，得到**物理地址**
  - 如果没有启用分页机制，那么线型地址直接就是**物理地址**了

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210413162336090.png" alt="image-20210413162336090" style="zoom:80%;" />

## 页面置换算法  

页面置换算法的主要目标是使**缺页率最低**。

### 1. 先进先出

> **FIFO**, First In First Out

原理：**每次淘汰最先进入的页面。**

优点：实现简单

缺点：**缺页率最高**。

改进方法：给每个页面增加一个R位，每次先从链表头开始查找，如果R置位，清除R位并且把该页面节点放 到链表结尾；如果R是0，那么就是又老又没用到，替换掉。

### 2. 最佳

> **OPT**, Optimal replacement algorithm

实现方法：**每次淘汰最长时间内不再被访问的页面。**

优点：**缺页率最低**。

缺点：过于理想，无法实现。

### 3. 最近最久未使用

> **LRU**, Least Recently Used

实现方法：**每次淘汰最近最久未使用的页面**。

优点：性能高。

缺点：**代价很高**。

手写LRU：

```java
public class LRUCache {
    private LinkedHashMap<Integer,Integer> cache;
    private int capacity;   //容量大小

    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    public int get(int key) {
        //缓存中不存在此key，直接返回
        if(!cache.containsKey(key)) {
            return -1;
        }

        int res = cache.get(key);
        cache.remove(key);   //先从链表中删除
        cache.put(key,res);  //再把该节点放到链表末尾处
        return res;
    }

    public void put(int key,int value) {
        if(cache.containsKey(key)) {
            cache.remove(key); //已经存在，在当前链表移除
        }
        if(capacity == cache.size()) {
            //cache已满，删除链表头位置
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        cache.put(key,value);  //插入到链表末尾
    }
}

```

# 五、设备管理

## 磁盘调度算法

### 1. 先来先服务

> FCFS, First Come First Served

按照**磁盘请求的顺序**进行调度。

优点是简单，缺点是平均寻道时间较长。

### 2. 最短寻道时间优先

> SSTF, Shortest Seek Time First

寻找离磁头最近的磁道。

[![img](https://camo.githubusercontent.com/4aaee136900eb1ece1352fa6ca5b92f37e59801a6fcd0a2345afa73ca44fd5b0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67)](https://camo.githubusercontent.com/4aaee136900eb1ece1352fa6ca5b92f37e59801a6fcd0a2345afa73ca44fd5b0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67)



### 3. 扫描

> SCAN

扫描，从一边到另一边

解决了 SSTF 的饥饿问题。

[![img](https://camo.githubusercontent.com/e4956eee145c33a868e367fe6a32eb40465503a4e6a31755ca4fe5a4a83d4019/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67)](https://camo.githubusercontent.com/e4956eee145c33a868e367fe6a32eb40465503a4e6a31755ca4fe5a4a83d4019/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67)

# 六、链接

## 静态链接

静态库生成的链接。

## 动态链接

动态库生成的链接。

## 静态链接和动态链接的区别

**生成可执行文件时，把所有用到的函数全部链接到可执行文件中。**

**生成可执行文件时，不用把所有用到的函数链接到一个可执行文件中。当可执行文件要使用到动态库的时候，程序才会去读取动态库中的函数来使用。**

静态链接在**编译时**链接，动态链接在**运行时**链接。

静态链接更新困难、浪费内存空间，动态链接解决了这两个问题。

## 静态库与动态库

* 静态库：Windows中的.lib，Linux中的.a，在**编译时**被链接。
* 动态库：Windows中的.dll，Linux中的.so，在**运行时**被链接。

