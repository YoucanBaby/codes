[toc]

# 算法基础

## 一、预备知识

### 1. 时间复杂度

主要关注**最坏时间复杂度**。

算法中log级别的时间复杂度都是由于使用了分治思想，这个底数直接由分治的复杂度决定。如果采用二分法,那么就会以2为底数，三分法就会以3为底数，其他亦然。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804014706.png" alt="image-20210804014706738" style="zoom:80%;" />

### 2. 数据的基本存储结构

#### 顺序存储结构

数据存放的**地址是连续的**。**数组**就是顺序存储结构的典型代表。

#### 链式存储结构

数据存放的**地址是连续的**，**也可以是不连续的**。**链表**就是链式存储结构的典型代表。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804114238.png" alt="image-20210804114238273" style="zoom:80%;" />

问题：数据的存储结构有哪些？它们的区别是什么？

回答：顺序存储和链式存储。顺序存储的地址是连续的；链式存储的地址可以是连续的，也可以是不连续的。

## 二、分治和递归

### 1. 递归 Recursion

<img src="https://pic1.zhimg.com/v2-1ad28b5063f58925acfbc5df639f61ec_r.jpg?source=1940ef5c" alt="img" style="zoom: 50%;" />

递归的定义：在本函数中调用本函数。

#### 递归的时间复杂度

递归函数调用的次数 * 递归函数自身的复杂度

#### 递归三步法

**1. 递归函数的输入与输出**

**2. 终止条件**

**3. 单层递归的逻辑**

举个例子：**二叉树的前序遍历**。

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入`list`，除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是 void 。代码如下：

```java
void preorder(TreeNode root, List<Integer> res)
```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：  

```java
if (root == null) {
    return;
}
```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：  

```java
res.add(root.val);
preorder(root.left, res);
preorder(root.right, res);
```

整体代码：

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preorder(root, res);
    return res;
}

public void preorder(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    res.add(root.val);
    preorder(root.left, res);
    preorder(root.right, res);
}
```

### 2. 分治 Partition

分治就是分步骤的递归解决问题。

#### 分治三步法

**Partition**一共分为三步：

​	**1. 划分问题**：把原问题划分为子问题

​	**2. 递归求解**：递归解决子问题

​	**3. 合并问题**：合并子问题的解得到原问题

**归并排序 Merge Sort**

**1. 划分问题**：把数组从中间分为左右两半

**2. 递归求解**：把左右两半的元素分别排序

**3. 合并问题**：把两个数组合并成一个

**快速排序 Quick Sort**

**1. 划分问题**：找到一个基准，根据基准把数组分为左右两部分，使得左边的元素都小于基准，右边的元素都大于基准

**2. 递归求解**：把左右两部分的元素分别排序

**3. 合并问题**：不用合并，因为此时数组已经有序

#### 贪心、分治、动态规划三者区别

|            | 分治       | 动态规划   | 贪心     |
| ---------- | ---------- | ---------- | :------- |
| 适用类型   | 通用       | 优化       | 优化     |
| 子问题     | 每个都不同 | 有很多重复 | 只有一个 |
| 最优子结构 | 没有要求   | 必须满足   | 必须满足 |
| 子问题数   | 全部都要解 | 全部都要解 | 只解一个 |

## 三、排序 Sort

手撕冒泡排序，选择排序，**插入排序**，堆排序，**快速排序**。

|   排序算法   | 平均时间复杂度 | 额外空间复杂度 | 稳定性 |        备注         |
| :----------: | :------------: | :------------: | :----: | :-----------------: |
| **冒泡排序** |   $O(N^{2})$   |     $O(1)$     |  稳定  |                     |
| **选择排序** |   $O(N^{2})$   |     $O(1)$     | 不稳定 |                     |
| **插入排序** |   $O(N^{2})$   |     $O(1)$     |  稳定  |                     |
|   希尔排序   |  $O(N^{1.3})$  |     $O(1)$     | 不稳定 |                     |
|  **堆排序**  |   $O(NlogN)$   |     $O(1)$     | 不稳定 | 下标范围是[1,N - 1] |
| **快速排序** |   $O(NlogN)$   |   $O(log⁡N)$    | 不稳定 |                     |
| **归并排序** |   $O(NlogN)$   |     $O(N)$     |  稳定  |                     |
|    桶排序    |   $O(N + k)$   |     $O(N)$     |  稳定  |     k是桶的个数     |
|   计数排序   |   $O(N + k)$   |     $O(N)$     |  稳定  |     k是桶的个数     |
|   基数排序   |   $O(N + k)$   |     $O(N)$     |  稳定  |     k是桶的个数     |

**稳定性**：数组内两个相等的数，在排序之后，它们的先后位置保持不变。

* 不在乎数据的基础类型，不在乎稳定性，追求常数**时间最优**，使用**快速排序**。
* 追求**最少的额外空间**使用，使用**堆排序**。
* 追求**稳定**，使用**归并排序**。

Java 主要排序方法为 java.util.Arrays.sort()，对于**基本数据类型**使用**三向切分的快速排序**，对于**引用类型**使用**归并排序**。

```java
public class Test <T extends Comparable<T>> {

    public boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }
    
    public boolean less(int v, int w) {
        return v < w;
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### O(N^2^)

#### 1. 冒泡排序 Bubble Sort

把最小的元素往上浮。

```java
public void bubbleSort(int[] nums) {
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[i]) swap(nums, i, j);
        }
    }
}
```

#### 2. 选择排序 Selection Sort

每次选择最小的元素，与开头的元素互换。

```java
private void selectionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[min]) min = j;
        }
        swap(nums, i, min);
    }
}
```

#### 3. 插入排序 Insertion Sort

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/Insertion-sort-example-300px.gif" alt="Insertion-sort-example-300px" style="zoom:80%;" />

将数组划分为左侧有序和右侧无序，每次将当前元素插入到左侧数组中的合适位置。

```java
public void insertionSort(int[] nums) {
    for (int j = 1; j < nums.length; j++) {
        for (int i = j; i >= 1; i--) {
            if (nums[i - 1] < nums[i]) break;
            swap(nums, i - 1, i); 
        }
    }
}
```

### O(N^1.3^)

#### 希尔排序 Shell Sort

希尔排序：每次对间隔为 h 的数组进行插入排序。每次完成插入排序之后，h 变为原来的三分之一，直到 h 等于 1。

h 如何产生：h 从 1 开始算，取不超过 N / 3 的 `3 * h + 1` 

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610022207751.png" alt="image-20210610022207751" style="zoom: 80%;" />

```java
public void shellSort(int[] nums) {
    int N = nums.length;
    int h = 1;
    while (h < N / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int j = h; j < N; j++) {
            for (int i = j; i >= h; i -= h) {
                if (nums[i - h] < nums[i]) break;
                swap(nums, i - h, i);
            }
        }
        h /= 3;
    }
}
```

### O(NlogN)

#### 1. 归并排序 Merge Sort

归并排序也被称为**合并排序**。把数组分为左右两部分，先让左右两部分有序，再让整体有序。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610051726440.png" alt="image-20210610051726440" style="zoom:80%;" />

```java
public void mergeSort(int[] nums, int left, int right) {
    if (left >= right) return;
    int mid = (left + right) / 2;
    mergeSort(nums, left, mid);
    mergeSort(nums, mid + 1, right);
    merge(nums, left, right, mid);
}

private void merge(int[] nums, int left, int right, int mid) {
    int p1 = left;
    int p2 = mid + 1;
    int[] temp = new int[nums.length];
    int i = left;
    while (p1 <= mid && p2 <= right) {
        if (nums[p1] <= nums[p2]) {
            temp[i++] = nums[p1++];
        } else {
            temp[i++] = nums[p2++];
        }
    }
    while (p1 <= mid) {
        temp[i++] = nums[p1++];
    }
    while (p2 <= right) {
        temp[i++] = nums[p2++];
    }
    for (int j = left; j <= right; j++) {
        nums[j] = temp[j];
    }
}
```

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927172840.png" alt="image-20210927172840729" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927172847.png" alt="image-20210927172847685" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927173512.png" alt="image-20210927173512887" style="zoom:67%;" />

思路：归并排序。

在每一次合并数组的时候，如果左边数组的元素 `nums[p1]` > 右边数组的元素 `nums[p2]` ，则结果加上 `mid - p1 + 1`，这个值是左边数组中大于 `nums[p2]` 的个数。

```java
class Solution {
    int count = 0;

    public int reversePairs(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return count;
    }

    public void mergeSort(int[] nums, int left, int right) {
        if (left >= right) return;
        int mid = (left + right) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, right, mid);
    }

    public void merge(int[] nums, int left, int right, int mid) {
        int p1 = left;
        int p2 = mid + 1;
        int[] temp = new int[right - left + 1];
        int i = 0;
        while (p1 <= mid && p2 <= right) {
            if (nums[p1] <= nums[p2]) {
                temp[i++] = nums[p1++];
            } else {
                temp[i++] = nums[p2++];
                count += mid - p1 + 1;
            }
        }
        while (p1 <= mid) {
            temp[i++] = nums[p1++];
        }
        while (p2 <= right) {
            temp[i++] = nums[p2++];
        }
        for (int j = left; j <= right; j++) {
            nums[j] = temp[j - left];
        }
    }
}
```

[315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927175348.png" alt="image-20210927175348172" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927175355.png" alt="image-20210927175355551" style="zoom:80%;" />

思路：

* 维护一个下标数组 `index[i]`，存放该元素 `nums[i]` 在原数组中的下标。
* 维护一个统计右边右侧小于 `nums[i]` 的计数数组`count[index[i]]`，存放该元素 `nums[i]` 在原数组中，下标 `index[i]` 右侧小于 `nums[i]` 的数量。

在每一次合并数组的时候，如果该向排序后的数组 `temp` 中放入左边数组的元素 `nums[p1]` ，则累加上所有比它小的数的数量，即 **`count[index[p1]] += p2 - mid - 1`** 

合并数组结束，最后更新下标数组和值的数组。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927184041.png" alt="image-20210927184041582" style="zoom: 50%;" />

```java
class Solution {

    int[] count;
    int[] index;

    int[] temp;
    int[] tempIndex;

    public List<Integer> countSmaller(int[] nums) {
        int N = nums.length;
        count = new int[N];
        index = new int[N];
        for (int i = 0; i < N; i++) index[i] = i;
        temp = new int[N];
        tempIndex = new int[N];

        mergeSort(nums, 0, N - 1);

        List<Integer> res = new ArrayList<>();
        for (int c : count) res.add(c);
        return res;
    }

    public void mergeSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int mid = (left + right) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, right, mid);
    }

    public void merge(int[] nums, int left, int right, int mid) {
        int p1 = left;
        int p2 = mid + 1;
        int i = left;
        while (p1 <= mid && p2 <= right) {
            if (nums[p1] <= nums[p2]) {
                count[index[p1]] += p2 - mid - 1;
                temp[i] = nums[p1];
                tempIndex[i++] = index[p1++];
            } else {
                temp[i] = nums[p2];
                tempIndex[i++] = index[p2++];
            }
        }
        while (p1 <= mid) {
            count[index[p1]] += p2 - mid - 1;
            temp[i] = nums[p1];
            tempIndex[i++] = index[p1++];
        }
        while (p2 <= right) {
            temp[i] = nums[p2];
            tempIndex[i++] = index[p2++];
        }
        for (int j = left; j <= right; j++) {
            nums[j] = temp[j];
            index[j] = tempIndex[j];
        }
    }
}
```

#### 2. 快速排序 Quick Sort

挑选一个基数坐标，先让整体有序，再考虑左右两边。进行区域划分的时候，选最后一位做为基准数，先从左向右找大于等于基准的数，再从右向左找小于等于基准的数，交换这两个数。最后基准数归位。

```java
public void quickSort(int[] nums, int left, int right) {
    if (left >= right) {
        return;
    }
    // 分区：左边区域比基数小，右边区域比基数大，然后返回基数的下标
    int mid = partition(nums, left, right);
    quickSort(nums, left, mid - 1);
    quickSort(nums, mid + 1, right);
}

private int partition(int[] nums, int left, int right) {
    int p1 = left;
    int p2 = right;
    int pivot = nums[right];    // 选最后一位做为基准数
    while (p1 < p2) {
        while (p1 < p2 && nums[p1] <= pivot) {      // 先从左向右找大于等于基准的数
            p1++;
        }
        while (p1 < p2 && nums[p2] >= pivot) {      // 再从右向左找小于等于基准的数
            p2--;
        }
        swap(nums, p1, p2);     // 交换这这两个数
    }
    swap(nums, p1, right);      // 基准数归位，p1是基准数的位置
    return p1;
}
```

##### 快速选择

关键词：返回第k个最大/最小元素。返回前k个最大/最小元素，返回的元素不要求排序。

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210926153826.png" alt="image-20210926153826790" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210926153836.png" alt="image-20210926153836276" style="zoom:80%;" />

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSort(nums, nums.length - k, 0, nums.length - 1);
    }

    public int quickSort(int[] nums, int k, int left, int right) {
        int mid = patition(nums, k, left, right);
        if (mid == k) {
            return nums[mid];
        } else if (mid < k) {
            return quickSort(nums, k, mid + 1, right);
        } else {
            return quickSort(nums, k, left, mid - 1);
        }
    }

    private int patition(int[] nums, int k, int left, int right) {
        int p1 = left;
        int p2 = right;
        int pivot = nums[right];
        while (p1 < p2) {
            while (p1 < p2 && nums[p1] <= pivot) p1++;
            while (p1 < p2 && nums[p2] >= pivot) p2--;
            swap(nums, p1, p2);
        }
        swap(nums, p1, right);
        return p1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### 3. 堆排序 Heap Sort

<img src="D:\BaiduNetdiskDownload\蓝桥罗召勇-数据结构和算法课件笔记代码\课件\1堆排序.jpg" alt="1堆排序" style="zoom:67%;" />

堆：用数组维护模拟堆。数组从1开始保存元素。

* 从右向左，下沉所有非叶子节点
* 这时候，堆顶元素是最大值，然后交换堆顶元素与最后一个元素，N--，下沉第一个元素

下沉：找出父节点中最大的一个节点，如果最大的节点是父节点，则交换子节点和父节点，递归父节点。保证栈顶最大。这样下次交换的时候，最大的元素就到最末尾了。

```java
public void heapSort(int[] nums) {
    int N = nums.length - 1;
    for (int i = N / 2; i >= 0; i--) {
        down(nums, i, N);
    }
    while (N > 1) {
        swap(nums, 1, N);
        N--;
        down(nums, 1, N);
    }
}

private void down(int[] nums, int i, int N) {
    int max = i;
    if (i * 2 <= N && nums[max] < nums[i * 2]) max = i * 2;
    if (i * 2 + 1 <= N && nums[max] < nums[i * 2 + 1]) max = i * 2 + 1;
    if (max != i) {
        swap(nums, i, max);
        down(nums, max, N);
    }
}
```

堆在 Java 中就是优先队列，优先队列默认小的在前，也就是小根堆。

```java
PriorityQueue<Object> pq = new PriorityQueue<>();
```

**1. 堆**

堆是一颗**完全二叉树**。堆可分为大根堆与**小根堆**。

* 大根堆：堆中父节点总是大于等于其子节点 
* 小根堆：堆中父节点总是小于等于其子节点的值

堆可以用数组来表示。位置 **i** 的节点的**父节点**位置为 **i / 2**，而它的**两个子节点**的位置分别为 **2 * i** 和 **2 * i+1**。（这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系）

以下例子实现的是大根堆。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610030811433.png" alt="image-20210610030811433" style="zoom: 67%;" />

```java
class Heap {
    int N = 0;
    int[] nums = new int[N + 1];
   
    public Heap() {}
    
    public void up(int i) {
        
    }
    
    public void down(int i) {
        
    }
    
    public void insert(int val) {

    } 
    
    public int delMax() {

    }
}
```

**2. 上浮和下沉**

在堆中，当一个节点比父节点小，那么需要交换这个两个节点。交换后还可能比它新的父节点还小，因此需要不断地进行比较和交换操作，把这种操作称为**上浮**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39396435653834652d666332612d343961332d383235392d3864653237343631373735362e676966.gif" alt="68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39396435653834652d666332612d343961332d383235392d3864653237343631373735362e676966" style="zoom:80%;" />

```java
public void up(int i) {
    while (i > 1 && heap[i] < heap[i / 2]) {
        swap(nums, i / 2, i);
        i /= 2;
    }
}
```

类似地，当一个节点比子节点大，需要不断地向下进行比较和交换操作，把这种操作称为**下沉**。一个节点如果有两个子节点，应当与两个子节点中最小那个节点进行交换。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34626635653366622d613238352d343133382d623362362d3738303935366562316466312e676966.gif" alt="68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34626635653366622d613238352d343133382d623362362d3738303935366562316466312e676966" style="zoom:80%;" />

```java
public void down(int[] nums, int i, int N) {
    int max = i;
    if (i * 2 <= N && nums[max] < nums[i * 2]) max = i * 2;
    if (i * 2 + 1 <= N && nums[max] < nums[i * 2 + 1]) max = i * 2 + 1;
    if (max != i) {
        swap(nums, i, max);
        down(nums, max, N);
    }
}
```

**3. 插入元素**

将新元素放到数组末尾，然后对最后一个位置进行上浮。

```java
public void insert(int val) {
    heap[++N] = val;
    up(N);
}
```

**4. 删除最小元素**

从堆的顶端删除最小的元素，并将数组的最后一个元素放到顶端，并下沉这个元素。

```java
public int delMax() {
    int max = heap[1];
    swap(nums, 1, N);
    heap[N--] = Integer.MIN_VALUE;
    down(1);
    return max;
}
```

### O(N + k)

了解原理即可。

#### 1. 桶排序 Bucket Sort

假设输入数据是均匀分布的，不会出现很多数落入同一个桶内的情况。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210610153158780.png" alt="image-20210610153158780" style="zoom: 67%;" />

假设数据在 0 ~ 49 之间，桶以 10 为大小划分，则 0 ~ 9 ... 40 ~ 49 为一个桶，元素在桶中排序。排序之后，再按照桶的顺序，把桶中的元素按照先后次序倒出即可。

#### 2. 计数排序 Count Sort

<img src="D:\BaiduNetdiskDownload\蓝桥罗召勇-数据结构和算法课件笔记代码\课件\1计数排序.jpg" alt="1计数排序" style="zoom: 50%;" />

先找到数组的最小值和最大值。数组长度是最大值-最小值+1。然后统计数组中数字的出现次数。最后枚举频率数组，只要当前下标对应的频率不为0，就把这个下标+最小值覆盖到原数组上。

```java
public void countSort(int[] nums) {
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    for (int num : nums) {
        min = Math.min(min, num);
        max = Math.max(max, num);
    }
    int N = max - min + 1;
    int[] freq = new int[N];
    for (int num : nums) {
        freq[num - min]++;
    }
    int index = 0;
    for (int i = 0; i < freq.length; i++) {
        while (freq[i] > 0) {
            nums[index++] = min + i;
            freq[i]--;
        }
    }
}
```

[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928125919.png" alt="image-20210928125919913" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928125926.png" alt="image-20210928125926763" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928125950.png" alt="image-20210928125949949" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928130001.png" alt="image-20210928130001882" style="zoom:80%;" />

思路：计数排序。

* 使用哈希表，统计每个元素出现的次数，**<元素，元素出现的频率>**
* 将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
* 倒序遍历数组获取出现顺序从大到小的排列，注意只要k个

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    int N = nums.length;
    List[] list = new ArrayList[N + 1];
    for (int key : map.keySet()) {
        int freq = map.get(key);
        if (list[freq] == null) list[freq] = new ArrayList();
        list[freq].add(key);
    }

    List<Integer> res = new ArrayList<>();
    for (int i = N; i >= 0; i--) {
        if (list[i] == null) continue;
        res.addAll(list[i]);
        if (res.size() >= k) break;
    }

    int[] ret = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        ret[i] = res.get(i);
    }
    return ret;
}
```

#### 3. 基数排序 Radix Sort

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/1基数排序.jpg" alt="1基数排序" style="zoom: 50%;" />

以最大值是三位数的数组为例，准备10个桶，分别对应 0~9。首先根据个位数决定当前元素进哪个桶，对每个桶里的元素进行排序；再以十位数决定当前元素进哪个桶，对每个桶里的元素进行排序；最后以百位数决定当前元素进哪个桶，对每个桶里的元素进行排序。最后返回排序好的结果。

## 四、查找 Search

### 二分查找 Binary Search

#### 模板

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = ...;
    
    while (left < right) {
        int mid =  (left + right) / 2;      // mid向下取整，是左边数组的最后一位
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {	// 舍弃所有右边的值
            left = mid + 1;
        } else if (nums[mid] > target) {	// 舍弃所有左边的值
            right = mid;
        }
    }
    return ...
}
```

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = ...;
    
    while (left <= right) {
        int mid =  (left + right) / 2;      // mid向下取整，是左边数组的最后一位
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {	// 舍弃所有左边的值（包括mid）
            left = mid + 1;
        } else if (nums[mid] > target) {	// 舍弃所有右边的值（包括mid）
            right = mid - 1;
        }
    }
    return ...
}
```

找目标值

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid =  (left + right) / 2;
        if (nums[mid] == target ) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

#### 找左侧插入位置

即 `nums` 中小于 `target` 的个数，比如 `nums = {1,2,2,2,4,5}; target = 2` ，则返回 `1`。

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid =  (left + right) / 2;
        if (nums[mid] == target) {
            right = mid - 1;					// 抛弃右侧解空间
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return left;
}
```

#### 找满足条件的最小值

[875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928174040.png" alt="image-20210928174040888" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928175331.png" alt="image-20210928175331766" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928175345.png" alt="image-20210928175344955" style="zoom:80%;" />

思路：找能吃完的最小速度 `i` ，时间：$O(NlogM)$，N 是香蕉堆的数量，M 是香蕉堆的最大大小。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210928175423.png" alt="image-20210928175423631" style="zoom: 50%;" />

```java
public int minEatingSpeed(int[] piles, int H) {
    int left = 0;
    int right = (int) 1e9;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (getTime(piles, mid) <= H) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

private int getTime(int[] piles, int mid) {
    int time = 0;
    for (int pile : piles) {
        time += Math.ceil((double) pile / mid);
    }
    return time;
}
```

#### 找右侧插入位置

即 `nums` 中小于等于 `target` 的个数，比如 `nums = {1,2,2,2,4,5}; target = 2` ，则返回 `4`

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid =  (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1;						// 抛弃左侧解空间
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return left;
}
```

除了二分查找以外还有几种查找：

| 查找           | 平均时间复杂度 | 用于                                               |
| -------------- | -------------- | -------------------------------------------------- |
| 顺序查找       | $O(N)$         | 链表                                               |
| 二分查找       | $O(logN)$      | 有序数组                                           |
| 分块查找       | $O(logN)$      |                                                    |
| 二叉搜索树查找 | $O(logN)$      | 二叉搜索树，但是二叉搜索树可能会退化为链表         |
| 红黑树查找     | $O(logN)$      | Java的哈希表底层                                   |
| 哈希查找       | $O(1)$         | Java的哈希表，底层对红黑树做了优化，优化到了$O(1)$ |

### 其他

#### 1. 顺序查找

定义：从头到尾扫描一遍。

#### 2. 哈希查找 Hash Search

哈希表采用哈希查找：

* JDK 7，结构基于**数组+链表**实现，使用**拉链法**解决哈希冲突。
* JDK 8，结构基于数组+链表实现，使用拉链法解决哈希冲突。但当数组中某个链表长度超过 8 时，会将链表转换为红黑树。

哈希冲突：有两个不相等的值，它们通过哈希函数之后，得到的哈希值是一样的

哈希函数：选取一个素数作为哈希函数的base，一般取**769**，因为769的错误率小，并且值小。哈希函数就是这个数模上base。

拉链法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。

哈希扩容：在 Java 中，默认已使用数组的个数超过数组长度的 75%，就把数组扩容到原来的两倍。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210625160107389.png" alt="image-20210625160107389" style="zoom:80%;" />

[705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210919122246.png" style="zoom:80%;" />

本题的具体做法：维护一个链表数组。想要添加元素，枚举哈希值所在的链表，看该链表是否已经有这个值了，有的话，就不添加；反之，添加到末尾。想要删除的话，也要枚举哈希值所在的链表，找到值所在的位置，删除。判断是否存在这个值，也要枚举哈希值所在的链表。

```java
class MyHashSet {

    static int BASE = 769;
    LinkedList[] data = new LinkedList[BASE];;

    public MyHashSet() {
        for (int i = 0; i < data.length; i++) {
            data[i] = new LinkedList<Integer>();
        }
    }

    public void add(int key) {
        int h = hash(key);
        for (int num : (LinkedList<Integer>) data[h]) {
            if (num == key) return;
        }
        data[h].addLast(key);
    }

    public void remove(int key) {
        int h = hash(key);
        int index = 0;
        for (int num : (LinkedList<Integer>) data[h]) {
            if (num == key) {
                data[h].remove(index);
                return;
            }
            index++;
        }
    }

    public boolean contains(int key) {
        int h = hash(key);
        for (int num : (LinkedList<Integer>) data[h]) {
            if (num == key) return true;
        }
        return false;
    }

    private static int hash(int key) {
        return key % BASE;
    }
}
```

#### 3. 分块查找

首先找到待查数字所在的块，然后在块内顺序查找，直到找出该数字。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513212127903.png" alt="image-20210513212127903" style="zoom:50%;" />

# 数据结构

计算机能执行 $10^{9}$ 段代码。

数据结构是一种用来保存数据的工具，算法是如何去更高效的使用这些工具。

## 二、数据结构

### 1. 数组 Array

静态数组和动态数组的区别：静态数组在实例化时，长度已经固定；动态数组的长度是可变的。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804102343.png" alt="image-20210804102343021" style="zoom: 50%;" />

链表的查询时间是 $O(N)$，哈希集合的查询时间是 $O(1)$。

#### 静态数组 Array

```java
int[] arr = new int[10];
```

##### Arrays API

```java
/*
    nums1 = Arrays.copyOf(nums, 0, nums.length);
    Arrays.sort(nums);							// Arrays.sort(arr, new Comparator<>() {});
    Arrays.binarySearch(nums, 0, nums.length, 要查的数字);		// 找不到返回-1
    Arrays.fill(nums, 要填充的数字);
    Arrays.equals(nums, nums1);
    Arrays.asList(nums);
    Arrays.toString(nums);
*/
```

**System API**

```java
// 把源数组src复制给目标数组dst
System.arraycopy(Object src, int srcPos,
                 Object dst, int dstPos,
                 int length);
```

#### 动态数组 ArrayList

```java
List<Object> list = new ArrayList<>();
```

增查 $O(1)$，**删 **$O(n)$

```java
/*	ArrayList 刷题常用方法：
		增：add(E e)
		删：remove(int index) / remove(Object o)
		改：set(int index, E e)
		查：get(int index) 
		插：add(int index, E e)
		遍历：Iterator / foreach / for
		转数组：toArray() / toArray(T[] t)
*/
```

#### 数组的表达形式

##### 前缀和数组

**优化空间**：某些前缀和数组，可用一个变量（**前缀和**）来表示。

**前缀和**算法 和 **滑动窗口**会经常用在求**子数组和子串问题**上。

前缀和其实我们很早之前就了解过的，我们求数列的和时，Sn = a1 + a2 + a3 + ... an; 此时 Sn 就是数列的前 n 项和。例如 S5 = a1 + a2 + a3 + a4 + a5;  S2 = a1 + a2。所以我们完全可以通过 S5 - S2 得到 a3 + a4 + a5 的值，

<img src="https://pic.leetcode-cn.com/1610773274-UhkZUS-file_1610773273683" alt="前缀和" style="zoom: 50%;" />

```java
// 前缀和数组
public void preSum(int[] nums) {
    int N = nums.length;
    int[] preSum = new int [N + 1];

    for (int i = 0; i < N; i++) {
        preSum[i + 1] = preSum[i] + nums[i];
    }
}
```

```java
// 前缀和 + 哈希表
public void preSum(int[] nums) {
    Map<Integer, Integer> preSum = new HashMap<>();
    preSum.put(0, 1);
    int sum = 0;

    for (int num: nums) {
        sum += num;
        preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
    }
}
```

**稀疏数组**

稀疏数组的第一行存储原始数组的行、列、非0值的个数。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210201100847419.png" alt="image-20210201100847419" style="zoom:67%;" />

##### 一维数组和二维数组之间的转换

**1. 二维数组转一维数组**

​	假设二维数组大小为 M*N

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710100810.png" alt="png" style="zoom: 80%;" />

**2. 一维数组转二维数组**

​	假设二维数组大小为 M*N，一维数组的位置为 k

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710101045.png" alt="png (1)" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710101102.png" alt="png (2)" style="zoom:80%;" />

### 2. 链表 LinkedList

单链表，双链表，循环链表。

```java
class ListNode {
    int val;
    ListNode next;

    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next;}
}
```

链表 API：

```java
List<Integer> list = new LinkedList<>();
```

### 3. 栈 Stack

栈和队列都建议使用ArrayDeque，速度要比ArrayList快！

```java
Deque<Object> stack = new ArrayDeque<>();

stack.push(E item);		// 入栈：向栈顶添加元素
stack.pop();			// 出栈：移除栈顶元素，并返回值
stack.peek();			// 查看栈顶元素
stack.isEmpty();		// 栈是否为空
```

```java
// 遍历栈
while (!stack.isEmpty()) {
            
}
```

#### 单调栈

```java
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < N; i ++) {
    while (!stack.isEmpty() && nums[i] 比较 nums[stack.peek()]) {
        stack.pop();
	}
    stack.push(i);
}
```

### 4. 队列 Queue

#### 双端队列 Deque

Deque 是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中ArrayDeque 速度最快。

**Deque的三种用途：**

- 普通队列 (一端进另一端出):
  `Queue<Object> queue = new ArrayDeque<>();`或`Deque<Object> deque = new ArrayDeque<>();`
- **双端队列** (**两端都可进出**)
  `Deque<Object> deque = new ArrayDeque<>();`
- 栈
  `Deque<Object> stack = new ArrayDeque<>();`

Deque 可以使用 Stack 和 Queue 中的方法，也有自带的方法，下表总结了 Deque 的 12 种方法：

|          | **第一个元素 (头部)** | 第一个元素（头部） | 最后一个元素 (尾部) | **最后一个元素 (尾部)** |
| -------- | :-------------------: | :----------------: | :-----------------: | :---------------------: |
|          |      *抛出异常*       |      *特殊值*      |     *抛出异常*      |        *特殊值*         |
| **插入** |      addFirst(e)      |   offerFirst(e)    |     addLast(e)      |      offerLast(e)       |
| **删除** |     removeFirst()     |    pollFirst()     |    removeLast()     |       pollLast()        |
| **检查** |      getFirst()       |    peekFirst()     |      getLast()      |       peekLast()        |

| 队列方法  | **等效Deque方法** |
| :-------: | :---------------: |
|  add(e)   |    addLast(e)     |
| offer(e)  |   offerLast(e)    |
| remove()  |   removeFirst()   |
|  poll()   |    pollFirst()    |
| element() |    getFirst()     |
|  peek()   |    peekFirst()    |

| **堆栈方法** | **等效Deque方法** |
| :----------: | :---------------: |
|   push(e)    |    addFirst(e)    |
|    pop()     |   removeFirst()   |
|    peek()    |    peekFirst()    |

```java
// 遍历双端队列
while (!deque.isEmpty()) {
            
}
```

#### **优先队列 PriorityQueue**

优先队列（小顶堆），内部自动按大小排序，小的在队首（左边），大的在队尾（右边）。可用比较器，修改排序方式。

```java
// 优先队列，内部自动按大小排序，小的在队首（左边），大的在队尾（右边）
// 优先队列是单端队列
PriorityQueue<Object> pq = new PriorityQueue<>();

pq.add(E e);			// pq.offer(E e);   add抛出异常，offer返回特殊值
pq.clear();
pq.contains(Object o);
pq.peek();			// 查看队首元素，即最左边的值
pq.poll();			// 移除队首元素，并返回值，		pq.remove();	poll抛出异常，remove返回特殊值
pq.size();
pq.toArray();
```

```java
// 优先队列，使用 Comparator，实现逆序排序
PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
    	return o2 - o1;
    }
});
```

### 5. 哈希表 Map/set

#### HashMap / TreeMap

```java
/*	HashMap常用方法：
		增：put(K key, V value)
		删：remove(Object key) / remove(Object key, Object value) 
		改：replace(K key, V value) / replace(K key, V oldValue, V newValue) 
		查：get(Object key) / getOrDefault(Object key, V defaultValue) 
*/

```

**HashMap / TreeMap** 属于 **Map API**

```java
/*	Map 通用方法：
		清除：clear()
		包含：containsKey(Object key) / containsValue(Object value) 
		Entry：entrySet() 
		key：keySet() 
		value：values() 
		非空：isEmpty()
		长度：size() 
		转数组：toArray()
		相等：equals(Object o)
		哈希值：hashCode()
*/
```

#### HashSet / TreeSet

```java
/*	HashSet 刷题常用方法：
		增：add(E e)
		删：remove(Object o)
		遍历：Iterator / foreach
*/
```

**HashSet / TreeSet** 属于 **Collection API**

```java
/*	Collection 通用方法：
		清除：clear()
		包含：contains()
		非空：isEmpty()
		长度：size() 
		转数组：toArray()
		相等：equals(Object o)
		哈希值：hashCode()
*/
```

##### Collections API

数组的工具类是 Arrays

Collection 和 Map 的工具类是 Collections

```java
/* Collections：
		binarySearch(List, Object)		// 二分查找，返回List下标
		reverse(List)
		shuffle(List)						// 随机打乱
		sort(List)
		sort(List, Comparator)
		swap(List, i, j)					// 交换List中i和j的值
*/
```

```java
/* Collections：
		Object max(Collection)
		Object max(Collection, Comparator)
		Object min(Collection)
		Object min(Collection, Comparator)
		int frequency(Collection, Object)
*/
```

### 6. 二叉树 BinaryTree



### 7. 图 Graph



### 8. 并查集 Union-find Set



### 9. 前缀树 Trie Tree

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210713095850.png" alt="image-20210713095850233" style="zoom: 67%;" />

**前缀树的节点**：

```java
class TrieNode {
    int pass;       // 有多少个字符串经过这个节点
    int end;        // 是多少个字符串的结尾节点
    TrieNode[] nexts;

    TrieNode() {
        pass = 0;
        end = 0;
        nexts = new TrieNode[26];   // 一共有26个小写字母
    }
}
```

**前缀树的增删查**：

```java
    class Trie {
        TrieNode root;

        Trie() {
            root = new TrieNode();
        }

        // 增
        public void insert(String word) {
            // 处理特殊情况
            if (word == null) {
                return;
            }
            // 更新节点
            TrieNode node = root;
            node.pass++;
            // 遍历字符串，沿途节点的pass++，末端节点的end++
            for (char c : word.toCharArray()) {
                int index = c - 'a';
                // 如果后续没有节点，则新建节点
                if (node.nexts[index] == null) {
                    node.nexts[index] = new TrieNode();
                }
                node = node.nexts[index];
                node.pass++;
            }
            node.end++;
        }

        // 删
        public void delete(String word) {
            // 处理特殊情况，如果没有word
            if (search(word) == 0) {
                return;
            }
            // 更新节点
            TrieNode node = root;
            node.pass--;
            // 遍历字符串，沿途节点的pass--，末端节点的end--
            for (char c : word.toCharArray()) {
                int index = c - 'a';
                node.nexts[index].pass--;
                // 如果后续节点的pass为0，则置空
                if (node.nexts[index].pass == 0) {
                    node.nexts[index] = null;
                    return;
                }
                node = node.nexts[index];
            }
            node.end--;
        }

        // 查：word这个单词加入过几次
        public int search(String word) {
            // 处理特殊情况
            if (word == null) {
                return 0;
            }
            // 节点
            TrieNode node = root;
            // 遍历字符串，返回末端节点的end
            for (char c : word.toCharArray()) {
                int index = c - 'a';
                // 如果没有这个节点
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            // 返回末端节点的end
            return node.end;
        }

        // 查：所有加入的字符串中，有几个是以pre这个字符串作为前缀的
        public int prefixNumber(String pre) {
            // 处理特殊情况
            if (pre == null) {
                return 0;
            }
            // 节点
            TrieNode node = root;
            // 遍历字符串，返回pre末端节点的pass
            for (char c : pre.toCharArray()) {
                int index = c - 'a';
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.pass;
        }
    }
```



## 三、字符串 String

### String API

```java
char charAt(int index)
char[] toCharArray() 
boolean equals(Object other)
int indexOf(String str)
int lastIndexOf(String str)
int length()
String substring(int beginIndex, int endIndex)		// [beginIndex, endIndex)
String valueOf(int i)
```

### 字符串的普通匹配算法

#### 1. 暴力匹配

#### 2. 双指针

#### 3. 快慢指针

#### 4. 滑动窗口

### KMP

KMP是三个作者的首字母。

题目：假设 `s = "abaababc"`，`t = "ababc"`，返回 `s` 中 `t` 出现的第一个下标

思路：KMP先要求短字符串的`next`数组，再进行匹配。

#### next数组的构造方法

构造方法为：**`next[i]` 对应的下标，为 `t[0...i - 1]` 的最长公共前缀后缀的长度，令 `t[0] = -1`，`t[1] = 0`。** 具体解释如下：

例如对于字符串 `abab`：

- 前缀：它的前缀包括：`a, ab, aba`，不包括 `abab`；
- 后缀：它的后缀包括：`bab, ab, b, `，不包括 `abab`；
- 最长公共前缀后缀：`abab` 的前缀和后缀中只有 `ab` 是公共部分，字符串 `ab` 的长度为 `2`。

所以，我们将 `t[0...i - 1]` 的最长公共前后缀的长度作为 `next[i]` 的下标，就得到了 `next` 数组。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210925200634.png" alt="image-20210925200634726" style="zoom:80%;" />

#### 匹配

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210925201720.png" alt="image-20210925201720392" style="zoom: 50%;" />

先匹配前几个字符，然后 `s[3] != t[3]`，所以接下来 `s[3]` 要和 `t[1]` 匹配。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210925201936.png" alt="image-20210925201936877" style="zoom:50%;" />

然后 `s[3] != t[1]`，所以接下来 `s[3]` 和 `t[0]` 匹配。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210925202117.png" alt="image-20210925202117034" style="zoom:50%;" />

直到最后匹配成功，返回 `s` 中的下标 `3` 。

### 马拉车

### 前缀树 Trie

举个例子：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210926065812.png" alt="image-20210926065812142" style="zoom: 50%;" />

用二维数组实现前缀树。

* 用二维数组 `trie` 存放当前节点的下一层的节点
* 一维数组 `count` 记录以当前节点结尾的单词数量
* `index` 是总结点个数，也用于对节点进行编号

操作：

* 插入：枚举字符串，如果当前字母没有我们要找的下一个字母，则新建下一个字母。最后一个字母上的叶子节点个数++
* 搜索：枚举字符串，如果当前字母没有我们要找的下一个字母，则返回 false。最后判断最后一个字母上的叶子节点个数是否为0，不为0，则说明有这个单词
* 搜索前缀：枚举字符串，如果当前字母没有我们要找的下一个字母，则返回 false。最后返回true

```java
class Trie {

    int N = (int) 1e5;
    int[][] trie = new int[N][26];      // 前缀树
    int[] count = new int[N];           // 叶子节点个数（单词个数）
    int index = 1;                      // 总节点个数，0是根节点，也是空节点

    public Trie() {}

    public void insert(String s) {
        int p = 0;
        for (int i = 0; i < s.length(); i++) {
            int c = s.charAt(i) - 'a';
            if (trie[p][c] == 0) trie[p][c] = index++;
            p = trie[p][c];
        }
        count[p]++;
    }

    public boolean search(String s) {
        int p = 0;
        for (int i = 0; i < s.length(); i++) {
            int c = s.charAt(i) - 'a';
            if (trie[p][c] == 0) return false;
            p = trie[p][c];
        }
        return count[p] != 0;
    }

    public boolean startsWith(String s) {
        int p = 0;
        for (int i = 0; i < s.length(); i++) {
            int c = s.charAt(i) - 'a';
            if (trie[p][c] == 0) return false;
            p = trie[p][c];
        }
        return true;
    }
}
```

# 搜索与图论

## 二叉树 Binary Tree

### 1. 二叉树的预备知识

根节点：root

父节点：

子节点：

叶子节点：没有子节点的节点。

节点的权：节点值。

节点的度：子节点的个数。

节点的深度：从上向下算，根节点的深度为1，下面每有一层深度就+1。

节点的高度：从下向上算。

节点的路径：从根节点到该节点的最短路线。

### 2. 二叉树定义

**二叉树** 是一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513094624655.png" alt="image-20210513094624655" style="zoom: 67%;" />

**二叉树的定义**：

```java
public class TreeNode {

    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() { }

    TreeNode(int val) { this.val = val; }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 3. DFS

* 二叉树的**深度优先搜索** (**DFS**, Depth First Search)：**前序、中序、后序遍历**
  * **前序**遍历：**根左右**
  * **中序**遍历：**左根右**
  * **后序**遍历：**左右根**

DFS递归模板：

```java
void dfs(TreeNode root) {
    // 前序遍历
    dfs(root.left)
    // 中序遍历
    dfs(root.right)
    // 后序遍历
}
```

#### 前序遍历

思路1：递归

```java
List<Integer> res = new ArrayList<>();

public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) return res;
    res.add(root.val);
    preorderTraversal(root.left);
    preorderTraversal(root.right);
    return res;
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入左节点，如果左节点非空的话
    * 加入中节点，加入 null
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```java
public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.addFirst(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.removeFirst();
        if (node != null) {
            if (node.right != null) {       // 右
                stack.addFirst(node.right);
            }
            if (node.left != null) {        // 左
                stack.addFirst(node.left);
            }
            stack.addFirst(node);           // 中
            stack.addFirst(null);
        } else {
            node = stack.removeFirst();
            res.add(node.val);
        }
    }

    return res;
}
```

#### 中序遍历

思路1：递归。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    inorder(root, res);
    return res;
}

public void inorder(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    inorder(root.left, res);
    res.add(root.val);
    inorder(root.right, res);
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入中节点，加入 null
    * 加入左节点，如果左节点非空的话
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```java
public List<Integer> inorderTraversal(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.addFirst(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.removeFirst();
        if (node != null) {
            if (node.right != null) {
                stack.addFirst(node.right);     // 右
            }
            stack.addFirst(node);               // 中
            stack.addFirst(null);
            if (node.left != null) {
                stack.addFirst(node.left);      // 左
            }
        } else {
            node = stack.removeFirst();
            res.add(node.val);
        }
    }

    return res;
}
```

#### 后序遍历

思路1：递归。

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    postorder(root, res);
    return res;
}

public void postorder(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    postorder(root.left, res);
    postorder(root.right, res);
    res.add(root.val);
}
```

思路2：迭代。

* 创建结果集 `res`，创建栈 `stack`，把头节点加入栈。栈需要使用 `LinkedList`，`LinkedList` 能加入 null
* 栈非空：
  * 栈顶节点 `node` 出栈
  * 如果 `node` 非空：
    * 加入右节点，如果右节点非空的话
    * 加入左节点，如果左节点非空的话
    * 加入中节点，加入 null
  * 如果 `node` 是空：
    * 栈顶节点 `node` 出栈，刚刚出栈的是空，现在肯定不是空
    * 把 `node` 加入结果集
* 返回 `res`

```java
public List<Integer> inorderTraversal(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.addFirst(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.removeFirst();
        if (node != null) {
            stack.addFirst(node);               // 中
            stack.addFirst(null);
            if (node.right != null) {
                stack.addFirst(node.right);     // 右
            }
            if (node.left != null) {
                stack.addFirst(node.left);      // 左
            }
        } else {
            node = stack.removeFirst();
            res.add(node.val);
        }
    }

    return res;
}
```

----

#### 已知两个遍历，求另一个遍历

先根据已知的遍历，把二叉树给画出来。

**已知前序和中序，求后序遍历：**

* 前序遍历：ABCDEF

* 中序遍历：CBDAEF

前序遍历的第一个位置一定是根节点，所以A是根节点。根据中序遍历确定，CBD在左边，EF在右边。再根据前序遍历，判断各自的位置。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210617190127875.png" alt="image-20210617190127875" style="zoom: 33%;" />

**已知中序和后序，求前序遍历：**

* 中序遍历：CBDAEF

* 后序遍历：CDBFEA

后序遍历的最后一个位置一定是根节点，所以A是根节点。根据中序遍历确定，CBD在左边，EF在右边。再根据后序遍历，判断各自的位置。

**已知前序和后序，求中序遍历：**

* 前序遍历：ABCDEF

* 后序遍历：CDBFEA

已知前序、后序遍历无法求出中序遍历，因为由前序后序重构出来的二叉树不止一种。

---

### 4. BFS

二叉树的**宽度优先搜索** (**BFS**, Breadth First Search)：**层序遍历**

#### 层序遍历

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513140421151.png" alt="image-20210513140421151" style="zoom: 50%;" />

```java
public List<Integer> bfs (TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);

    while (!deque.isEmpty()) {
        TreeNode node = deque.removeFirst();
        res.add(node.val);
        if (node.left != null) {
            deque.addFirst(node.left);
        }
        if (node.right != null) {
            deque.addFirst(node.right);
        }
    }

    return res;
}
```

#### 层序遍历Ⅱ

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    List<List<Integer>> res = new ArrayList<>();
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addLast(root);

    while (!deque.isEmpty()) {
        int N = deque.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < N; i++) {
            root = deque.removeFirst();
            level.add(root.val);
            if (root.left != null) {
                deque.addLast(root.left);
            }
            if (root.right != null) {
                deque.addLast(root.right);
            }
        }
        res.add(0, level);
    }

    return res;
}
```

#### [BFS: 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

### 5. 二叉树的构造

#### **完全二叉树**

最后一层的右边缺少部分结点，其余每一层上的结点数均达到最大值。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210714180240.png" alt="image-20210714180240299" style="zoom:80%;" />

**堆**（**优先队列**）就是一个**完全二叉树**。优先队列的**正序**和**倒序**分别对应**小根堆**和**大根堆**。

判断一个树是完全二叉树？

* 思路：宽度优先遍历
  1. 任意节点，有右无左false。
  2. 在保证1的情况下，如果遇到了一个节点左右子树不全，需要保证后序节点都是叶结点。

```java
public boolean isValidCBT(TreeNode root) {
    if (root == null) {
        return true;
    }

    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.addFirst(root);
    // 判断是否遇到一个节点左右子树不全，即后序的节点都要是叶结点
    boolean isLeft = false;

    while (!deque.isEmpty()) {
        root= deque.removeLast();
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 任意节点，有右无左false。
        if (left != null && right == null) {
            return false;
        }
        // 如果遇到了一个节点左右子树不全，需要保证后序节点都是叶结点。
        if (isLeft) {
            if (left == null || right == null) {
                return false;
            }
        }

        if (left != null) {
            deque.addFirst(left);
        }
        if (right != null) {
            deque.addFirst(right);
        }

        // 如果遇到了一个节点左右子树不全，需要保证后序节点都是叶结点。
        if (left == null || right == null) {
            isLeft = true;
        }
    }
    return true;
}
```

**计算完全二叉树的节点个数**：

思路：后序遍历

```java
public int countNodes(TreeNode root) {
    // 终止条件
    if (root == null) {
        return 0;
    }

    // 递归左子树
    int leftNode = countNodes(root.left);
    // 递归右子树
    int rightNode = countNodes(root.right);

    // 返回值
    return leftNode + rightNode + 1;
}
```

#### **满二叉树**

所有的叶子节点都在最后一层，并且`节点总数 = 2^n - 1`，n是二叉树的深度。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210514170516899.png" alt="image-20210514170516899" style="zoom:67%;" />

**判断是否为满二叉树？**

思路：是否满足`节点总数 = 2^深度 - 1`

* 计算二叉树的深度
* 计算节点总数

```java
public class isValidFBT {
    
    // 二叉树节点个数
    int num = 0;

    public boolean isValidFBT(TreeNode root) {
        if (root == null) {
            return true;
        }
		
        // 计算深度
        int depth = maxDepth(root);
        // 计算节点个数
        countNum(root);

        return depth == (1 << num - 1);
    }

    public void countNum(TreeNode root) {
        if (root == null) {
            return;
        }

        countNum(root.left);
        countNum(root.right);
        num++;
    }

    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);

        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

#### 线索二叉树（树状数组）

* 中序线索二叉树

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210625210944616.png" alt="image-20210625210944616" style="zoom:80%;" />

绿色的线条代表原来二叉树的下一个节点。蓝色的箭头指向中序遍历中，当前节点的上一个or下一个节点。

中序线索二叉树结点的结构：左节点，左 tag，data，右 tag，右节点。左右tag 代表是否有 左右节点。

```java
public class Node {

    int data;
    Node left;
    Node right;
    
    boolean leftTag = false;        // true代表有左节点，false代表无
    boolean rightTag = false;

    public Node() {
    }

    public Node(int data) {
        this.data = data;
    }

    public Node(int data, Node left, Node right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

```

* 先序线索二叉树
* 后序线索二叉树

#### 哈夫曼树 Huffman Tree

定义：**带权路径长度**（WPL）**最小的二叉树**。

叶结点的带权路径长度：从树的根到该结点的路径长度 * 该结点的权值

树的带权路长度：所有叶结点的带权路径长度

Eg: a: 1，b: 2，c: 2，d: 3，e: 7 构造哈夫曼树，算出 WPL，写出每个字母的哈夫曼编码（左0右1）

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513193244096.png" alt="image-20210513193244096" style="zoom: 67%;" />

WPL = 7 * 1 + 3 * 2 + 2 * 3 + 1 * 4 + 2 * 4 = 31

a: 1110

b: 1111

c: 110

d: 10

e: 0

#### 前缀树 Trie Tree

又称字典树，查找树。



## 五、二叉搜索树 Binary Search Tree

### 1. 二叉搜索树

**BST**，Binary Search Tree。

数据结构：左子树 < 当前节点 < 右子树，不会出现相等的节点。

优点：中序遍历是严格单调递增的序列。

缺点：可能会退化为链表，会导致查找的时间为O(N)。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210516143555407.png" alt="image-20210516143555407" style="zoom: 80%;" />

* 判断一棵树是否是二叉查找树？

  DFS中序遍历。全局变量保存上次处理的节点，如果上次处理的节点值比当前节点的值大，那就不是二叉搜索树。

```java
class Solution {
    TreeNode pre = null;

    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }

        if (!isValidBST(root.left)) {
            return false;
        }

        if (pre != null && pre.val >= root.val) {
            return false;
        }
        pre = root;

        return isValidBST(root.right);
    }
}
```

### 2. 平衡二叉搜索树

平衡二叉树的常用实现方法有：**AVL树**，红黑树，替罪羊树、Treap，伸展树。

#### **AVL树**

数据结构：**每个节点的左右子树的深度之差不超过 1** 的 **二叉搜索树**。

进行插入会破坏 AVL树 的平衡，旋转可以恢复 AVL树 的平衡，旋转分为单旋转和双旋转。

结点的平衡因子：左子树高 - 右子树高，平衡因子只能是 -1、0、1 。

先找“最小不平衡子树”。

**单旋转**：插入发生在“外边”的情况，即对a的左儿子的左子树进行插入，或对a的右儿子的右子树进行插入。

* 左左：对“最小不平衡子树”进行**左旋转**
* 右右：对“最小不平衡子树”进行**右旋转**

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513152843257.png" alt="image-20210513152843257" style="zoom: 50%;" />

**双旋转**：插入发生在“内部”的情况，即对a的左儿子的右子树进行插入，或对a的右儿子的左子树进行插入。

* 左右：先左旋转后右旋转，先对“最小不平衡子树”的**根的下一级**进行**左旋转**，再对“最小不平衡子树”的**根**进行**右旋转**。
* 右左：先右旋转后左旋转，先对“最小不平衡子树”的**根的下一级**进行**右旋转**，再对“最小不平衡子树”的**根**进行**左旋转**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513190203081.png" alt="image-20210513190203081" style="zoom:50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210513155620317.png" alt="image-20210513155620317" style="zoom:50%;" />

#### 红黑树

数据结构：

1. 每个节点要么是**黑色**，要么是**红色**
2. **根节点是黑色**
3. 每个叶子节点都是黑色的空节点，也就是说，**叶子节点不存储数据**
4. 任何相邻的节点都不能同时为红色，也就是说，**红色节点是被黑色节点隔开的**
5. **最长路径长度 <= 最短路径长度 * 2**

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210514193338301.png" alt="image-20210514193338301" style="zoom: 33%;" />

#### AVL树和红黑树的区别

1. AVL树 比 红黑树 更加平衡，但AVL树在插入和删除的时候会存在大量的旋转操作。所以存在大量的插入和删除操作，选择 红黑树；存在大量的查找操作，选择 AVL树。
2. AVL 树：插入最多旋转一次（单旋转or双旋转），删除最多 logN 次
   红黑树：插入最多二次，删除最多三次
3. AVL 树：插入 旋转量级 O(1)，删除 旋转量级 O(logN)
   红黑树：插入 旋转量级 O(1)，删除 旋转量级 O(1)

### 3. 多叉树

**2 - 3 树**

定义：3 阶 B树。

**2 - 3 - 4 树**

定义：4 阶 B树

### 4. B 树

B树 又称 多路平衡查找树，

m 阶 B树 的数据结构：

1. 1 <= 根节点的index数 <= m - 1
2. ceil(m/2) - 1<= 非根节点的index数 <= m - 1
3. **所有的叶子节点高度都相同**。
4. 节点有m个子树，就对应有m-1个index
5. 每个节点中的index都按照从小到大的顺序排列，每个index的左子树中的所有index都小于等于它，而右子树中的所有index都大于等于它

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210514152143526.png" alt="image-20210514152143526" style="zoom:80%;" />

上图是4阶的B树，也就是 2-3-4树。

### 5. B + 树

m 阶 B+树 的数据结构：

1. 在B树的基础上做了优化
2. 节点有m个子树，就对应有m个index
3. 非叶子节点仅具有索引作用，不包含data，data均存放在叶子节点中。
4. 所有叶子节点构成一个有序的双向链表，可以按照index排序的次序遍历全部data。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210514153242658.png" alt="image-20210514153242658" style="zoom:80%;" />

#### B树和B+树的区别

* B+树的非叶子结点只具有索引作用，不包含data，节省内存，可以**内存中能够存放更多的index**，所以B+树磁盘读写的代价比B树低。
* B+树的**叶子结点都是相链的**，所以对整棵树的遍历**只需要遍历一次叶子结点**即可。而B树需要**中序遍历**。
* B+树的**叶子节点位于同一层**，data也都位于叶子节点中，所以每次查找都是从根节点找到叶子节点，效率很稳定。而B树在查到key后就停止查找了，效率不够稳定。

#### B树和B+树的优点

B树的优点：B树的每一个节点都包含index和data，离根节点更近，访问速度更快，所以可以把经常访问节点放到离根节点更近的位置。

B+树的优点：

1. **B+ 树的高度更低**。
2. **更少的磁盘IO操作**：B+树的**非叶子结点只具有索引作用**，不包含data，节省内存。一块磁盘块中**能够存放更多的节点**，一次性读入内存的节点数量也就越多，所以IO读写次数就更少。磁盘每次都会**预读**，可以减少磁盘 I/O 操作。
3. **更少的查询次数**：B+树的**叶子结点都是相链的**，所以对整棵树的遍历**只需要遍历一次叶子结点**即可。
4. **更高的查找效率**：B+树的**叶子节点位于同一层**，data也都位于叶子节点中，每次查找都是从根节点找到叶子节点，效率很稳定。

#### 关于B+树的问题

* 为什么MySQL使用B+树？而不用二叉树、AVL树、红黑树、B树、Hash索引（散列表）、跳表？

  1. 二叉树，可能会退化为链表，会导致查找的时间复杂度为O(N)。
  2. AVL 树，防止了二叉树退化为链表，但是为了绝对平衡（每个节点的左右子树深度之差不超过1），需要进行旋转，旋转是一个非常耗时的操作。
  3. 红黑树，减少了删除的旋转次数，但不适用于大量查找操作，因为树的高度太高。
  4. B 树，树的高度没有红黑树高，减少磁盘的IO操作。但在进行查找的时候，需要中序遍历，很耗时。
  5. B+树，在B树的基础上进一步**减少磁盘的IO操作**。非叶子结点只具有索引作用，不包含data，节省内存。一块磁盘块中**能够存放更多的节点**，一次性读入内存的节点数量也就越多，所以IO读写次数就更少。磁盘每次都会**预读**，可以减少磁盘 I/O 操作。**更少的查询次数**，进行查找的时候，**只需要遍历一次叶子结点**即可。**更高的查找效率**，B+树的**叶子节点位于同一层**，data也都位于叶子节点中，每次查找都是从根节点找到叶子节点，效率很稳定。
  6. Hash索引，如果只查询单个值的话，Hash索引的效率非常高，时间复杂度为O(1)。但是 Hash 索引有三个问题：1）不支持范围查询；2）不支持索引值的排序操作；3）不支持联合索引的最左匹配规则。
  7. 跳表，是链表加多层索引的结构，时间复杂度O(logn)，支持区间查找。但对于相同数量级的数据，跳表的索引高度比B+树高，磁盘的IO操作更多。

* B+树一个节点有多大？一千万条数据，B+树多高（需要几次IO）？

  在 MySQL 中 B+ 树的**一个节点大小为“1页”，也就是16k**。对于叶子节点，如果一行数据大小为1k，那么一页就能存16行数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在MySQL中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个key和指针。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于**两千多万条的数据**，我们只需要**高度为3的B+树**就可以完成，通过主键查询只需要**3次IO操作**就能查到对应数据。

* B树和B+树是一个什么数据结构？

* 讲讲B+树的操作

  * 查找：在根节点进行二分查找，然后递归查找到叶子节点，在叶子节点上进行二分查找，找到index对应的data。
  * 插入删除：插入和删除操作会破坏B+树的平衡，所以需要对B+树进行分裂、合并、旋转等操作。

* 二叉树和B+树的区别

  二叉树适合数据量少的情况；B+树效率高且适合数据多的情况。

* 红黑树和B+树的区别
  * **B+ 树的高度更低**。
  * **磁盘IO操作更少**。非叶子结点只具有索引作用，不包含data，节省内存。一个节点存放的索引更多。磁盘每次都会**预读**，可以减少磁盘 I/O 操作。
  * **更少的查询次数**，进行查找的时候，**只需要遍历一次叶子结点**即可。
  * **更高的查找效率**，B+树的**叶子节点位于同一层**，value也都位于叶子节点中，每次查找都是从根节点找到叶子节点，效率很稳定。

### 6. 另外的索引结构

#### Hash索引

优点：如果只查询单个值的话，Hash索引的效率非常高，时间复杂度为O(1)。

缺点：1）不支持排序和分组；2）只支持精确查找，不支持范围查找；3）不支持最左前缀匹配规则

哈希表 = 数组 + 链表

数组存储链表 ，链表存储值。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210516161435673.png" alt="image-20210516161435673" style="zoom: 67%;" />

#### 跳表

redis 常用

数据结构：链表加多层索引。上层索引个数是下层的1/2，最少索引个数为2个。

优点：时间复杂度O(logN)，实现简单。

缺点：对于相同数量级的数据，跳表的索引高度比B+树高，磁盘的IO操作更多。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210514222441041.png" alt="image-20210514222441041" style="zoom: 33%;" />



## 六、图 Graph

### 图的预备知识

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210702154216772.png" alt="image-20210702154216772" style="zoom:80%;" />

* 图由 **顶点**（vertex）和 **边**（edge）组成。
* **路径**：从一个顶点到另一个顶点之间经过的所有顶点的集合。
* **路径长度**：路径上 ”边“ 的数量。
* **点到点的距离**：从 顶点v 到 顶点u 的最短路径长度。如果 v 和 u 之间不存在路径，则记该距离为无穷。
* **环**：起点和终点为同一个顶点的路径。
* **顶点的度**：和该顶点相连的所有边的数量。
* **顶点的入度**：以 顶点v 为终点的有向边的数量。
* **顶点的出度**：以 顶点v 为起点的有向边的数量。
* **无向图**和**有向图**：根据边有无方向可分为无向图和有向图。无向图的边叫做**无向边**，有向图的边叫做**有向边**。
* **有向无环图**：不存在环的有向图。
* **有权图**：”边“ 带有权重。
* 有权路径长度：当图是有权图时，一条路径上的所有边的权值之和。
* **连通图**：任意两个节点都是连通的。无向图中，顶点v 和 顶点u 之间存在路径，则称这两个点是**连通**的。
* **强连通图**：任意两个节点都是强连通的。有向图中，从 顶点v 到 顶点u 和 顶点u 到 顶点v 都有路径，则称这两个点是**强连通**的。
* 连通分量：连通子图的最大数量。
* 强连通分量：强连通子图的最大数量。
* 子图：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210702215927002.png" alt="image-20210702215927002" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210706212628509.png" alt="image-20210706212628509" style="zoom: 50%;" />

* **桥**：对于无向图而言，如果删除了一条边，整个图的连通分量数量发生了变化，则称这条边为桥。一个图中可以有多条桥。一棵树的所有边，都是桥。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210712044756.png" alt="image-20210712044756403" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210712045016.png" alt="image-20210712045016706" style="zoom: 33%;" />



* 割点：如果删除了一个顶点，顶点的邻边也删除，整个图的连通分量数量发生了变化，则称这个顶点为**割点**。
* **源点**：一条边的起始点
* **汇点**：一条边的终止点
* 二分图：图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210803082757.png" alt="image-20210803082757160" style="zoom: 25%;" />

### 图的存储方式

#### 1. 邻接矩阵法

邻接矩阵一般会超时，别用。

**1. 无向无权图**

* `nums[0][1] == 1` 代表 顶点0 和 顶点1 连通。`nums[0][4] == 0` 代表 顶点0 和 顶点4 不连通。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210706141157772.png" alt="image-20210706141157772" style="zoom: 67%;" />

**邻接矩阵**：

```java
public class AdjMatrix {
    int N;
    int[][] adj;

    public AdjMatrix(int N) {
        this.N = N;				// N是顶点个数
        this.adj = new int[N][N];
    }
}
```

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210702223614933.png" alt="image-20210702223614933" style="zoom: 80%;" />

​	ps：请注意这是矩阵相乘！

**2. 无权有向图**

**3. 有权无向图**

**4. 有权有向图**

* `nums[0][1] == 5` 代表 顶点0 到 顶点2 的距离是5。`nums[0][4] == ∞` 代表 顶点0 到 顶点4 的距离是无穷，即没有连通。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210702222516054.png" alt="image-20210702222516054" style="zoom: 50%;" />

#### 2. 邻接表法

请使用邻接表法！

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210703084718707.png" alt="image-20210703084718707" style="zoom: 50%;" />

用**邻接表**表示**无权图**：

```java
public class AdjList {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;
}
```

用**邻接表**表示**有权图**：

```java
public class AdjList {
    List<Map<Integer, Integer>> edges = new ArrayList<>();		// map: <汇点, 边的权重>
    boolean[] visited;
}
```

### 小岛问题 FloodFill

```java
// 四连通
int[][] dirs = {
    {-1, 0}, {1, 0},    // 上下
    {0, -1}, {0 , 1}    // 左右
};
for (int k = 0; k < dirs.length; k++) {
    int nextX = x + dirs[k][0];
    int nextY = y + dirs[k][1];
    dfs(nextX, nextY);
}

// 八连通
int[][] dirs = {
    {-1, -1}, {-1, 0}, {-1, 1},     // 第一行
    {0, -1},           {0, 1},      // 第二行
    {1, -1}, {1, 0}, {1, 1}        	// 第三行
};
for (int k = 0; k < dirs.length; k++) {
    int nextX = x + dirs[k][0];
    int nextY = y + dirs[k][1];
    dfs(nextX, nextY);
}
```

### 无向图

#### DFS

**`solution(int n, int[][] relation)`**：n是节点个数，`relation[i][0]➡ relation[i][1]`

3. 初始化边，再添加所有的边
4. 遍历所有没有被访问过的源点，对其做 DFS

**`dfs(int src)`**：标记源点为已访问，遍历源点的汇点（如果该汇点没有被访问过）

根据打印当前节点的位置不同，DFS可分为 深度优先**先序遍历** 和 深度优先**后序遍历**。多用 深度优先**先序遍历**，但在有向图的某些应用中，使用 深度优先**后序遍历**，会更好。

```java
class DFS {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    // n是节点个数，relation由题目给出，relation[i][0]➡ relation[i][1]
    public void solution(int n, int[][] relation) {
        visited = new boolean[n];
        // 初始化边
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        // 添加所有的边
        for (int[] edge : relation) {
            int src = edge[0];
            int dst = edge[1];
            edges.get(src).add(dst);
        }
        // 遍历所有没有被访问过的源点，对其做DFS
        for (int src = 0; src < n; src++) {
            if (!visited[src]) {
                dfs(src);
            }
        }
    }

    // 深度优先先序遍历
    public void dfs(int src) {
        visited[src] = true;
        System.out.println(src);
        for (int dst : edges.get(src)) {
            if (!visited[dst]) {
                dfs(dst);
            }
        }
    }

    // 深度优先后序遍历
    public void dfs1(int src) {
        visited[src] = true;
        for (int dst : edges.get(src)) {
            if (!visited[dst]) {
                dfs1(dst);
            }
        }
        System.out.println(src);
    }
}
```

#### BFS

使用**队列**完成。

```java
class BFS {
    List<List<Integer>> edges = new ArrayList<>();
    boolean[] visited;

    // n是节点个数，relation由题目给出，relation[i][0]➡ relation[i][1]
    public void solution(int n, int[][] relation) {
        visited = new boolean[n];
        // 初始化边
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        // 添加所有的边
        for (int[] edge : relation) {
            int src = edge[0];
            int dst = edge[1];
            edges.get(src).add(dst);
        }
        // BFS，遍历是为了避免有多个连通分量
        for (int src = 0; src < n; src++) {
            if (!visited[src]) {
                bfs(src);
            }
        }
    }

    public void bfs(int src) {
        Deque<Integer> deque = new ArrayDeque<>();
        deque.addLast(src);
        visited[src] = true;

        while (!deque.isEmpty()) {
            src = deque.removeFirst();
            System.out.println(src);

            for (int dst : edges.get(src)) {
                if (!visited[dst]) {
                    deque.addLast(dst);
                    visited[dst] = true;
                }
            }
        }
    }
}
```

**DFS 和 BFS的区别**

* DFS就是一条路走到底，发现没路了，返回来，走另一条路。
* BFS就是每条路都走一点，走一点点后就走另一条路了。

### 有向图

#### 拓扑排序 Topological Sort

在一个有向图中，对所有的节点进行排序，要求所有的节点都不能指向它前面的节点。

先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。

重复上述操作，直到所有的节点都被分离出来。

如果最后存在入度不为0的节点，那就说明有环，不存在拓扑排序的结果。

算法的演示过程：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210825034551.png" alt="image-20210825034551600" style="zoom: 67%;" />

**拓扑排序**能**检测有向图的环**，基于**BFS + 贪心**实现。拓扑排序的**结果不唯一**。

### 最短路径

#### 单源最短路径

##### Dijkstra 算法 

不适用于有负权值的带权图。

思想：**贪心**。<font color='red'>先求出长度最短的一条路径</font>，再根据这条最短路径<font color='red'>求出第二长的路径</font>，以此类推，直到求出源点到其他各个顶点的距离。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/迪杰斯特拉算法.gif" alt="迪杰斯特拉算法"  />

### 并查集

多用在**无向图连通性**的题目上。

**路径压缩**：

union: $O(logN)$

find: $O(logN)$

```java
class UnionFind {
    int count;      // 连通分量个数
    int[] parent;   // 节点i的父节点是parent[i]

    public UnionFind(int N) {
        this.count = N;         // n为图的节点总数
        parent = new int[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;      // 父节点指针初始指向自己
        }
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        parent[rootX] = rootY;          // x成为y的子树
        count--;
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

**路径压缩 + 带权**：

union: 接近常数

find: 接近常数

```java
class UnionFind {
    int count;      // 连通分量个数
    int[] parent;   // 节点i的父节点是parent[i]
    int[] size;     // 每棵树的重量

    public UnionFind(int N) {
        this.count = N;         // n为图的节点总数
        parent = new int[N];
        size = new int[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;      // 父节点指针初始指向自己
            size[i] = 1;        // 最初每个树只有一个节点，即每棵树的初始重量为1
        }
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        if (size[rootX] < size[rootY]) {
            parent[rootX] = rootY;          // x成为y的子树
            size[rootY] += size[rootX];
        } else {
            parent[rootY] = rootX;          // y成为x的子树
            size[rootX] += size[rootY];
        }
        count--;
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

# 算法

## 一、双指针 

### 1. 双指针 Two Points

```java
int left = 0;
int right = N - 1;
while (left < right) {
    
}
```

### 2. 快慢指针 Fast-slow Point



### 3. 滑动窗口 Sliding Window

```java
int left = 0;
for (int right = 0; right < N; right++) {
    
    while / if (xxx) {
        left++;
    }
}
```

## 二、前缀和数组

### 前缀和数组

定义：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916183341.png" alt="image-20210916183341326" style="zoom: 50%;" />

举例：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916183443.png" alt="image-20210916183443550" style="zoom:50%;" />

作用：在 $O(1)$ 时间内，求出数组一段区间内的和。比如求 `[left, right]` 之间的和，就等于 `s[right] - s[left - 1]`

下面的代码中，`nums[i]` 中的 `i` 相当于是向前移动了一位。

```java
// 求前缀和数组
public void preSum(int[] nums) {
    int N = nums.length;
    int[] s = new int [N + 1];

    for (int i = 0; i < N; i++) {
        s[i + 1] = s[i] + nums[i];
    }
}

// 获得[left, right]之间的和
public int getSum(int[] s, int left, int right) {
    return s[right] - s[left - 1];
}
```

```java
// 前缀和 + 哈希表
public void preSum(int[] nums) {
    Map<Integer, Integer> preSum = new HashMap<>();
    preSum.put(0, 1);
    int sum = 0;

    for (int num: nums) {
        sum += num;
        preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
    }
}
```

### 二维前缀和数组

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916185128.png" alt="image-20210916185128018" style="zoom: 50%;" />

```java
class NumMatrix {

    int[][] s;

    public NumMatrix(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;
        
        s = new int[M + 1][N + 1];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + mat[i][j];
            }
        }
    }

    public int sumRegion(int x1, int y1, int x2, int y2) {
        return s[x2 + 1][y2 + 1] - s[x1][y2 + 1] - s[x2 + 1][y1] + s[x1][y1];
    }
}
```

### 后缀和数组

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916190616.png" alt="image-20210916190616549" style="zoom: 67%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916190652.png" alt="image-20210916190651918" style="zoom:67%;" />

```java
public void preSum(int[] nums) {
    int N = nums.length;
    int[] s = new int [N + 1];

    for (int i = N - 1; i >= 0; i--) {
        s[i] = s[i + 1] + nums[i];
    }
}
```

### 前缀积数组

### 后缀积数组

### 差分数组

对差分数组求前缀和，就可以获得原数组。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916193154.png" alt="image-20210916193153958" style="zoom:80%;" />

作用：在 $O(1)$ 时间内，给原数组的某一段区间加上一个值。就是在差分数组对应的左端点加，在右端点减。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210916201406.png" alt="image-20210916201406062" style="zoom: 50%;" />

题目：给数组 `nums` 的区间 `[left, right]` 加上一个值 `val`，不考虑越界。

```java
public int[] addVal(int[] nums, int left, int right, int val) {
    int N = nums.length;
    int[] diff = new int[N];
    for (int i = 1; i < N; i++) {
        diff[i] = nums[i] - nums[i - 1];
    }

    diff[left] += val;
    diff[right + 1] -= val;

    for (int i = 1; i < N; i++) {
        nums[i] = nums[i - 1] + diff[i];
    }
    return nums;
}
```

## 六、搜索

### 1. DFS 回溯 Backtracking

回溯法是 DFS，其本质就是**暴力递归**，穷举所有可能，返回我们想要的答案。

具体过程：每次从一条路往前走，能走则走，不能走则退回来，换一条路再试。

回溯法解决的问题都可以抽象为**树形结构**（N叉树）。

某些题目中的回溯法需要剪枝，剪枝在每道题的技巧都是不一样的， 不过一个简单的原则就是**避免根本不可能是答案的递归**。

能够解决的问题：

* **组合**：N个数里面按⼀定规则找出k个数的集合。组合无序，即（1，2）和（2，1）是一个集合。
* **切割**：⼀个字符串按⼀定规则有几种切割方式 
* **子集**：⼀个N个数的集合⾥有多少符合条件的子集
* **排列**：N个数按⼀定规则全排列，有几种排列方式。排列有序，即（1，2）和（2，1）不是一个集合。。
* **棋盘问题**：N皇后，解数独

回溯法⼀般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。**for循环**可以理解是**横向遍历**， backtracking（**递归**）就是**纵向遍历**。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210716165215.png" alt="image-20210716165215046"  />

**回溯法通用模板**：

```java
List<List<Integer>> res = new ArrayList<>();    // 二维数组res
List<Integer> path = new ArrayList<>();         // 一维数组path

void dfs(参数) {	
    if (终止条件) {
        res.add(new ArrayList<>(path));		// 深度拷贝
        return;
    }
    
    for (选择：选择列表) {
        if (选择是否符合要求) {
            path.add(当前的元素);			 // 做选择
       	 	dfs(参数); 					   // DFS
            path.remove(path.size() - 1);	// 撤销选择
        }
    }
}
```

**回溯三步法**：

**1. 确定递归函数的参数和返回值**：即输入与输出，但大多数情况下回溯是没有输出的，输出都写成全局变量了。

**2. 确定终止条件**：

**3. 确定单层递归的逻辑**

### 2. BFS

```java
public int bfs(Node start, Node target) {
    Deque<Node> deque = new ArrayDeque<>();
    Set<Node> visited = new HashSet<>();
    deque.addLast(start);
    visited.add(start);

    int step = 0;
    while (!deque.isEmpty()) {
        step++;
        int size = deque.size();

        for (int i = 0; i < size; i++) {
            Node cur = deque.removeFirst();
            if (cur == target) {
                return step;
            }

            for (Node next : cur.getNext()) {
                if (!visited.contains(next)) {
                    deque.addLast(next);
                    visited.add(next);
                }
            }
        }
    }
    return -1;
}
```

### 3. ElasticSearch

#### 倒排索引

将文档中的单词作为索引，将文档ID作为记录。

#### 最细粒度的拆分

**ik_max_word**: 会将文本做**最细粒度的拆分**，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query；

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210202144350789.png" alt="image-20210202144350789" style="zoom:80%;" />

#### 最粗粒度的拆分

**ik_smart**: 会做**最粗粒度的拆分**，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase Query。

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210202144329833.png" alt="image-20210202144329833" style="zoom:80%;" />

## 七、贪心 Greedy

优先考虑最满足标准的样本，最后考虑最不满足标准的样本。

贪心定义：找出**局部最优**并可以推出**全局最优**。

## 八、动态规划 DP

### 概念

**动态规划**（英语：Dynamic Programming，简称 **DP**），**由子问题的解求出原问题的解**。DP就是自底向上的迭代解法。

**动态规划**有两个重要的概念：**最优子结构**和**重复子问题**。

* **最优子结构**：由**子问题的最优解**可以推出**原问题的最优解**。
* **重叠子问题**：每个**重叠的子问题只会被求解一次**。

### 动态规划六步曲

**1. 状态**：原问题和子问题中会变化的变量

* 集合：状态的集合
* 属性：最值/组合/存在问题

**2. dp数组**：

**3. 状态计算**：求dp数组

**4. base case**：

**5. 循环方式**：

**6. 空间优化**：使用 **滚动数组 **代替 dp数组

### 问题分类

1. 线性DP
2. 背包DP
3. 区间DP
4. 树形DP
5. 状压DP
6. 状态机DP

#### 1. 线性DP

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

#### 2. 背包DP

背包类型：

* 01背包：每种物品只有一个，只能选择放或者不放
* 完全背包：每种物品有无限个
* 多重背包：每种物品的个数是不一样的
* 混合背包：前三种背包的组合
* 二维费用背包：每件物品都有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。  
* 分组背包：物品被划分为`K`组，每组中的物品互相冲突，最多选一件
* 树型背包：物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j

##### 01背包

有 `N` 件物品和一个容量是 `V ` 的背包。每件物品只能使用一次。

第 `i` 件物品的体积是 `v[i]`，价值是 `w[i]`。(volume，worth)

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
public int zeroOneBag(int[] v, int[] w, int V, int N) {
    int[] dp = new int[V + 1];
    
    for (int i = 0; i < N; i++) {			// 正序枚举物品
        for (int j = V; j >= v[i]; j--) {		// 逆序枚举容量
            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    return dp[V];
}
```

如果物品的体积和价值相同。

```java
public int zeroOneBag(int[] nums, int target) {
    int[] dp = new int[target + 1];
    
    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
    return dp[target];
}
```

##### 完全背包

有 `N` 件物品和一个容量是 `V` 的背包。每件物品能使用无限次。

第 `i` 件物品的体积是 `v[i]`，价值是 `w[i]`。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
public int completeBag(int[] v, int[] w, int V, int N) {
    int[] dp = new int[V + 1];

    for (int i = 0; i < N; i++) {			// 枚举物品
        for (int j = w[i]; j <= V; j++) {		// 枚举容量
            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    return dp[V];
}
```

##### 多重背包

有 `N` 件物品和一个容量是 `V` 的背包。

第 `i` 件物品的个数是 `s[i]`，体积是 `v[i]`，价值是 `w[i]`。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
public int multipleBag(int[] s, int[] v, int[] w, int V, int N) {
    int[] dp = new int[V + 1];

    for (int i = 0; i < N; i++) {       // 枚举物品
        for (int j = w[i]; j <= V; j++) {   // 枚举容量
            for (int k = 1; k <= s[i]; k++) {   // 枚举物品个数
                if (j - k * v[i] < 0) {             // 拿不起k个物品，就退出
                    break;
                }
                dp[j] = Math.max(dp[j], dp[j - k * v[i]] + k * w[i]);
            }
        }
    }
    return dp[V];
}
```

优化前的时间：$O(N*V*最多的物品个数)$，优化后的时间：$O(N*\sum{log(物品个数)})$

二进制优化：

如果一个物品的数量是10，之前是枚举物品个数从1到10，需要枚举10次。

现在用二进制的方式压缩，类似Linux的文件权限。将原本的物品个数用 `ceil(log(n))` 来代替。

10可以用`1、2、4、3` 来代替。不能用 `1、2、4、6` 或者 `1、2、4、8` 来代替。因为`1、2、4、6` 可以表达的范围是 0~13，而 `1、2、4、8` 可以表达的范围是 0~15，而我们要求的是表达 10，大于 10 的范围是不能被选择的。

所以我们在 `1、2、4` （表达的范围是 0~7）的基础上，增加一个数 3（由 10 - 7 而来），这样就能满足我们需要表达的范围 0~10。

```java
class Good {
    int v;
    int w;

    public Good(int v, int w) {
        this.v = v;
        this.w = w;
    }
}

public int multipleBag(int[] s, int[] v, int[] w, int V, int N) {
    // 二进制压缩
    List<Good> goods = new ArrayList<>();
    for (int i = 0; i < N; i++) {
        int c = s[i];             // 第i件物品的个数
        for (int k = 1; k <= s[i]; k *= 2) {
            c -= k;
            goods.add(new Good(v[i] * k, w[i] * k));
        }
        if (c > 0) {
            goods.add(new Good(v[i] * c, w[i] * c));
        }
    }

    // 转化为01背包
    int[] dp = new int[V + 1];
    for (Good good : goods) {
        for (int j = V; j >= good.v; j--) {
            dp[j] = Math.max(dp[j], dp[j - good.v] + good.w);
        }
    }
    return dp[V];
}
```

##### 混合背包

有 `N` 件物品和一个容量是 `V ` 的背包。

物品一共有三类：

* 第一类：物品只有一个，只能选择放或者不放（01背包）
* 第二类：物品有无限个（完全背包）
* 第三类：每种物品的个数是不一样的（多重背包）

第 `i` 件物品的个数是 `s[i]`，体积是 `v[i]`，价值是 `w[i]`。

* `s[i] = -1`，表示第 `i` 件物品只能使用一次
* `s[i] = 0`，表示第 `i` 件物品可以使用无限次
* `s[i] > 0`，表示第 `i` 件物品可以使用 `s[i]` 次

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
class Good {
    int kind;
    int v, w;

    public Good(int kind, int v, int w) {
        this.kind = kind;
        this.v = v;
        this.w = w;
    }
}

public int hybridBag(int[] s, int[] v, int[] w, int V, int N) {
    List<Good> goods = new ArrayList<>();
    for (int i = 0; i < N; i++) {
        if (s[i] <= 0) {            // 01背包和完全背包
            goods.add(new Good(s[i], v[i], w[i]));
        } else {
            int c = s[i];             // 第i件物品的个数
            for (int k = 1; k <= s[i]; k *= 2) {
                c -= k;
                goods.add(new Good(s[i], v[i] * k, w[i] * k));
            }
            if (c > 0) {
                goods.add(new Good(s[i], v[i] * c, w[i] * c));
            }
        }
    }

    int[] dp = new int[N + 1];
    for (Good good : goods) {
        if (good.kind == -1) {      // 01背包
            for (int j = V; j >= good.v; j--) {
                dp[j] = Math.max(dp[j], dp[j - good.v] + good.w);
            }
        } else {                    // 完全背包和多重背包
            for (int j = good.v; j <= V; j++) {
                dp[j] = Math.max(dp[j], dp[j - good.v] + good.w);
            }
        }
    }
    return dp[N];
}
```

##### 二维费用背包

有 `N` 件物品和一个容量是 `V ` 的背包，背包能承受的最大重量是 `M`。每件物品只能使用一次。

每件物品的体积是 `v[i]`，重量是 `m[i]`，价值是 `w[i]`。(volume，mass，worth)

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

dp数组：容量是`i`，最大承重是`j`的背包，所背物品的最大价值是 `dp[i][j]`。

```java
public int twoDBag(int[] v, int[] m, int[] w, int V, int M, int N) {
    int[][] dp = new int[V + 1][M + 1];

    for (int i = 0; i < N; i++) {       // 枚举物品
        for (int j = V; j >= v[i]; j--) {   // 逆序枚举体积
            for (int k = M; k >= m[i]; k--) {   // 逆序枚举重量
                dp[j][k] = Math.max(dp[j][k], dp[j - v[i]][k - m[i]] + w[i]);
            }
        }
    }
    return dp[V][M];
}
```

##### 分组背包

有 `N` 组物品和一个容量是 `V ` 的背包。每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 `v[i][j]`，价值是 `w[i][j]`。`i` 是组号，`j` 是组内编号。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
public int groupBag(List<List<Integer>> v, List<List<Integer>> w, int V, int N) {
    int[] dp = new int[V + 1];

    for (int i = 0; i < N; i++) {       // 枚举组
        for (int j = V; j >= 0; j--) {      // 枚举容量
            for (int k = 0; k < v.get(i).size(); k++) { // 枚举组号
                if (j - v.get(i).get(k) >= 0) {
                    dp[j] = Math.max(dp[j], dp[j - v.get(i).get(k)] + w.get(i).get(k));
                }
            }
        }
    }
    return dp[V];
}
```

##### 树型背包

就是树型DP + 分组背包。

有 `N` 组物品和一个容量是 `V ` 的背包。

物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如下图所示：

<img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="QQ图片20181018170337.png" style="zoom:67%;" />

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。

第 `i` 件物品的体积是 `v[i]`，价值是 `w[i]`，依赖的父节点编号是 `p[i]`。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

dp数组：根是`u`，容量是`j`的背包，所背物品的最大价值是 `dp[u][j]`。

##### 背包问题的问法

**1、问法类型**

* 最值问题：求最小值/最大值
* 排列/组合问题：求所有满足……的排列or组合
* 存在问题：是否存在…………，满足…………

**2. 状态计算**：

* 最值问题：`dp[j] = max/min(dp[j], dp[j - v[i]] + w[i])`
* 排列/组合问题：`dp[j] += dp[j - v[i]]`
* 存在问题 (boolean)：`dp[j] |= dp[j - v[i]]` 

**3. base case**：

* 最值问题：看题目要求
* 排列组合问题：`dp[0] = 1`
* 存在问题 (boolean)：看题目要求

排列/组合问题在不同的背包种枚举方式不同。

* 排列问题：顺序不同，方案相同。
* 组合问题：顺序不同，方案不同。

01背包组合问题：[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905045257.png" alt="image-20210905045257321" style="zoom:80%;" />

思路：找到 `nums` 的一个`正子集P` 和 一个`负子集N`，使得总和等于 `target`。等同于找到存在多少个正子集P，使 `sum(P) == (target + sum(nums))/2`

01背包枚举方式：正序枚举物品，逆序枚举背包容量

```java
public int findTargetSumWays(int[] nums, int S) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    if (S > sum || ((S + sum) & 1) == 1) {
        return 0;
    }

    int target = (S + sum) / 2;
    if (target < 0) {
        return 0;
    }

    int[] dp = new int[target + 1];
    dp[0] = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[target];
}
```

完全背包排列问题：[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904023721.png" alt="image-20210904023721575" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909051644.png" alt="image-20210909051644909" style="zoom:80%;" />

完全背包枚举方式：正序枚举物品，正序枚举背包容量

```java
public int change(int target, int[] nums) {
    int[] dp = new int[target + 1];
    
    dp[0] = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = nums[i]; j <= target; j++) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[target];
}
```

完全背包组合问题：[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909050136.png" alt="image-20210909050107378" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909050133.png" alt="image-20210909050117063" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909060300.png" alt="image-20210909060300139" style="zoom:50%;" />

`dp[j]`：总和为 `j` 的组合总数。

```java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int j = 0; j <= target; j++) {
        for (int i = 0; i < nums.length; i++) {
            if (j >= nums[i]) {
                dp[j] += dp[j - nums[i]];
            }
        }
    }
    return dp[target];
}
```

二维费用背包组合问题：[879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)

#### 3. 区间DP

**1. 状态**：区间`[i, j]`

* 集合：状态的集合
* 属性：最值/组合/存在问题

**2. dp数组**：

**3. 状态计算**：求dp数组

**5.枚举方式**：枚举区间长度，枚举区间左边界，枚举区间分割点（左右边界内的值）。

```java
for (int len = 2; len <= N; len++) {
	for (int i = 1; i + len - 1  < N; i++) {
		int j = i + len - 1;			// 右边界
		for (int k = i; k <= j; k++) {

		}
	}
}
return dp[1][N];
```

## 九、数学 Math

### 数学公式

#### 欧式距离

$d_{12}=\sqrt{(x_{1}-x_{2})^{2}+(y_{1}-y_{2})^{2}}$

#### 曼哈顿距离

$d_{12}=\left |x_{1}-x_{2}  \right | + \left |y_{1}-y_{2}  \right |$

### 概率论

#### 等差数列求和

$S_{n}=\frac{n(a_{1}+a_{n})}{2}$

$S_{n}=na_{1}+\frac{n(n-1)d}{2}$

#### 等比数列

$S_{n}=\frac{a_{1}-a_{n}q}{1-q}$

$S_{n}=\frac{a_{1}(1-q^{n})}{1-q}$

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210804015032.png" alt="image-20210804015032552" style="zoom: 80%;" />

#### 离散型期望

$\sum_{i=1}^{n}x_{i}*p_{i}$ 

$x_{i}$ 是值，$p_{i}$ 是 $x_{i}$ 的概率。

### 最大公约数

最大公约数：Greatest Common Divisor（GCD），使用辗转相除法求得

证明：

`(a, b)` 的最大公约数等于 `(a, x * a + y * b)`，x和y是任意整数，比如 `(4, 6)` 的最大公约数是 `2`，`(4, 4 * 2 + 1 * 6) == (4, 14)` 的最大公约数也是 `2`。

基于上面的原理，我们用迭代相减法，基本上思路就是大数减去小数，一直减到能算出来为止：

`(78,14)=(64,14)=(50,14)=(36,14)=(22,14)=(8,14)=(8,6)=(2,6)=(2,4)=(2,2)=(0,2)=2`

但是用迭代相减法太慢了，用求余数的方式更快，所以诞生出了辗转相除法，以下用 `gcd` 代表最大公约数：

所以 `gcd(a, b) == gcd(b, a - y * b)`

代码：

```java
public int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

### 位运算

#### 左移右移

##### 乘2

`n << 1`

##### 除2

`n >> 1`

#### 判断

##### 是否是奇数

`(n & 1) == 1`

##### 是否是偶数

`(n & 1) == 0`

##### 是否是2的整数次幂

`(n & (n - 1)) == 0`

比如 `(100 & 011) == 0` ，说明 4 是2的整数次幂

##### 两非零数符号是否相同

`(a ^ b) >= 0`

#### 操作

##### 绝对值

`(n ^ (n >> 31)) - (n >> 31)`

`n >> 31` 取得 n 的符号，若 n 为正数，`n>>31` 等于 0，若 n 为负数，`n>>31` 等于 -1 。比如 -4，就等于 `(-4 ^ -1 - (-1)) == (3 + 1) == 4`

##### 交换两个数

`void swap(int a, int b) { a = a ^ b; b = a ^ b; a = a ^ b; }` 

##### 获取一个数二进制的某一位

`(a >> b) & 1` ：获取一个二进制数的第 `b` 位，最低位编号是0

##### 将一个数二进制的某一位设置为0

`a & ~(1 << b)` ：将一个数二进制的第 `b` 位设置为 0

##### 将一个数二进制的某一位设置为1

`a | (1 << b)` ：将一个数二进制的第 `b` 位设置为 1

##### 将一个数二进制的某一位取反

`a ^ (1 << b)`

#### 模拟集合（状态压缩）

一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。比如集合 $\left \{ 1,3,4,8 \right \}$，可以表示成 $(100011010)_{2}$。而对应的位运算也就可以看作是对集合进行的操作。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210911104127.png" alt="image-20210911104127774" style="zoom:80%;" />

子集遍历：

```java
// 遍历 u 的非空子集
for (int s = u; s; s = (s - 1) & u) {
  // s 是 u 的一个非空子集
}
```

### 素数

#### 判断一个数是否是素数

时间：$O(\sqrt{N})$

```java
public boolean isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) return true;
    }
    return false;
}
```

#### 统计小于n的素数

时间：$O(NloglogN)$

思路：埃及筛。定义一个素数数组，大小为 n， 从 2 枚举到 $\sqrt{n}$ ，如果当前枚举到的数是素数，就把从 i * 2 开始，i 的所有倍数都设置为 false。最后在遍历一次素数数组，统计素数的个数。

```java
public int countPrimes(int n) {
    boolean[] isPrime = new boolean[n];
    Arrays.fill(isPrime, true);
    for (int i = 2; i <= n / i; i++) {
        if (isPrime[i]) {
            for (int j = i * 2; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    int res = 0;
    for (int i = 2; i < n; i++) {
        if (isPrime[i]) res++;
    }
    return res;
}
```





# 技巧

## 1. 统一参数名称

* 一维数组： **nums**
* 两个一维数组：A，B
* 二维数组：**mat**
* 一维动态数组 `List<Integer>`：**list**
* 二维动态数组 `List<List<Integer>>`：**lists**
* 树：**root**，node
* 图：**graph**
* 栈：**stack**
* 双端队列：**deque**
* 优先队列：**pq**
* HashMap / HashSet:  map / set
* TreeMap / TreeSet:  treeMap / treeSet

* 总和：sum
* 最大值：max
* 最小值：min
* 计数变量/计数数组：count
* 下标：idx
* 左边界（左指针）：left
* 右边界（右指针）：right
* 返回结果：res

## 2. 限制条件

* 机器限制只能执行 $10^{7}$ （一千万） 行代码。
  * 如果 N 是 10 左右，那么算法通常是 $O(N!)$ 的时间复杂度。
  * 如果 N 是 20 左右，那么算法通常是 $O(2^{N})$ 的时间复杂度
  * 如果 N 是 $10^{3}$ 左右，那么算法通常是 $O(N^{2})$ 的时间复杂度
  * 如果 N 是 $10^{5}$ 左右，那么算法通常是 $O(NlogN)$ 的时间复杂度

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907090451.png" alt="image-20210907090451282" style="zoom:80%;" />

# 其他

一些问题：

1. 栈的应用场景？（递归，括号匹配，单调栈，JVM，图的DFS）
2. 队列的应用场景？（消息队列，操作系统中的先到先服务，树/图的BFS）
3. 说几个数据压缩的例子？（稀疏数组，二维数组压缩为一维数组，前缀和数组，前缀树，哈夫曼树）
4. 图的应用场景？    （有向图：微博；无向图：微信）

