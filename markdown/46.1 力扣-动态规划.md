[toc]

# 线性DP

## 经典问题

### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906190741.png" alt="image-20210906190741163" style="zoom:80%;" />

不会。

思路1：动态规划。时间：$O(M^{2}N)$

**1. 状态**：`i` 层楼，`j` 个鸡蛋

* 集合：M层楼，N个鸡蛋的操作次数的集合
* 属性：最坏情况下的最小值

**2. dp数组**：`i` 层楼，`j` 个鸡蛋，最坏情况下操作次数的最小值为 `dp[i][j]`

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906191013.png" alt="image-20210906191012890" style="zoom:67%;" />

**4. base case**：

* `i` 层楼，`1` 个鸡蛋：移动 `i` 次
* `1` 层楼，`j` 个鸡蛋：移动 `1` 次

**5. 循环方式**：循环楼层高度，循环鸡蛋个数，枚举存在的楼层

```java
// N个鸡蛋，M层楼
public int superEggDrop1(int N, int M) {
    int[][] dp = new int[M + 1][N + 1];

    for (int i = 1; i <= M; i++) {
        dp[i][1] = i;
    }
    for (int j = 1; j <= N; j++) {
        dp[1][j] = 1;
    }

    for (int i = 2; i <= M; i++) {
        for (int j = 2; j <= N; j++) {
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = 1; k <= i; k++) {
                dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - k][j], dp[k - 1][j - 1]) + 1);
            }
        }
    }
    return dp[M][N];
}
```

思路2：动态规划。时间：$O(MN)$

**1. 状态**：操作`i` 次，`j` 个鸡蛋

* 集合：用 `j` 个鸡蛋操作 `i` 次能够测量的楼层高度集合
* 属性：最大值

**2. dp数组**：用 `j` 个鸡蛋操作 `i` 次，所能测量到的最高楼层高度为 `dp[i][j]`

**3. 状态计算**：`dp[i][j] = dp[i - 1][j] + 1 + dp[i - 1][j - 1]`

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906194049.png" alt="image-20210906194049857" style="zoom: 50%;" />

第一次测量楼层高度到达`M`的操作次数，就是最小的操作次数。

**5. 循环方式**：循环操作次数（M层楼最多操作M次），循环鸡蛋个数

```java
public int superEggDrop(int N, int M) {
    int[][] dp = new int[M + 1][N + 1];

    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            dp[i][j] = dp[i - 1][j] + 1 + dp[i - 1][j - 1];
            if (dp[i][N] >= M) {
                return i;
            }
        }
    }
    return 0;
}
```

### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

先跳过。

### [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

先跳过。



## 打家劫舍

### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906201717.png" alt="image-20210906201717620" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906201725.png" alt="image-20210906201725376" style="zoom:80%;" />

**1. 状态**：第 `i` 个房间

* 集合：到达第 `i` 个房间偷到的钱
* 属性：最大值

**2. dp数组**：到达第 `i` 个房间偷到的钱的最大值

**3. 状态计算**：

* 不偷：`dp[i - 1]`
* 偷：`dp[i - 2] + nums[i]`

**4. base case**：`dp[0] = nums[0]`，`dp[1] = max(nums[0], nums[1])`

```java
public int rob(int[] nums) {
    int N = nums.length;
    if (N == 1) {
        return nums[0];
    }

    int[] dp = new int[N];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (int i = 2; i < N; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[N - 1];
}
```

**6. 空间优化**：使用 **滚动数组 **代替 dp数组

```java
public int rob(int[] nums) {
    int N = nums.length;
    if (N == 1) {
        return nums[0];
    }

    int pre = nums[0];
    int cur = Math.max(nums[0], nums[1]);

    for (int i = 2; i < N; i++) {
        int tempCur = Math.max(cur, pre + nums[i]);
        pre = cur;
        cur = tempCur;
    }
    return cur;
}
```

### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906211709.png" alt="image-20210906211709636" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906211718.png" alt="image-20210906211718621" style="zoom:80%;" />

思路：本题就是环形数组的打家劫舍。分别讨论：

* 偷第一间房屋：0 ~ N - 2
* 不偷第一间房屋：1 ~ N - 1

```java
class Solution {
    public int rob(int[] nums) {
        int N = nums.length;
        if (N == 1) {
            return nums[0];
        }

        int a = myRob(Arrays.copyOfRange(nums, 0, N - 1));
        int b = myRob(Arrays.copyOfRange(nums, 1, N));
        return Math.max(a, b);
    }

    public int myRob(int[] nums) {
        int N = nums.length;
        if (N == 1) {
            return nums[0];
        }

        int pre = nums[0];
        int cur = Math.max(nums[0], nums[1]);

        for (int i = 2; i < N; i++) {
            int temp = Math.max(pre + nums[i], cur);
            pre = cur;
            cur = temp;
        }
        return cur;
    }
}
```

### [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909151450.png" alt="image-20210909151450397" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909151510.png" alt="image-20210909151510094" style="zoom:80%;" />

不会 * 2

思路：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210707210316959.png" alt="image-20210707210316959" style="zoom:80%;" />

本题还可空间优化。

```java
public int deleteAndEarn(int[] nums) {
    int max = 0;
    for (int num : nums) {
        max = Math.max(max, num);
    }

    int[] sum = new int[max + 1];
    for (int num : nums) {
        sum[num] += num;
    }
    return rob(sum);
}

public int rob(int[] nums) {
    int N = nums.length;
    int[] dp = new int[N];

    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (int i = 2; i < N; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[N - 1];
}
```

## 炒股

<img src="https://pic.leetcode-cn.com/1625302665-jtySnq-image.png" alt="image.png" style="zoom: 50%;" />

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906212108.png" alt="image-20210906212108358" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906212121.png" alt="image-20210906212121141" style="zoom:80%;" />

思路：**贪心**。找最小价格 `minPrice`，结果保存最大利润 `price - minPrice` 。

```java
public int maxProfit(int[] prices) {
    int min = prices[0];
    int max = 0;

    for (int price : prices) {
        min = Math.min(min, price);
        max = Math.max(max, price - min);
    }
    return max;
}
```

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906212944.png" alt="image-20210906212943967" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/1604770312-ptYXBB-image.png" alt="image.png" style="zoom: 67%;" />

思路：**贪心**。计算上升的值。

```java
public int maxProfit(int[] prices) {
    int res = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            res += prices[i] - prices[i - 1];
        }
    }
    return res;
}
```

## 单串

### [300. 最长递增子序列(LIS)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906044609.png" alt="image-20210906044609530" style="zoom:80%;" />

LIS: Longest Increasing Subsequence

不会 * 2

**1. 状态**：以 `i` 结尾的序列

* 集合：以 `i` 结尾的序列的子序列的集合
* 属性：最大长度

**2. dp数组**：以 `i` 结尾的最长上升子序列的长度

**3. 状态计算**：只要 `nums[i]` 严格大于在它位置之前的某个数，那么 `nums[i]` 就可以接在这个数后面形成一个更长的上升子序列。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906045615.png" alt="image-20210906045614990" style="zoom: 67%;" />

**4. base case**：整个数组都为 1

最后需要遍历dp数组，找出最大值。

```java
public int lengthOfLIS(int[] nums) {
    int N = nums.length;
    int[] dp = new int[N];
    Arrays.fill(dp, 1);

    for (int i = 0; i < N; i++) {
        for (int k = 0; k < i; k++) {
            if (nums[k] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[k] + 1);
            }
        }
    }

    int max = 0;
    for (int num : dp) {
        max = Math.max(max, num);
    }
    return max;
}
```

* 时间：$O(N^{2})$
* 空间：$O(N)$

**2. 动态规划（贪心 + 二分查找）**建议使用动态规划！贪心太难想了。

时间：$O(NlogN)$

思路：维护一个单调栈，保存最长单调子序列，保证栈底最小，栈顶最大，最后返回栈的大小。使用数组模拟单调栈，二分查找当前数组应该放入的位置。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/300. 最长递增子序列.gif" alt="300. 最长递增子序列" style="zoom: 50%;" />

```java
public int lengthOfLIS(int[] nums) {
    int[] stack = new int[nums.length];
    int index = 0;

    for (int num : nums) {
        int left = 0;
        int right = index;
        while (left < right) {
            int mid = (left + right) / 2;
            if (stack[mid] >= num) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        stack[left] = num;
        if (left == index) {
            index++;
        }
    }
    return index;
}
```

### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210920144816.png" style="zoom:80%;" />

不会。

**1. 状态**：

* 集合：以 `nums[i]` 结尾的最长递增子序列的集合
* 属性：最大值

**2. dp数组**：

* `dp[i]` ：以 `nums[i]` 结尾的最长递增子序列的最长长度
* `count[i]`：以 `nums[i]` 结尾的最长递增子序列的个数

**3. 状态计算**：只要 `nums[k] < nums[i]`，就更新数组：第一次找到，更新 `dp[i]` 和 `count[i]`；第一次之后，累加 `count[k]`

**4. base case**：全为1

**5. 循环方式**：外层枚举位置，内层枚举到当前的位置。

最后结果应该是所有最大长度的子序列的 `count` 的总和。

```java
public int findNumberOfLIS(int[] nums) {
    int N = nums.length;

    int[] dp = new int[N];
    Arrays.fill(dp, 1);
    int[] count = new int[N];
    Arrays.fill(count, 1);

    for (int i = 0; i < N; i++) {
        for (int k = 0; k < i; k++) {
            if (nums[k] < nums[i]) {
                if (dp[k] + 1 > dp[i]) {			// 第一次更新
                    dp[i] = dp[k] + 1;
                    count[i] = count[k];
                } else if (dp[k] + 1 == dp[i]) {	// 第一次之后
                    count[i] += count[k];
                }
            }
        }
    }

    int res = 0;
    int max = 0;
    for (int i = 0; i < N; i++) {
        if (dp[i] > max) {
            max = dp[i];
            res = count[i];
        } else if (dp[i] == max) {
            res += count[i];
        }
    }
    return res;
}
```

### [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)







## 连续单串

### [53. 和最大的连续子数组](https://leetcode-cn.com/problems/maximum-subarray/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906062758.png" alt="image-20210906062758401" style="zoom:80%;" />

思路：维护一个 `pre`，保存到上一个数字为止，最大的连续子数组的和。返回 `pre` 能取到的最大值。

```java
public int maxSubArray(int[] nums) {
    int pre = (int) -1e9;
    int max = (int) -1e9;
    
    for (int num : nums) {
        pre = Math.max(pre + num, num);
        max = Math.max(max, pre);
    }
    return max;
}
```

### [152. 乘积最大的连续子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906063702.png" alt="image-20210906063702099" style="zoom:80%;" />

**1. 状态**：以 `i` 结尾的连续数组

* 集合：以 `i` 结尾的连续子数组乘积的最大值
* 属性：最大值

**2. dp数组**：有正负之分

* max：以 `i` 结尾的连续子数组乘积的最大值，最后的结果就是 max数组中的最大值
* min：以 `i` 结尾的连续子数组乘积的最小值

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710062831.png" alt="png" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710063404.png" alt="png (2)" style="zoom:50%;" />

**4. base case**：提前更新第0个位置

**6. 空间优化**：采用两个变量分别代替 max数组 和 min数组。也需要两个临时变量保存 max 和 min。

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = nums[0];
        int min = nums[0];
        int res = nums[0];

        for (int i = 1; i < nums.length; i++) {
            int tempMax = max(nums[i], max * nums[i], min * nums[i]);
            int tempMin = min(nums[i], max * nums[i], min * nums[i]);
            max = tempMax;
            min = tempMin;
            res = Math.max(res, max);
        }
        return res;
    }

    private int max(int a, int b, int c) {
        return Math.max(a, Math.max(b, c));
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

### [1567. 乘积为正数的最长连续子数组](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906070256.png" alt="image-20210906070256255" style="zoom:80%;" />

**1. 状态**：数组长度

* 集合：以下标`i`结尾的数组，乘积为正数的连续子数组
* 属性：最大值

**2. dp数组**：

* `positive[i]`：下标 i 结尾的乘积为**正数**的最长子数组长度
* `negative[i]`：下标 i 结尾的乘积为**负数**的最长子数组长度

**3. 状态计算**：

1. 当 `nums[i] > 0 `时，之前的乘积乘以 `nums[i]  `**不会改变**乘积的正负性。

   <img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710072741.png" alt="image-20210710072741738" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710072753.png" alt="image-20210710072752986" style="zoom:80%;" />

2. 当 `nums[i] < 0 `时，之前的乘积乘以 `nums[i] ` **会改变**乘积的正负性。

   <img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710072956.png" alt="image-20210710072956029" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210710073013.png" alt="image-20210710073013105" style="zoom:80%;" />

3. 当 `nums[i] == 0 `时，以下标 i 结尾的子数组的元素乘积一定为 0，因此有 `positive[i] = 0` 和 `negative[i] = 0`。

**4. base case**：

* `nums[0] > 0`：`positive[0] = 1`
* `nums[0] < 0` ：`negative[0] = 1`。

**5. 空间优化**：采用两个变量分别代替 两个数组 `positive `和 `negative`。也需要两个临时变量保存 `positive` 和 `negative`。

```java
public int getMaxLen(int[] nums) {
    int p = nums[0] > 0 ? 1 : 0;
    int n = nums[0] < 0 ? 1 : 0;
    int res = p;

    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > 0) {
            p = p + 1;
            n = n > 0 ? n + 1 : 0;
        } else if (nums[i] < 0) {
            int tempP = n > 0 ? n + 1 : 0;
            int tempN = p + 1;
            p = tempP;
            n = tempN;
        } else {
            p = 0;
            n = 0;
        }
        res = Math.max(res, p);
    }
    return res;
}
```

### [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906080542.png" alt="image-20210906080542108" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906080557.png" alt="image-20210906080557370" style="zoom:80%;" />

不会 * 2，本题由 [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) 改编。

**2. dp数组**：以 `i` 结尾的连续子数组的最大和

**3. 状态计算**：环形子数组的最大和具有两种可能，一种是不使用环的情况，另一种是使用环的情况

* 不使用环：和  [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) 一样
* 使用环：则一定包括 `nums[0]` 和 `nums[N - 1]`， `nums[1]` 和 `nums[N - 2]`之间一定包含负数，需要算出它们之间的最小和，最后用数组总和减去最小和，就是使用环的最大和

```java
public int maxSubarraySumCircular(int[] nums) {
    int pre = (int) -1e9;
    int max = (int) -1e9;
    int sum = 0;

    for (int num : nums) {
        pre = Math.max(pre + num, num);
        max = Math.max(max, pre);
        sum += num;
    }

    int min = 0;
    pre = 0;

    for (int i = 1; i < nums.length - 1; i++) {
        pre = Math.min(pre + nums[i], nums[i]);
        min = Math.min(pre, min);
    }

    return Math.max(max, sum - min);
}
```

### [674. 最长连续递增子数组](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907004728.png" alt="image-20210907004728203" style="zoom:80%;" />

思路：动态规划。维护一个当前最长连续递增序列的长度 `cur` 和 最长长度 `max` 即可。

```java
public int findLengthOfLCIS(int[] nums) {
    int cur = 1;
    int max = 1;

    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            cur++;
            max = Math.max(max, cur);
        } else {
            cur = 1;
        }
    }
    return max;
}
```

### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907020747.png" alt="image-20210907020747171" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907020753.png" alt="image-20210907020753416" style="zoom:80%;" />

不会 * 2

**1. 状态**：左指针 `i`，右指针 `j`

**2. dp数组**：区间范围 `[i,j]`（左闭右闭）的字串是否是回文串

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907022122.png" alt="image-20210907022122248" style="zoom:50%;" />

**5. 循环方式**：从右下角遍历。因为 `dp[i][j] `依赖于 `dp[i + 1][j - 1]`

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907022536.png" alt="image-20210907022536251" style="zoom:80%;" />

```java
public int countSubstrings(String s) {
    int N = s.length();
    boolean[][] dp = new boolean[N][N];
    int res = 0;

    for (int i = N - 1; i >= 0; i--) {
        for (int j = i; j < N; j++) {
            if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) {
                dp[i][j] = true;
                res++;
            } else {
                dp[i][j] = false;
            }
        }
    }
    return res;
}
```

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

思路：[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)，保留最长的回文子串。

```java
public String longestPalindrome(String s) {
    int N = s.length();
    boolean[][] dp = new boolean[N][N];
    String res = "";

    for (int i = N - 1; i >= 0; i--) {
        for (int j = i; j < N; j++) {
            if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) {
                dp[i][j] = true;
            } else {
                dp[i][j] = false;
            }
            if (dp[i][j] && (j - i + 1) > res.length()) {
                res = s.substring(i, j + 1);
            }
        }
    }
    return res;
}
```

## 双串

### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906042308.png" alt="image-20210906042308481" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906042236.png" alt="image-20210906042236738" style="zoom:80%;" />

**1. 状态**：字符串 ` s1` 的长度，字符串 ` s2` 的长度，

* 集合：两个字符串的公共子序列长度的集合
* 属性：最大值

**2. dp数组**：`s1` 的前 `i` 个字符 和 `s2` 的前 `j` 个字符 ，最长公共子序列的最大长度是 `dp[i][j]`

**3. 状态计算**：

* `s1(i - 1) == s2(j - 1)`： `dp[i][j] = dp[i - 1][j - 1] + 1`
* 不相等：`max(dp[i - 1][j], dp[i][j - 1])`

```java
public int longestCommonSubsequence(String s1, String s2) {
    int M = s1.length();
    int N = s2.length();
    int[][] dp = new int[M + 1][N + 1];

    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[M][N];
}
```

## 连续双串

### [718. 最长重复连续子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907005143.png" alt="image-20210907005143807" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907005149.png" alt="image-20210907005149050" style="zoom:80%;" />

**1. 状态**：数组 `A` 的长度 `i`，数组 `B` 的长度 `j`，

* 集合：两个字符串的连续公共子序列长度的集合
* 属性：最大值

**2. dp数组**：`s1` 的前 `i` 个字符 和 `s2` 的前 `j` 个字符 ，最长公共子序列的最大长度是 `dp[i][j]`

**3. 状态计算**：`s1(i - 1) == s2(j - 1)`： `dp[i][j] = dp[i - 1][j - 1] + 1`

要额外的变量 `max` 保存最大值。

```java
public int findLength(int[] A, int[] B) {
    int M = A.length;
    int N = B.length;
    int[][] dp = new int[M + 1][N + 1];
    int max = 0;

    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            if (A[i - 1] == B[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = 0;
            }
            max = Math.max(max, dp[i][j]);
        }
    }
    return max;
}
```

**6. 空间优化**：使用 **滚动数组 **代替 dp数组。

```java
public int findLength(int[] A, int[] B) {
    int M = A.length;
    int N = B.length;
    int[] dp = new int[N + 1];
    int max = 0;
    
    for (int i = 1; i <= M; i++) {
        for (int j = N; j >= 1; j--) {	// 因为当前值都是从左上角来的，所以B数组要从后向前遍历，避免重复
            if (A[i - 1] == B[j - 1]) {
                dp[j] = dp[j - 1] + 1;
            } else {
                dp[j] = 0;      // 更新dp数组，不相等要赋值为0
            }
            max = Math.max(max, dp[j]);
        }
    }
    return max;
}
```

## 双串匹配

### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210904202857926.png" alt="image-20210904202857926" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904202908.png" alt="image-20210904202846126" style="zoom:50%;" />

**1. 状态**：`word1` 和 `word2` 的长度

* 集合：`word1` 的前 `i` 个字母转换成 `word2` 的前 `j` 个字母，所使用的操作的集合
* 属性：最小值

**2. dp数组**： `word1` 的前 `i` 个字母转换成 `word2` 的前 `j` 个字母，所使用的最少操作为 `dp[i][j]` 

**3. 状态计算**：

1. 增，`dp[i - 1][j] + 1`
2. 删，`dp[i][j - 1] + 1`，相当于在 `word2` 上增加一个元素，例如：`word1 = "ad"`，`word2 = "a"`，则 `word2` 添加一个元素 `"d"`，也相当于在 `word1` 上删除 `"d"`，二者的操作数一样。在 `word2` 在 `j - 2 `处增加一个元素，使得 `word1[i - 1] == word2[j - 1]`，所以 `dp[i][j] = dp[i][j - 1] + 1`
3. 改，`dp[i - 1][j - 1] + 1`

**4. base case**：

* `dp[i][0]`：`word2` 是空字符串，则需要删除 `word1` 的所有字符，所以 `dp[i][0] = i` 
* `dp[0][j]`：`word1` 是空字符串，则需要删除 `word2` 的所有字符，所以 `dp[0][j] = j` 

**5. 循环方式**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904203001.png" alt="image-20210904203001365" style="zoom: 80%;" />

```java
class Solution {
    public int minDistance(String s1, String s2) {
        int M = s1.length();
        int N = s2.length();
        int[][] dp = new int[M + 1][N + 1];

        for (int i = 1; i <= M; i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= N; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= M; i++) {
            for (int j = 1; j <= N; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(
                            dp[i - 1][j] + 1,
                            dp[i][j - 1] + 1,
                            dp[i - 1][j - 1] + 1
                    );
                }
            }
        }
        return dp[M][N];
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210802195418.png" alt="image-20210802195418751" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210802194603.png" alt="image-20210802194603264" style="zoom: 80%;" />

**1. 状态**：`s` 的长度 `i`，`t` 的长度 `j`

* 集合：以下标 `i - 1` 结尾的 `s` 的子序列，出现在以下标 `j - 1` 结尾的 `t` 的集合
* 属性：最大个数

**2. dp数组**：以下标 `i - 1` 结尾的 `s` 的子序列，出现在以下标 `j - 1` 结尾的 `t` 的最大个数

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907014231.png" alt="image-20210907014231356" style="zoom:67%;" />

**4. base case**：字符串 `t` 是空串时，能够匹配一个

```java
public int numDistinct(String s, String t) {
    int M = s.length();
    int N = t.length();
    int[][] dp = new int[M + 1][N + 1];

    for (int i = 0; i <= M; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[M][N];
}
```

### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210802195625.png" alt="image-20210802195624935" style="zoom:80%;" />

思路：和 [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) 类似。

**1. 状态**：`s` 的长度 `i`，`t` 的长度 `j`

* 集合：以下标 `i - 1` 结尾的字符串 `s` ，和以下标 `j - 1` 结尾的字符串 `t` ，想要达到相等，所需要删除的元素。
* 属性：最小值

**2. dp数组**：以下标 `i - 1` 结尾的字符串 `s` ，和以下标 `j - 1` 结尾的字符串 `t` ，想要达到相等，所需要删除的最少元素。

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907020053.png" alt="image-20210907020052976" style="zoom:67%;" />

**4. base case**：

* `dp[i][0]`：`word2` 是空字符串，则需要删除 `word1` 的所有字符，所以 `dp[i][0] = i` 
* `dp[0][j]`：`word1` 是空字符串，则需要删除 `word2` 的所有字符，所以 `dp[0][j] = j` 

```java
class Solution {
    public int minDistance(String s, String t) {
        int M = s.length();
        int N = t.length();
        int[][] dp = new int[M + 1][N + 1];

        for (int i = 0; i <= M; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= N; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= M; i++) {
            for (int j = 1; j <= N; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(
                            dp[i - 1][j] + 1,
                            dp[i][j - 1] + 1,
                            dp[i - 1][j - 1] + 2
                    );
                }
            }
        }
        return dp[M][N];
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907061147.png" alt="image-20210907061146900" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907061210.png" alt="image-20210907061210583" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907061224.png" alt="image-20210907061224340" style="zoom:80%;" />

不会。

**2. dp数组**： `s` 中以 `i` 为结尾的子串和 `t` 中的 `j` 为结尾的子串是否匹配

**3. 状态计算**：在 `s` 和 `t` 前面加 `‘ ’` 

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907055218.png" alt="image-20210907055218142" style="zoom:80%;" />

**4. base case**：`dp[0][0] = true;`

```java
public boolean isMatch(String ss, String tt) {
    int M = ss.length();
    int N = tt.length();
    ss = ' ' + ss;
    tt = ' ' + tt;
    char[] s = ss.toCharArray();
    char[] t = tt.toCharArray();

    boolean[][] dp = new boolean[M + 1][N + 1];
    dp[0][0] = true;

    for (int i = 0; i <= M; i++) {
        for (int j = 1; j <= N; j++) {

            if (j + 1 <= N && t[j + 1] == '*') { // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过
                continue;
            }

            if (i - 1 >= 0 && t[j] != '*') {
                dp[i][j] = dp[i - 1][j - 1] && (s[i] == t[j] || t[j] == '.');
            }

            else if (t[j] == '*') {
                dp[i][j] = (j - 2 >= 0) && dp[i][j - 2]
                    || (i - 1 >= 0) && dp[i - 1][j] && (s[i] == t[j - 1] || t[j - 1] == '.');
            }
        }
    }
    return dp[M][N];
}
```

### [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907061442.png" alt="image-20210907061441963" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907061521.png" alt="image-20210907061521381" style="zoom:80%;" />

不会。

**2. dp数组**： `s` 中以 `i` 为结尾的子串和 `t` 中的 `j` 为结尾的子串是否匹配

**3. 状态计算**：在 `s` 和 `t` 前面加 `‘ ’` 

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907063443.png" alt="image-20210907063443861" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210907063523.png" alt="image-20210907063523434" style="zoom:80%;" />

**4. base case**：`dp[0][0] = true`。`dp[i][0]` 是没有意义的。`dp[0][j]` 是有意义的，比如 `t` 是  `‘****’`

```java
public boolean isMatch(String ss, String tt) {
    int M = ss.length();
    int N = tt.length();
    ss = ' ' + ss;
    tt = ' ' + tt;
    char[] s = ss.toCharArray();
    char[] t = tt.toCharArray();

    boolean[][] dp = new boolean[M + 1][N + 1];
    dp[0][0] = true;

    for (int i = 0; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            if (t[j] != '*') {
                dp[i][j] = (i - 1 >= 0) && dp[i - 1][j - 1] && (s[i] == t[j] || t[j] == '?');
            } else {
                dp[i][j] = (i - 1 >= 0) && dp[i - 1][j] || dp[i][j - 1];
            }
        }
    }
    return dp[M][N];
}
```

## 丑数

### [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909103829.png" alt="image-20210909103829233" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909103851.png" alt="image-20210909103850936" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909103904.png" alt="image-20210909103904897" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909104116.png" alt="image-20210909104116828" style="zoom:80%;" />

思路：数学。分别整除 2，3，5，直到除不了。

```java
public boolean isUgly(int n) {
    if (n <= 0) return false;
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    return n == 1;
}
```

### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909104710.png" alt="image-20210909104710836" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909104718.png" alt="image-20210909104718670" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909104731.png" alt="image-20210909104731061" style="zoom:80%;" />

思路：DP + 三指针。`dp[i]` 表示第 `i` 个丑数。

所有的丑数都基于以往的丑数产生，即使用「已有丑数」乘上「质因数」2、3、5。

因此，如果我们所有丑数的有序序列为 `a1,a2,a3,...,an` 的话，序列中的每一个数都必然能够被以下三个序列（中的至少一个）覆盖：

* 由丑数 * 2 所得的有序序列：1 * 2、2 * 2、3 * 2、4 * 2、5 * 2、6 * 2、8 * 2...
* 由丑数 * 3 所得的有序序列：1 * 3、2 * 3、3 * 3、4 * 3、5 * 3、6 * 3、8 * 3...
* 由丑数 * 5 所得的有序序列：1 * 5、2 * 5、3 * 5、4 * 5、5 * 5、6 * 5、8 * 5...

我们每次取三个序列中的最小值。我们使用三个指针，代表三个序列的位置。

```java
public int nthUglyNumber(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;

    int i2 = 1;
    int i3 = 1;
    int i5 = 1;

    for (int i = 2; i <= n; i++) {
        int n2 = dp[i2] * 2;
        int n3 = dp[i3] * 3;
        int n5 = dp[i5] * 5;

        dp[i] = min(n2, n3, n5);

        if (n2 == dp[i]) i2++;
        if (n3 == dp[i]) i3++;
        if (n5 == dp[i]) i5++;
    }
    return dp[n];
}

private int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

### [面试题 17.09. 第 k 个数](https://leetcode-cn.com/problems/get-kth-magic-number-lcci/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912085638.png" alt="image-20210912085638680" style="zoom:80%;" />

思路：本题源于 [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)。DP + 三指针。`dp[i]` 表示第 `i` 个丑数。

```java
public int getKthMagicNumber(int k) {
    int[] dp = new int[k + 1];
    dp[1] = 1;
    int i3 = 1, i5 = 1, i7 = 1;
    for (int i = 2; i <= k; i++) {
        int n3 = dp[i3] * 3;
        int n5 = dp[i5] * 5;
        int n7 = dp[i7] * 7;

        dp[i] = min(n3, n5, n7);

        if (dp[i] == n3) i3++;
        if (dp[i] == n5) i5++;
        if (dp[i] == n7) i7++;
    }
    return dp[k];
}

private int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

### [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909135648.png" alt="image-20210909135556798" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210909135605981.png" alt="image-20210909135605981" style="zoom:80%;" />

思路：和 [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/) 一样。维护多个指针。时间：$O(NM)$，n是第n个超级丑数，m是质数数组的长度。

```java
public int nthSuperUglyNumber(int n, int[] primes) {
    int m = primes.length;
    int[] index = new int[m];
    Arrays.fill(index, 1);

    int[] dp = new int[n + 1];
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        int min = Integer.MAX_VALUE;
        for (int j = 0; j < m; j++) {
            min = Math.min(min, dp[index[j]] * primes[j]);
        }
        dp[i] = min;
        for (int j = 0; j < m; j++) {
            if (dp[index[j]] * primes[j] == dp[i]) {
                index[j]++;
            }
        }
    }
    return dp[n];
}
```

## 矩形

### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910040157.png" alt="image-20210910040157766" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910040209.png" alt="image-20210910040209501" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910043521.png" alt="image-20210910043521365" style="zoom:50%;" />

**1. 状态**：坐标 `(i, j)`

* 集合：右下角为  `(i, j)` 的正方形的边长的集合
* 属性：最大值

**2. dp数组**：右下角为  `(i, j)` 的正方形的边长的最大值

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910043603.png" alt="image-20210910043603829" style="zoom:80%;" />

```java
public int maximalSquare(char[][] mat) {
    int M = mat.length;
    int N = mat[0].length;
    int[][] dp = new int[M][N];

    int res = 0;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            if (mat[i][j] == '0') {
                dp[i][j] = 0;
            } else {
                if (!inArea(mat, i - 1, j - 1)) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = min(dp, i, j) + 1;
                }
            }
            res = Math.max(res, dp[i][j]);
        }
    }
    return res * res;
}

// 获得左边，左上，上边，边长的最小值
private int min(int[][] dp, int i, int j) {
    int a = dp[i- 1][j - 1];
    int b = dp[i][j - 1];
    int c = dp[i- 1][j];
    return Math.min(a, Math.min(b, c));
}

private boolean inArea(char[][] mat, int i, int j) {
    return i >= 0 && i < mat.length && j >= 0 && j < mat[0].length;
}
```

### [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)







### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910044003.png" alt="image-20210910044003762" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910044012.png" alt="image-20210910044012005" style="zoom:80%;" />

**1. 状态**：当前位置下标 `(i, j)`

* 集合：从 `(0, 0)` 到  `(i, j)` 的路径集合
* 属性：最小值

**2. dp数组**：从 `(0, 0)` 到  `(i, j)` 的最小路径

**3. 状态计算**：最小路径来自左边和上边

**4. base case**：`dp[0][0] = mat[0][0]`

**6. 空间优化**：使用 **滚动数组 **代替 dp数组

```java
public int minPathSum(int[][] mat) {
    int M = mat.length;
    int N = mat[0].length;
    
    int[][] dp = new int[M][N];
    dp[0][0] = mat[0][0];
    
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            if (j - 1 >= 0 && i - 1 >= 0) {
                dp[i][j] = mat[i][j] + Math.min(dp[i][j - 1], dp[i - 1][j]);
            } else {
                if (j - 1 >= 0) dp[i][j] = mat[i][j] + dp[i][j - 1];
                if (i - 1 >= 0) dp[i][j] = mat[i][j] + dp[i - 1][j];
            }
        }
    }
    return dp[M - 1][N - 1];
}
```

### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210918163455.png" alt="image-20210918163455095" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210918163515.png" alt="image-20210918163515035" style="zoom:80%;" />

**2. dp数组**：从 `(0, 0)` 到  `(i, j)` 的最大礼物价值

**3. 状态计算**：最小路径来自左边和上边

```java
public int maxValue(int[][] mat) {
    int M = mat.length;
    int N = mat[0].length;
    int[] dp = new int[N + 1];
    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            dp[j] = Math.max(dp[j - 1], dp[j]) + mat[i - 1][j- 1];
        }
    }
    return dp[N];
}
```

## 其他

### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910050454.png" alt="image-20210910050454390" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910050501.png" alt="image-20210910050501334" style="zoom:80%;" />

**1. 状态**：下标 `i`

* 集合：字符串 `s(0~i-1)` 的有效解码方式的集合
* 属性：总和

**2. dp数组**：字符串 `s(0~i-1)` 的有效解码方式的总和为 `dp[i]`

**3. 状态计算**：向字符串开头添加空格，避免出现前导0，简化 `dp[i-1]` 等负数下标的判断。

假设当前位置组成的数是a，上一个位置和当前位置组成的数是b

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910053054.png" alt="image-20210910053054684" style="zoom:80%;" />

**4. base case**：`dp[0] = 1`

```java
public int numDecodings(String ss) {
    int N = ss.length();
    ss = " " + ss;
    char[] s = ss.toCharArray();
    
    int[] dp = new int[N + 1];
    dp[0] = 1;

    for (int i = 1; i <= N; i++) {
        int a = s[i] - '0';									// 当前位置组成的数是a
        int b = (s[i - 1] - '0') * 10 + s[i] - '0';			// 上一个位置和当前位置组成的数是b
        if (a >= 1 && a <= 9) dp[i] = dp[i - 1];
        if (b >= 10 && b <= 26) dp[i] += dp[i - 2];
    }
    return dp[N];
}
```

### [639. 解码方法 II](https://leetcode-cn.com/problems/decode-ways-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210927015721.png" alt="image-20210927015721259" style="zoom:80%;" />

**1. 状态**：下标 `i`

* 集合：字符串 `s(0~i-1)` 的有效解码方式的集合
* 属性：总和

**2. dp数组**：字符串 `s(0~i-1)` 的有效解码方式的总和为 `dp[i]`

**3. 状态计算**：向字符串开头添加空格，避免出现前导0，简化 `dp[i-1]` 等负数下标的判断。

`s[i]` 的解码方式 =  `s[i]` 为独立数字的个数 + `s[i - 1]` 和 `s[i]` 的组合数的数量

* `s[i]` 为 `*` ：
  * `s[i]` 可为 1 ~ 9，即 `dp[i] += dp[i - 1] * 9`
  * `s[i - 1]` 为 1，那么 `s[i - 1]` 和 `s[i]` 的组合数为 11 ~ 19，即 `dp[i] += dp[i - 2] * 9`
  * `s[i - 1]` 为 2，那么 `s[i - 1]` 和 `s[i]` 的组合数为 20 ~ 26，即 `dp[i] += dp[i - 2] * 6`
  * `s[i - 1]` 为 #，那么 `s[i - 1]` 和 `s[i]` 的组合数为 11 ~ 26，即 `dp[i] += dp[i - 2] * 15`
* `s[i]` 为 数字：
  * `s[i]` 为独立的数字，即 `dp[i] += dp[i - 1]`
  * `s[i - 1]` 为 1，那么 `s[i - 1]` 和 `s[i]` 的组合数为 1x，即 `dp[i] += dp[i - 2]`
  * `s[i - 1]` 为 2，如果 `s[i]` 为 0 ~ 6，那么 `s[i - 1]` 和 `s[i]` 的组合数为 2x，即 `dp[i] += dp[i - 2]`
  * `s[i - 1]` 为 #，
    * 如果 `s[i]` 为 0 ~ 6，那么 `s[i - 1]` 和 `s[i]` 的组合数为 1x 和 2x，即 `dp[i] += dp[i - 2] * 2`
    * 如果 `s[i]` 为 7 ~ 9，那么 `s[i - 1]` 和 `s[i]` 的组合数为 1x，即 `dp[i] += dp[i - 2]`

```java
    public int numDecodings(String ss) {
        int MOD = (int) (1e9 + 7);
        ss = " " + ss;
        char[] s = ss.toCharArray();
        int N = s.length;
        long[] dp = new long[N];
        dp[0] = 1;
        if (s[1] == '*') dp[1] = 9;
        if (s[1] >= '1' && s[1] <= '9') dp[1] = 1;
        for (int i = 2; i < N; i++) {
            if (s[i] == '*') {
                dp[i] += dp[i - 1] * 9;
                if (s[i - 1] == '1') dp[i] += dp[i - 2] * 9;
                if (s[i - 1] == '2') dp[i] += dp[i - 2] * 6;
                if (s[i - 1] == '*') dp[i] += dp[i - 2] * 15;
            } else {
                if (s[i] != '0') dp[i] += dp[i - 1];
                if (s[i - 1] == '1') dp[i] += dp[i - 2];
                if (s[i - 1] == '2' && s[i] >= '0' && s[i] <= '6') dp[i] += dp[i - 2];
                if (s[i - 1] == '*') {
                    if (s[i] >= '0' && s[i] <= '6') dp[i] += dp[i - 2] * 2;
                    if (s[i] >= '7' && s[i] <= '9') dp[i] += dp[i - 2];
                }
            }
            dp[i] %= MOD;
        }
        return (int) dp[N - 1];
    }
```

### [1048. 最长字符串链](https://leetcode-cn.com/problems/longest-string-chain/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210921154256.png" alt="image-20210921154256814" style="zoom:80%;" />

**2. dp数组**：`dp[i]` 是 `words[0]` 到 `words[i]` 的最长字符串链

**3. 状态计算**：如果 `words[k]` 是 `words[i]` 的前身，就更新长度

**4. base case**：全初始化为 1

**5. 循环方式**：外层枚举数组，内层枚举到当前位置

还要对数组进行排序，按照字符串长度排序。

```java
public int longestStrChain(String[] w) {
    Arrays.sort(w, (o1, o2) -> o1.length() - o2.length());
    int N = w.length;
    int[] dp = new int[N];
    Arrays.fill(dp, 1);
    for (int i = 1; i < N; i++) {
        for (int k = 0; k < i; k++) {
            if (isChain(w[k], w[i])) {
                dp[i] = Math.max(dp[i], dp[k] + 1);
            }
        }
    }
    int res = 0;
    for (int d : dp) {
        res = Math.max(res, d);
    }
    return res;
}

private boolean isChain(String s, String t) {
    if (s.length() != t.length() - 1) return false;
    int i = 0;
    for (int j = 0; j < t.length(); j++) {
        if (i == s.length()) return true;
        if (s.charAt(i) == t.charAt(j)) i++;
    }
    return i == s.length();
}
```

# 背包DP

## 01背包

背包问题的遍历顺序：从右上角向左下方遍历，或者从左上角向右下方遍历

### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905032117.png" alt="image-20210905032116981" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905043614.png" alt="image-20210905043614649" style="zoom:80%;" />

思路：01背包最值问题。容量为 `sum / 2` 的背包，是否能装满 `sum / 2` 价值的物品。

**1. 状态**：背包容量 `j`

**2. DP数组**：容量为 `j` 的背包，背的物品最大价值为 `dp[j]`

**3. 选择**：

* 不背第`j`个物品：`dp[j]`
* 背第`j`个物品：`dp[j - nums[i]] + nums[i]`

**4. 递推公式**：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`

**5. base case**：`dp[0] = 0`

**6. DP数组移动方向**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905044601.png" alt="image-20210905044601661" style="zoom: 67%;" />

```java
public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    if ((sum & 1) == 1) {
        return false;
    }

    int target = sum / 2;
    int[] dp = new int[target + 1];
    dp[0] = 0;

    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= 0; j--) {
            if (j - nums[i] >= 0) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
    }
    return dp[target] == target;
}
```

### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905045257.png" alt="image-20210905045257321" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210727152607.png" alt="image-20210727152606922" style="zoom: 50%;" />

不会 * 2

思路：01背包组合问题。

原问题等同于，找到 `nums` 的一个`正子集P` 和 一个`负子集N`，使得总和等于 `S`。

​	即 `sum(P) - sum(N) == target`

​	即 `sum(P) + sum(N) + sum(P) - sum(N) == S + sum(P) + sum(N)`

​	即 `2 * sum(P) == S + sum(nums)`，其中 `S + sum(nums)` 必须 >=0 且为 偶数，否则等式不可能成立。

则问题转换为：**存在多少个子集P，使 `sum(P) == (S + sum(nums))/2`**

代码中 `sum(P)` 简写为 `target`，`sum(nums)` 简写为 `sum` 。

**1. 状态**：`sum(P)`的值，`sum(P)` 最大为 `(S + sum) / 2`

**2. DP数组**：容量为 `j` 的背包，一共有`dp[j]` 种方法

**3. 选择**：

* 不选择第`i`个物品：`dp[i - 1][j]`
* 选择第`i`个物品：`dp[i - 1][j - nums[i]]`

**4. 递推公式**：两个选择加起来，`dp[j] += dp[j - nums[i]]`

**5. base case**：`dp[0] = 1`，装满容量为0的背包，只有一种方法，就是什么都不装。

**6. DP数组移动方向**：外层**正序**遍历物品，内层**逆序**遍历背包容量

```java
public int findTargetSumWays(int[] nums, int S) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    if (S > sum || ((S + sum) & 1) == 1) {
        return 0;
    }

    int target = (S + sum) / 2;
    if (target < 0) {
        return 0;
    }

    int[] dp = new int[target + 1];
    dp[0] = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[target];
}
```

### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905055340.png" alt="image-20210905055340390" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905055354.png" alt="image-20210905055354288" style="zoom:80%;" />

不会 * 2

思路：01背包最值问题。尽可能的把石头分为重量相同的两堆，使得相撞后剩下的石头重量最小。

**2. DP数组**：容量为 `j` 的背包，所背的**石头重量**最大为 `dp[j]`

**3. 选择**：不背或背第 `i` 块石头

**4. 递推公式**：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`

**举例推导DP数组**：`int[] nums = [2,4,1,1]`，此时 `target = (2 + 4 + 1 + 1) / 2 = 4 ` 

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210731014107.png" alt="image-20210731014107452" style="zoom: 67%;" />

最后 **`dp[target]`** 里是**容量为 `target` 的背包所能背的最大重量**。 

那么分成两堆石头，⼀堆石头的总重量是`dp[target]`，另⼀堆就是 `sum - dp[target]` 。  

在计算 `target` 的时候，`target = sum / 2` 因为是向下取整，所以 `sum - dp[target]` ⼀定是大于等于 `dp[target]` 的。那么相撞之后剩下的最小石头重量就是 `(sum - dp[target]) - dp[target]`。  

```java
public int lastStoneWeightII(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    int target = sum / 2;

    int[] dp = new int[target + 1];
    dp[0] = 0;

    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
    return (sum - dp[target]) - dp[target];
}
```

## 完全背包

### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905065730.png" alt="image-20210905065730465" style="zoom:80%;" />

不会 * 2

思路：完全背包存在问题。

**1. 状态**：

**2. DP数组**：**长度为`j` 的字符串，是否能拆分为一个或多个在字典中出现的单词**

**4. 递推公式**：如果 `dp[i]` 为 true，而且 `[i,j]` 这个区间的子串出现在字典里，那么 `dp[j]` 为 true

**5. base case**：`dp[0] = true  `

**6. DP数组移动方向**：外层正序 `[0, target - 1]`，内层正序 `[i + 1, target]`

```java
public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> set = new HashSet<>(wordDict);

    int N = s.length();
    boolean[] dp = new boolean[N + 1];
    dp[0] = true;

    for (int i = 0; i <= N - 1; i++) {
        for (int j = i + 1; j <= N; j++) {
            if (dp[i] && set.contains(s.substring(i, j))) {
                dp[j] = true;
            }
        }
    }
    return dp[N];
}
```

### [140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910032640.png" alt="image-20210910032640350" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910032650.png" alt="image-20210910032649905" style="zoom:80%;" />

思路：DP + 暴搜（DFS回溯）。

DP数组**：**长度为`j` 的字符串，是否能拆分为一个或多个在字典中出现的单词。

暴搜：如果搜到头了，就添加到结果中，注意删除末尾的空格。

```java
List<String> res = new ArrayList<>();
int N;
Set<String> set;
boolean[] dp;

public List<String> wordBreak(String s, List<String> wordDict) {
    N = s.length();
    set = new HashSet<>(wordDict);
    dp = new boolean[N + 1];
    dp[0] = true;

    for (int i = 0; i <= N - 1; i++) {
        for (int j = i + 1; j <= N; j++) {
            if (dp[i] && set.contains(s.substring(i, j))) {
                dp[j] = true;
            }
        }
    }
    dfs(s, 0, "");
    return res;
}

private void dfs(String s, int start, String path) {
    if (start == N) {
        res.add(path.substring(0, path.length() - 1));
    }
    for (int i = start; i < N; i++) {
        String word = s.substring(start, i + 1);
        if (dp[i + 1] && set.contains(word)) {
            dfs(s, i + 1, path + word + " ");
        }
    }
}
```

### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905072437.png" alt="image-20210905072437837" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905072446.png" alt="image-20210905072445973" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210731041051.png" alt="image-20210731041051317" style="zoom: 80%;" />

思路：完全背包最值问题。

**1. 状态**：总和为 `j`

**2. DP数组**：**总和为`j` 的数，其完全平方数的最少数量为 `dp[j]`**

**3. 选择**：不选择/选择这个完全平方数

**4. 递推公式**：`dp[j] = min(dp[j], dp[j -i * i] + 1)  `

**5. base case**：`dp[0] = 0  `，0没有完全平方数，其余全初始化为比target大的值就好

**6. DP数组移动方向**：外层正序完全平方数，内层正序 `完全平方数的平方 ~ target`

```java
public int numSquares(int target) {
    int[] dp = new int[target + 1];
    Arrays.fill(dp, target + 1);
    dp[0] = 0;

    for (int i = 1; i <= target; i++) {
        for (int j = i * i; j <= target; j++) {
            dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
        }
    }
    return dp[target];
}
```

### [1155. 掷骰子的N种方法](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905170620.png" alt="image-20210905170620840" style="zoom:80%;" />

不会 * 2

思路：完全背包排列问题。

**1. 状态**：仍 i 个骰子，得到的总和为 j ，当前骰子的点数为 k

**2. DP数组**：仍 i 个骰子，得到的总和为 j 的组合数为 `dp[i][j]`

**3. 选择**：不保留/保留当前骰子

**4. 递推公式**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905170424.png" alt="png" style="zoom:80%;" />

**5. base case**：`dp[0][0] = 1  `

**6. DP数组移动方向**：枚举物品，枚举背包容量（1~target）

```java
public int numRollsToTarget(int N, int M, int target) {
    long MOD = (long) (1e9 + 7);
    long[][] dp = new long[N + 1][target + 1];
    dp[0][0] = 1;

    // 枚举物品
    for (int i = 1; i <= N; i++) {
        // 枚举背包容量
        for (int j = 1; j <= target; j++) {
            // 枚举骰子能投出去的点数
            for (int k = 1; k <= M; k++) {
                if (j - k >= 0) {
                    dp[i][j] += dp[i - 1][j - k];
                    dp[i][j] %= MOD;
                }
            }
        }
    }
    return (int) dp[N][target];
}
```

### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904023954.png" alt="image-20210904023954085" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904024005.png" alt="image-20210904024005475" style="zoom:80%;" />

示例1的DP状态：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904025206.png" alt="image-20210904025206419" style="zoom:33%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210731031456.png" alt="image-20210731031456186" style="zoom:80%;" />

思路：完全背包最值问题。

**1. 状态**：

**2. DP数组**：凑出金额 `j` ，至少需要 `dp[j] ` 枚硬币 

**3. 选择**：

**4. 递推公式**：`dp[j] = min(dp[j], dp[j - nums[i]] + 1)  `

**5. base case**：`dp[0] = 0  `，其余比`amount`大就行

**6. DP数组移动方向**：外层正序 `nums`，内层正序 `nums[i] ~ target`

```java
public int coinChange(int[] nums, int target) {
    int[] dp = new int[target + 1];
    Arrays.fill(dp, target + 1);
    dp[0] = 0;

    for (int i = 0; i < nums.length; i++) {
        for (int j = nums[i]; j <= target; j++) {
            dp[j] = Math.min(dp[j], dp[j - nums[i]] + 1);
        }
    }
    return dp[target] == target + 1 ? -1 : dp[target];
}
```

### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904023721.png" alt="image-20210904023721575" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909051644.png" alt="image-20210909051644909" style="zoom:80%;" />

**举例推导DP数组**：`int target = 5`，`int[] nums = {1,2,5}`

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210730232807.png" alt="image-20210730232807053" style="zoom:80%;" />

思路：完全背包排列问题。

**1. 状态**：

**2. DP数组**：凑出总金额为 `j` 的硬币组合数为 `dp[j]`

**3. 选择**：

**4. 递推公式**：`dp[j] += dp[j - nums[i]]  `

**5. base case**：`dp[0] = 1  `

**6. DP数组移动方向**：外层正序 `nums`，内层正序 `nums[i] ~ target`

```java
public int change(int target, int[] nums) {
    int[] dp = new int[target + 1];
    dp[0] = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = nums[i]; j <= target; j++) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[target];
}
```

### [377. 排列总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909050136.png" alt="image-20210909050107378" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909050133.png" alt="image-20210909050117063" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909060300.png" alt="image-20210909060300139" style="zoom:50%;" />

思路：完全背包组合问题。

**2. dp数组**：`dp[j]`：总和为 `j` 的方案总数。

```java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int j = 0; j <= target; j++) {
        for (int i = 0; i < nums.length; i++) {
            if (j >= nums[i]) {
                dp[j] += dp[j - nums[i]];
            }
        }
    }
    return dp[target];
}
```

### [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912082316.png" alt="image-20210912082316507" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912082326.png" alt="image-20210912082326906" style="zoom:80%;" />

**1. 状态**：总金额

* 集合：凑出总金额 `i` 的方案集合
* 属性：最大值

**2. dp数组**：凑出总金额 `i` 的最大方案数是 `dp[i]`

**3. 状态计算**：`dp[j] += dp[j - nums[i]]`

**4. base case**：`dp[0] = 1`

```java
public int waysToChange(int n) {
    int MOD = (int) (1e9 + 7);
    int[] nums = {1,5,10,25};
    long[] dp = new long[n + 1];
    dp[0] = 1L;
    for (int i = 0; i < nums.length; i++) {			// 枚举硬币
        for (int j = nums[i]; j <= n; j++) {			// 枚举总金额
            dp[j] += dp[j - nums[i]];
            dp[j] %= MOD;
        }
    }
    return (int) dp[n];
}
```

## 二维费用背包

### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909062451.png" alt="image-20210909062451402" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909062501.png" alt="image-20210909062501671" style="zoom:80%;" />

思路：二维费用背包最值问题。要先统计每个字符串中 0和1的个数。

**1. 状态**：第 i 个物品 0 和 1 的个数

* 集合：有 j 个 0 和 k 个 1 的子集大小
* 属性：最大值

**2. dp数组**：**`dp[j][k]`** 表示 **有 j 个 0 和 k 个 1 的最大子集的大小**

**3. 状态计算**：

**5. 循环方式**：正序枚举物品，逆序枚举体积，逆序枚举重量。

```java
public int findMaxForm(String[] strs, int V, int M) {
    int N = strs.length;
    int[] zero = new int[N];
    int[] one = new int[N];
    for (int i = 0; i < N; i++) {
        int zeroCount = 0;
        int oneCount = 0;
        for (char c : strs[i].toCharArray()) {
            if (c == '0') {
                zeroCount++;
            }
            else if (c == '1') {
                oneCount++;
            }
        }
        zero[i] = zeroCount;
        one[i] = oneCount;
    }

    int[][] dp = new int[V + 1][M + 1];
    for (int i = 0; i < N; i++) {
        for (int j = V; j >= zero[i]; j--) {
            for (int k = M; k >= one[i]; k--) {
                dp[j][k] = Math.max(dp[j][k], dp[j - zero[i]][k - one[i]] + 1);
            }
        }
    }
    return dp[V][M];
}
```

### [879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909064541.png" alt="image-20210909064541785" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210909064552.png" alt="image-20210909064552327" style="zoom:80%;" />

思路：二维费用背包组合问题。

**1. 状态**：第 i 种工作，需要的员工数和利润

* 集合：员工数为 `j`，利润 `k` 的集合
* 属性：总和

**2. dp数组**：员工数为 `j`，至少工作利润为 `k` 的组合数量

**3. 状态计算**：`dp[j][k] += dp[j - v[i]][Math.max(0, k - m[i])];`

**4. base case**：第 0 列为 1

**5. 循环方式**：枚举任务，逆序枚举员工，逆序枚举利润

```java
// 员工总数，最小利润，员工数，利润
public int profitableSchemes(int V, int M, int[] v, int[] m) {
    int MOD = (int) (1e9 + 7);
    int N = v.length;
    long[][] dp = new long[V + 1][M + 1];
    for (int i = 0; i <= V; i++) {
        dp[i][0] = 1;
    }

    for (int i = 0; i < N; i++) {
        for (int j = V; j >= v[i]; j--) {
            for (int k = M; k >= 0; k--) {
                dp[j][k] += dp[j - v[i]][Math.max(0, k - m[i])];
                dp[j][k] %= MOD;
            }
        }
    }
    return (int) dp[V][M];
}
```









# 区间DP

### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905235240.png" alt="image-20210905235240585" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905235259.png" alt="image-20210905235259352" style="zoom:80%;" />

思路：区间DP最值问题。子序列不是连续的。

**1. 状态**：区间`[i, j]`

* 集合：区间`[i, j]`上回文子序列的集合
* 属性：最大值

**2. dp数组**：区间`[i, j]`上回文子序列的最大值

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906001534.png" alt="image-20210906001534666" style="zoom: 80%;" />

**4. DP数组移动方向**：区间长度，区间左边界。

```java
public int longestPalindromeSubseq(String s) {
    int N = s.length();
    int[][] dp = new int[N][N];

    for (int i = 0; i < N; i++) {
        dp[i][i] = 1;
    }

    for (int len = 2; len <= N; len++) {
        for (int i = 0; i + len - 1 < N; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][N - 1];
}
```

### [1000. 合并石头的最低成本](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905173310.png" alt="image-20210905173310676" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905173329.png" alt="image-20210905173329382" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905210645.png" alt="image-20210905210645753" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905210344.png" alt="image-20210905210343966" style="zoom:80%;" />

思路：区间DP最值问题。

**1. 状态**：区间`[i, j]`

* 集合：将区间`[i, j]`合并为一堆的成本的集合
* 属性：最小值

**2. dp数组**：将区间`[i, j]`合并为一堆的成本的最小值

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905232137.png" alt="image-20210905232137602" style="zoom: 67%;" />

**4. DP数组移动方向**：枚举区间长度，枚举左边界，枚举分界点。

```java
public int mergeStones(int[] nums, int k) {
    int N = nums.length;
    if ((N - 1) % (k - 1) != 0) {
        return -1;
    }

    int[] sum = new int[N + 1];                 // 前缀和数组
    for (int i = 1; i <= N; i++) {
        sum[i] = sum[i - 1] + nums[i - 1];
    }

    int[][] dp = new int[N + 1][N + 1];
    for (int len = k; len <= N; len++) {        // 枚举区间长度
        for (int i = 1; i + len - 1 <= N; i++) {    // 枚举区间左端点
            int j = i + len - 1;                        // 右端点
            dp[i][j] = Integer.MAX_VALUE;
            for (int p = i; p < j; p += k - 1) {        // 枚举区间分界点
                dp[i][j] = Math.min(dp[i][j], dp[i][p] + dp[p + 1][j]);
            }
            if ((j - i) % (k - 1) == 0) {               // 如果可以继续合并，dp[i][j] += sum(i, j)
                dp[i][j] += sum[j] - sum[i - 1];
            }
        }
    }
    return dp[1][N];
}
```

### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906001858.png" alt="image-20210906001857984" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906001904.png" alt="image-20210906001904691" style="zoom:80%;" />

**1. 状态**：区间`[i, j]`

* 集合：区间`[i, j]`上获得硬币的集合
* 属性：最大值

**2. dp数组**：区间`[i, j]`上获得硬币的最大值

**3. 状态计算**：假设每次只能戳爆 `(i,j)` 之间的气球，`k` 是这个区间内最后一个被戳爆的气球。则：

`dp[i][j] = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]`

为了获得最大值，我们需要枚举区间`(i,j)` 内的每个气球。为了处理边界情况，我们要在原数组的基础上首尾添0。

**5. DP数组移动方向**：区间长度，区间左边界，区间之内的所有点（即最后被戳爆的点）。

```java
public int maxCoins(int[] oldNums) {
    int[] nums = new int[oldNums.length + 2];
    int N = nums.length;
    nums[0] = 1;
    for (int i = 0; i < oldNums.length; i++) {
        nums[i + 1] = oldNums[i];
    }
    nums[N - 1] = 1;

    int[][] dp = new int[N][N];

    for (int len = 2; len <= N; len++) {
        for (int i = 0; i + len - 1 < N; i++) {
            int j = i + len - 1;
            for (int k = i + 1; k < j; k++) {
                dp[i][j] = Math.max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]);
            }
        }
    }
    return dp[0][N - 1];
}
```

### [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906012059.png" alt="image-20210906012059127" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906012106.png" alt="image-20210906012106676" style="zoom:80%;" />

**1. 状态**：区间`[i, j]`

* 集合：区间`[i, j]`上打印次数的集合
* 属性：最小值

**2. dp数组**：区间`[i, j]`上打印次数的最小值

**3. 状态计算**：

* 假设第 `i` 个字母与区间 `[i + 1, j]` 内的每一个字母都不相同：`dp[i][j] = dp[i + 1][j] + 1`
* 假设区间里有字母和第 `i` 个字母s相同：`dp[i][k - 1] + dp[k + 1][j]`

**4. base case**：区间长度为 `1` 的字符串 最少也要打印一次，`dp[i][i] = 1`

**5. 三重循环**：区间长度，区间左边界，区间分界点

```java
public int strangePrinter(String s) {
    int N = s.length();
    int[][] dp = new int[N + 1][N + 1];
    
    for (int i = 0; i < N; i++) {
        dp[i][i] = 1;
    }

    for (int len = 2; len <= N; len++) {
        for (int i = 0; i + len - 1 < N; i++) {
            int j = i + len - 1;

            dp[i][j] = dp[i + 1][j] + 1;
            for (int k = i + 1; k <= j; k++) {
                if (s.charAt(i) == s.charAt(k)) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][k - 1] + dp[k + 1][j]);
                }
            }
        }
    }
    return dp[0][N - 1];
}
```

### [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210923164117.png" alt="image-20210923164116919" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210923164140.png" alt="image-20210923164139962" style="zoom:80%;" />

**2. dp数组**：`dp[i][j]` 表示闭区间 `[i,j]` 下，先手玩家（玩家1）与后手玩家（玩家2）的得分差距的最大值。

**3. 状态计算**：每次可以选择左端点或者右端点。此时是先手玩家，被转移的区间就是后手玩家的得分，所以需要 取相反数 然后转移。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210923171107.png" alt="image-20210923171107656" style="zoom: 80%;" />

**4. base case**：`dp[i][i] = nums[i]`

**5. 双重循环**：枚举区间长度，再枚举区间左边界

```java
public boolean PredictTheWinner(int[] nums) {
    int N = nums.length;
    int[][] dp = new int[N][N];

    for (int i = 0; i < N; i++) {
        dp[i][i] = nums[i];
    }

    for (int len = 2; len <= N; len++) {
        for (int i = 0; i + len - 1 < N; i++) {
            int j = i + len - 1;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][N - 1] >= 0;
}
```

# 递推型DP

### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904225414.png" alt="image-20210904225414465" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904225422.png" alt="image-20210904225422537" style="zoom:80%;" />

**1. 状态**：当前所在的台阶

**2. DP数组**：到达第 `i` 个台阶由 `dp[i]` 种方法

**3. 选择**：每次从`i - 1`来或从`i - 2`来

**4. 递推公式**：`dp[n] = dp[n - 1] + dp[n - 2]`

**5. base case**：`dp[0] = 0` ，`dp[1] = 1`，`dp[2] = 2`

**6. DP数组移动方向**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904230702.png" alt="image-20210904230702588" style="zoom:67%;" />

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }

    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

**7. 空间优化**：使用 **滚动数组 **代替 dp数组。

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }

    int pre = 1;
    int cur = 2;
    
    for (int i = 3; i <= n; i++) {
        int temp = pre + cur;
        pre = cur;
        cur = temp;
    }
    return cur;
}
```

**爬楼梯进阶**：力扣无原题。如果⼀步⼀个台阶，两个台阶，三个台阶。有多少种方法爬到第n个台阶。  

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }

    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }
    return dp[n];
}
```

### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905024753.png" alt="image-20210905024753318" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905024731.png" alt="image-20210905024731186" style="zoom: 67%;" />

**1. 状态**：第 i 层 台阶

**2. DP数组**：到达台阶 `i` 所花费总体力的最小值

**3. 选择**：可从`i - 1`来或从`i - 2`来

**4. 递推公式**：`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`

**5. base case**：`dp[0] = 0`，`dp[1] = 0`

```java
public int minCostClimbingStairs(int[] cost) {
    int N = cost.length;
    int[] dp = new int[N + 1];

    dp[0] = 0;
    dp[1] = 0;

    for (int i = 2; i <= N; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[N];
}
```

**6. 空间优化**：使用 **滚动数组 **代替 dp数组。

```java
public int minCostClimbingStairs1(int[] cost) {
    int N = cost.length;
    
    int pre = 0;
    int cur = 0;

    for (int i = 2; i <= N; i++) {
        int temp = Math.min(pre + cost[i - 2], cur + cost[i - 1]);
        pre = cur;
        cur = temp;
    }
    return cur;
}
```

### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905020129.png" alt="image-20210905020129363" style="zoom:80%;" />

思路：第 i 个斐波拉契数是 dp[i] 。

```java
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    int[] dp = new int[n + 1];
    
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

**6. 空间优化**：使用 **滚动数组 **代替 dp数组。

```java
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }

    int pre = 0;
    int cur = 1;
    
    for (int i = 2; i <= n; i++) {
        int temp = pre + cur;
        pre = cur;
        cur = temp;
    }
    return cur;
}
```

### [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906065612.png" alt="image-20210906065611903" style="zoom:80%;" />

```java
public int tribonacci(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }

    int x = 0;
    int y = 1;
    int z = 1;

    for (int i = 3; i <= n; i++) {
        int sum = x + y + z;
        x = y;
        y = z;
        z = sum;
    }
    return z;
}
```

### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905013115.png" alt="image-20210905013115543" style="zoom:80%;" />

**1. 状态**：正整数 `i`

**2. DP数组**：将正整数 `i` 拆分成至少两个正整数的和之后，它们的乘积为 `dp[i]`

**3. 选择**：当 `i >= 2` 时，假设对正整数 `i` 拆分出的第一个正整数是 `k (1 <= k <= i)`，则有以下两种方案：

* 将 $i$ 拆分成 $k$ 和 $i-k$ 的和，且 $i-k$ **不再拆分**成多个正整数，此时的乘积是 $k \times (i-k)$；

* 将 $i$ 拆分成 $k$ 和 $i-k$ 的和，且 $i-k$ **可以拆分**成多个正整数，此时的乘积是 $k \times dp(i-k)$；

**4. 递推公式**：<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210905015409.png" alt="png" style="zoom:67%;" />

**5. base case**：`dp[0] = 0`，`dp[1] = 0`

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    
    dp[0] = 0;
    dp[1] = 0;

    for (int i = 2; i <= n; i++) {
        for (int k = 1; k <= i - 1; k++) {
            dp[i] = max(
                dp[i],
                k * (i - k),
                k * dp[i - k]
            );
        }
    }
    return dp[n];
}

private int max(int a, int b, int c) {
    return Math.max(a, Math.max(b, c));
}
```

* 时间：$O(N^{2})$
* 空间：$O(N)$

### [LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210705215427109.png" alt="image-20210705215427109" style="zoom:80%;" />

实例1图示：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210705215303735.png" alt="image-20210705215303735" style="zoom: 67%;" />

思路：**动态规划**（最优解）。

**1. 状态**：传递次数和编号

* 集合：经过 `i` 次传递到编号 `j` 的方案的集合
* 属性：总和

**2. dp数组**：经过 `i` 次传递到编号 `j` 的方案总数为 `dp[i][j]`

**3. 状态计算**：`dp[i + 1][dst] += dp[i][src]`

**4. base case**：`dp[0][0] = 1`

**5. 枚举方式**：枚举传递次数，枚举路径

```java
public int numWays(int n, int[][] relation, int k) {
    int[][] dp = new int[k + 1][n];
    dp[0][0] = 1;

    for (int i = 0; i < k; i++) {
        for (int[] node : relation) {
            int src = node[0];
            int dst = node[1];
            dp[i + 1][dst] += dp[i][src];
        }
    }
    return dp[k][n - 1];
}
```

### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912072308.png" alt="image-20210912072308841" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912072314.png" alt="image-20210912072314899" style="zoom:80%;" />

思路：

* 奇数：二进制表示中，**奇数一定比前面那个偶数多一个 1**，因为多的就是最低位的 1。

- ```
            举例： 
           0 = 0       1 = 1
           2 = 10      3 = 11
  ```

* 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，**除以 2** 就是右移一位，也就是把那个 0 抹掉而已，所以 **1 的个数是不变的**。

*            举例：
            2 = 10       4 = 100       8 = 1000
            3 = 11       6 = 110       12 = 1100

代码：

```java
public int[] countBits(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    for (int i = 0; i <= n; i++) {
        if ((i & 1) == 1) dp[i] = dp[i - 1] + 1;
        else dp[i] = dp[i / 2];
    }
    return dp;
}
```

## 三角形

### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910055410.png" alt="image-20210910055410003" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910055422.png" alt="image-20210910055422503" style="zoom:80%;" />

思路：注意两边都是1。

```java
public List<List<Integer>> generate(int N) {
    List<List<Integer>> res = new ArrayList<>();
    for (int i = 0; i < N; i++) {
        List<Integer> row = new ArrayList<>();
        for (int j = 0; j <= i; j++) {
            if (j == 0 || j == i) {
                row.add(1);
            } else {
                row.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));
            }
        }
        res.add(row);
    }
    return res;
}
```

### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912064724.png" alt="image-20210912064724115" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912064741.png" alt="image-20210912064740897" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210912065124.png" alt="image-20210912065123973" style="zoom:80%;" />

```java
public List<Integer> getRow(int n) {
    Integer[] row = new Integer[n + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = i; j >= 0; j--) {
            if (j == 0) {
                row[0] = 1;
                continue;
            }
            if (j == i) {
                row[i] = 1;
                continue;
            }
            row[j] = row[j - 1] + row[j];
        }
    }
    return Arrays.asList(row);
}
```

### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210906053910248.png" alt="image-20210906053910248" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210906053924226.png" alt="image-20210906053924226" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906062002.png" alt="image-20210906062002538" style="zoom: 50%;" />

**1. 状态**：第 `i` 层，第 `j `个节点

* 集合：第 `i` 层，第 `j `个节点的路径和的集合
* 属性：最小值

**2. dp数组**：第 `i` 层，第 `j `个节点的最小路径和

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906061907.png" alt="image-20210906061907458" style="zoom: 67%;" />                                                                                

**4. base case**：提前存入第0行的节点

**6. 空间优化**：使用 **滚动数组 **代替 dp数组

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int[] dp = new int[triangle.get(triangle.size() - 1).size()];
    dp[0] = triangle.get(0).get(0);

    for (int i = 1; i < triangle.size(); i++) {
        for (int j = triangle.get(i).size() - 1; j >= 0; j--) {
            int a = j - 1 < 0 ? Integer.MAX_VALUE : dp[j - 1] + triangle.get(i).get(j);
            int b = j >= triangle.get(i - 1).size() ? Integer.MAX_VALUE : dp[j] + triangle.get(i).get(j);
            dp[j] = Math.min(a, b);
        }
    }

    int min = Integer.MAX_VALUE;
    for (int num : dp) {
        min = Math.min(min, num);
    }
    return min;
}
```

# 计数型DP

### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210904223739022.png" alt="image-20210904223739022" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904223754.png" alt="image-20210904223745629" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224153.png" alt="image-20210904224152948" style="zoom:50%;" />

**1. 状态**：当前位置 `(i, j)`

**2. DP数组**：从 `(0,0)` 出发到 `(i,j)` ，一共有 `dp[i][j]` 条不同的路径

**3. 选择**：每次选择向下或向右走，对应当前位置只能由左边和上边来

**4. 递推公式**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**5. base case**：第0行和第0列都初始为 1

**6. DP数组移动方向**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224141.png" alt="image-20210904224141727" style="zoom:67%;" />

```java
public int uniquePaths(int M, int N) {
    int[][] dp = new int[M][N];

    for (int i = 0; i < M; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < N; j++) {
        dp[0][j] = 1;
    }

    for (int i = 1; i < M; i++) {
        for (int j = 1; j < N; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[M - 1][N - 1];
}
```

* 时间：$O(M*N)$
* 空间：$O(M*N)$

**6. 空间优化**：使用 **滚动数组 **代替 dp数组。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210726173720.png" alt="image-20210726173719873" style="zoom: 50%;" />

```java
public int uniquePaths(int M, int N) {
    int[] dp = new int[N];
    for (int j = 0; j < N; j++) {
        dp[j] = 1;
    }

    for (int i = 1; i < M; i++) {
        for (int j = 1; j < N; j++) {
            dp[j] = dp[j] +  dp[j - 1];
        }
    }

    return dp[N - 1];
}
```

* 时间：$O(M*N)$
* 空间：$O(N)$

### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224637.png" alt="image-20210904224637632" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224648.png" alt="image-20210904224648241" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224734.png" alt="image-20210904224734160" style="zoom: 50%;" />

**1. 状态**：当前位置 `(i, j)`

**2. DP数组**：从 `(0,0)` 出发到 `(i,j)` ，一共有 `dp[i][j]` 条不同的路径

**3. 选择**：每次选择向下或向右走，对应当前位置只能由左边和上边来

**4. 递推公式**：如果当前位置上没有障碍物的话，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**5. base case**：第0行和第0列在没有遇到障碍物之前都初始化为 1

**6. DP数组移动方向**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904224141.png" alt="image-20210904224141727" style="zoom:67%;" />

```java
public int uniquePathsWithObstacles(int[][] mat) {
    int M = mat.length;
    int N = mat[0].length;
    int[][] dp = new int[M][N];

    for (int i = 0; i < M; i++) {
        if (mat[i][0] == 1) {
            break;
        }
        dp[i][0] = 1;
    }
    for (int j = 0; j < N; j++) {
        if (mat[0][j] == 1) {
            break;
        }
        dp[0][j] = 1;
    }

    for (int i = 1; i < M; i++) {
        for (int j = 1; j < N; j++) {
            if (mat[i][j] == 0) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[M - 1][N - 1];
}
```

### [97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910133514.png" alt="image-20210910133446288" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910133509.png" alt="image-20210910133459014" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/5b5dc439d4ec4bdb35a68607a86558ff8b820e70726eeaf4178dc44a49ea9a33-image.png" alt="image.png" style="zoom: 33%;" />

思路：类似于 [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)，不过不是计数。

**1. 状态**：遍历两个字符串所用的指针

* 集合： `s1(0~i)` 和 `s2(0~j) ` 交错的集合
* 属性：存在一个答案等于 `s3(0~i+j)`

**2. dp数组**：`dp[i][j]` 代表 `s1(0~i)` 和 `s2(0~j) `是否交错

**3. 状态计算**：只要左边是True，并且 `s2[j] == s3[i + j]`；或者上边是True，并且 `s1[i] == s3[i + j]`。则 `dp[i][j] = true`

**4. base case**：`dp[0][0] = true`，所有与 `s3` 相符合的位置也为 `true`

**5. 循环方式**：先枚举一个字符串，再枚举另一个字符串

```java
public boolean isInterleave(String ss1, String ss2, String ss3) {
    if (ss1.length() + ss2.length() != ss3.length()) {
        return false;
    }

    int M = ss1.length();
    int N = ss2.length();
    ss1 = " " + ss1;
    ss2 = " " + ss2;
    ss3 = " " + ss3;
    char[] s1 = ss1.toCharArray();
    char[] s2 = ss2.toCharArray();
    char[] s3 = ss3.toCharArray();

    boolean[][] dp = new boolean[M + 1][N + 1];
    dp[0][0] = true;
    for (int i = 1; i <= M && s1[i] == s3[i]; i++) {
        dp[i][0] = true;
    }
    for (int j = 1; j <= N && s2[j] == s3[j]; j++) {
        dp[0][j] = true;
    }

    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= N; j++) {
            dp[i][j] |= dp[i - 1][j] && s3[i + j] == s1[i];
            dp[i][j] |= dp[i][j - 1] && s3[i + j] == s2[j];
        }
    }
    return dp[M][N];
}
```

### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210904231718.png" alt="image-20210904231718781" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/1609983287-iavrdl-file_1609983287697" alt="96.不同的二叉搜索树" style="zoom: 50%;" />

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

<img src="https://pic.leetcode-cn.com/1609983287-RMNuWf-file_1609983287769" alt="96.不同的二叉搜索树1" style="zoom: 50%;" />

n为3的时候，有5种情况。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

* 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 

* 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 

* 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以 **`dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]`**

如图所示：

<img src="https://pic.leetcode-cn.com/1609983287-kSoRZQ-file_1609983287784" alt="96.不同的二叉搜索树2" style="zoom: 50%;" />

**1. 状态**：二叉搜索树的节点数

**2. DP数组**：有 `i` 个节点的二叉搜索树，不同的个数为 `dp[i]`

**3. 选择**：以 `1` 到 `i` ，每个节点分别作为根节点

**4. 递推公式**：$dp(i)=\sum_{1 \leq k \leq i} \left \{ dp(i-k) \times dp(k-1) \right \}$

**5. base case**：`dp[0] = 1`，`dp[1] = 1`

```java
public int numTrees(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= N; i++) {
        for (int k = 1; k <= i; k++) {
            dp[i] += dp[i - k] * dp[k - 1];
        }
    }
    return dp[N];
}
```

* 时间：$O(N^{2})$
* 空间：$O(N)$

# 状态机DP

### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906213607.png" alt="image-20210906213607362" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906213618.png" alt="image-20210906213618559" style="zoom:80%;" />

**1. 状态**：第 `i` 次操作，第 `j` 种选择

* 集合：第 `i` 次操作，第 `j` 种选择所获得的利润的集合
* 属性：最大值

**2. dp数组**：第 `i` 次操作的第 `j` 种选择所获得的最大利润是 `dp[i][j]`

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906234747.png" alt="image-20210906234747772" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906215153.png" alt="image-20210906215153116" style="zoom: 80%;" />

```java
public int maxProfit(int[] prices) {
    int N = prices.length;
    int[][] dp = new int[N][5];

    dp[0][1] = -prices[0];
    dp[0][3] = -prices[0];

    for (int i = 1; i < N; i++) {
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    }
    return dp[N - 1][4];
}
```

### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906221745.png" alt="image-20210906221745036" style="zoom:80%;" />

**1. 状态**：第 `i` 次操作，第 `j` 种选择

* 集合：第 `i` 次操作，第 `j` 种选择所获得的利润的集合
* 属性：最大值

**2. dp数组**：第 `i` 次操作的第 `j` 种选择所获得的最大利润是 `dp[i][j]`

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906221659.png" alt="image-20210906221659315" style="zoom:80%;" />

```java
public int maxProfit(int K, int[] prices) {
    if (prices.length == 0) {
        return 0;
    }

    int N = prices.length;
    int[][] dp = new int[N][2 * K + 1];

    for (int j = 1; j < 2 * K + 1; j += 2) {
        dp[0][j] = -prices[0];
    }

    for (int i = 1; i < N; i++) {
        for (int j = 1; j < 2 * K + 1; j++) {
            if ((j & 1) == 1) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]);
            }
        }
    }
    return dp[N - 1][2 * K];
}
```

### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906221901.png" alt="image-20210906221901262" style="zoom:80%;" />

**1. 状态**：第 `i` 次操作， `j` 种状态

* 集合：第 `i` 次操作， `j` 种状态所获得的利润的集合
* 属性：最大值

**2. dp数组**：第 `i` 次操作的第 `j` 种状态所获得的最大利润是 `dp[i][j]`，`j` 代表：

* `0` 表示：不持股，今天没有卖出股票
* `1` 表示：持股
* `2` 表示：不持股，今天卖出股票

**3. 状态计算**：每种状态有不同的转移方式

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906230816.png" alt="image-20210906230816753" style="zoom: 50%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906231303.png" alt="image-20210906231303593" style="zoom:80%;" />

```java
public int maxProfit(int[] prices) {
    int N = prices.length;
    int[][] dp = new int[N][3];

    dp[0][1] = -prices[0];

    for (int i = 1; i < N; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        dp[i][2] = dp[i - 1][1] + prices[i];
    }
    return Math.max(dp[N - 1][0], dp[N - 1][2]);
}
```

### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906232245.png" alt="image-20210906232245396" style="zoom:80%;" />

**1. 状态**：两种状态 0 和 1

* 集合：第 `i` 次操作， `j` 种状态所获得的利润的集合
* 属性：最大值

**2. dp数组**：第 `i` 次操作的第 `j` 种状态所获得的最大利润是 `dp[i][j]`，`j` 代表：

* `0` 表示：不持股
* `1` 表示：持股

**3. 状态计算**：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210906234014.png" alt="image-20210906234013987" style="zoom:80%;" />

```java
public int maxProfit(int[] prices, int fee) {
    int N = prices.length;
    int[][] dp = new int[N][2];

    dp[0][1] = -prices[0] - fee;

    for (int i = 1; i < N; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
    }
    return dp[N - 1][0];
}
```

# 树型DP

### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210910054433.png" alt="image-20210910054433159" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210731095844.png" alt="image-20210731095844251" style="zoom:67%;" />

思路：树型dp，后序遍历。

**递归函数的参数和返回值**：输入根节点，返回 `[不偷，偷]`

**DP数组**：`dp` 是长度为 2 的数组，`dp[0]` 代表不偷当前节点所得到的最大金钱，`dp[1]` 代表偷当前节点所得到的最大金钱。

```java
public int rob(TreeNode root) {
    int[] res = dfs(root);
    return Math.max(res[0], res[1]);
}

public int[] dfs(TreeNode root) {
    if (root == null) {
        return new int[] {0,0};
    }

    int[] left = dfs(root.left);
    int[] right = dfs(root.right);

    int dp0 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    int dp1 = root.val + left[0] + right[0];
    return new int[] {dp0, dp1};
}
```

### [834. 树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)





# 状压DP

### [935. 骑士拨号器](https://leetcode-cn.com/problems/knight-dialer/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210911150643888.png" alt="image-20210911150643888" style="zoom:80%;" />

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210911150652553.png" alt="image-20210911150652553" style="zoom:80%;" />

**2. dp数组**：`dp[i][j]` 表示跳了 `i` 次，位于 `j` 的方案数

**3. 状态计算**：

**4. base case**：`dp[0][i] = 1;`

**5. 循环方式**：枚举跳跃次数，枚举按键数，枚举来的点

`src.get(i)` 存放的是能够到 `i` 的点

```java
public int knightDialer(int n) {
    List<int[]> src = new ArrayList<>();
    src.add(new int[] {4, 6});
    src.add(new int[] {6, 8});
    src.add(new int[] {7, 9});
    src.add(new int[] {4, 8});
    src.add(new int[] {3, 9, 0});
    src.add(new int[] {});
    src.add(new int[] {1, 7, 0});
    src.add(new int[] {2, 6});
    src.add(new int[] {1, 3});
    src.add(new int[] {2, 4});

    int MOD = (int) (1e9 + 7);
    long[][] dp = new long[n][10];
    for (int i = 0; i < 10; i++) dp[0][i] = 1L;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < 10; j++) {
            for (int k : src.get(j)) {
                dp[i][j] += dp[i - 1][k];
                dp[i][j] %= MOD;
            }
        }
    }

    long res = 0;
    for (int j = 0; j < 10; j++) {
        res += dp[n - 1][j];
        res %= MOD;
    }
    return (int) res;
}
```

### [1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210911223355.png" alt="image-20210911223355344" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210911223435.png" alt="image-20210911223435216" style="zoom:80%;" />

思路：

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210911223720.png" alt="image-20210911223720527" style="zoom:80%;" />

```java
public int minimumTimeRequired(int[] jobs, int k) {
    int n = jobs.length;
    int[] sum = new int[1 << n];
    for (int i = 1; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if ((i & (1 << j)) == (1 << j)) {
                sum[i] = sum[i - (1 << j)] + jobs[j];
                break;
            }
        }
    }

    int[][] dp = new int[k][1 << n];
    for (int i = 0; i < (1 << n); i++) {
        dp[0][i] = sum[i];
    }

    for (int i = 1; i < k; i++) {
        for (int j = 0; j < (1 << n); j++) {
            int min = Integer.MAX_VALUE;
            for (int s = j; s > 0; s = (s - 1) & j) {
                int val = Math.max(dp[i - 1][j - s], sum[s]);
                min = Math.min(min, val);
            }
            dp[i][j] = min;
        }
    }
    return dp[k - 1][(1 << n) - 1];
}
```

### [1986. 完成任务的最少工作时间段](https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)





# 下面都没做

# 数位DP

### [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)





### [600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)

cv了



### [902. 最大为 N 的数字组合](https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/)





### [1015. 可被 K 整除的最小整数](https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/)





# 博弈型DP

### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

