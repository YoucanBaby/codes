[toc]

# DFS回溯

* **组合**：N个数里面按⼀定规则找出k个数的集合。组合无序，即（1，2）和（2，1）是一个集合。
* **切割**：⼀个字符串按⼀定规则有几种切割方式 
* **子集**：⼀个N个数的集合⾥有多少符合条件的子集
* **排列**：N个数按⼀定规则全排列，有几种排列方式。排列有序，即（1，2）和（2，1）不是一个集合。。
* **棋盘问题**：N皇后，解数独

## 组合

### [77. 组合](https://leetcode-cn.com/problems/combinations/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901025509.png" alt="image-20210901025509003" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901025621.png" alt="image-20210901025621165" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901030925.png" alt="image-20210901030925491" style="zoom:80%;" />

思路：DFS回溯。

时间：$O(C_{k}^{n} * k)$，空间：$O(k)$

<img src="https://pic.leetcode-cn.com/1603889327-igUOld-77.%E7%BB%84%E5%90%88.png" alt="77.组合.png" style="zoom:67%;" />

**回溯 + 剪枝**：

<img src="https://pic.leetcode-cn.com/1603889421-MRglLM-77.%E7%BB%84%E5%90%884.png" alt="77.组合4.png" style="zoom: 50%;" />

**1. 确定递归函数的参数**：n、k、**起始下标start**

**2. 确定终止条件**：路径上的个数为 k。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        dfs(n, k, 1);
        return res;
    }

    private void dfs(int n, int k, int start) {
        // 剪枝：path长度加上区间长度[start, n] 的长度小于k，就不可能构造出长度为k的path
        if (path.size() + (n - start + 1) < k) {
            return;
        }
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i <= n; i++) {
            path.add(i);
            dfs(n, k, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901114931.png" alt="image-20210901114931518" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901115004.png" alt="image-20210901115004131" style="zoom:80%;" />

思路：DFS回溯 + 哈希表。哈希表保存 <数字的字符，对应的字符串>

**确定单层递归的逻辑**：根据路径长度从哈希表中取出字符串，遍历字符串做DFS

时间：$O(3^{m}*4^{n})$，m是3个字母的数字个数，n是4个字母的数字个数

时间：$O(m+n)$

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210716202112.png" alt="image-20210716202111923" style="zoom:67%;" />

```java
class Solution {
    Map<Character, String> map = new HashMap<>();
    List<String> res = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public List<String> letterCombinations(String s) {
        if (s.equals("")) {
            return new ArrayList<>();
        }

        map.put('2', "abc");
        map.put('3', "def");
        map.put('4', "ghi");
        map.put('5', "jkl");
        map.put('6', "mno");
        map.put('7', "pqrs");
        map.put('8', "tuv");
        map.put('9', "wxyz");

        dfs(s);
        return res;
    }

    private void dfs(String s) {
        if (path.length() == s.length()) {
            res.add(path.toString());
            return;
        }

        char key = s.charAt(path.length());
        String value = map.get(key);
        for (char c : value.toCharArray()) {
            path.append(c);
            dfs(s);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901115449.png" alt="image-20210901115449727" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901115533.png" alt="image-20210901115533305" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901115545.png" alt="image-20210901115545878" style="zoom:80%;" />

思路：先排序，再DFS回溯。

**剪枝**：如果 `sum + 当前节点的值` 大于 `目标值`，就退出递归。

* 时间：$O(N*2^{N})$，有剪枝，实际情况是小于这个值的
* 空间：$O(target)$，最差的情况是向下递归 `target` 层

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210717002929.png" alt="image-20210717002929209" style="zoom: 67%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] nums, int target) {
        Arrays.sort(nums);
        dfs(nums, target, 0, 0);
        return res;
    }

    public void dfs(int[] nums, int target, int sum, int start) {
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < nums.length; i++) {
            if (sum + nums[i] > target) {			// 剪枝
                return;
            }

            path.add(nums[i]);
            dfs(nums, target, sum + nums[i], i);
            path.remove(path.size() - 1);
        }
    }
}
```

### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901122759.png" alt="image-20210901122759251" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901122816.png" alt="image-20210901122816198" style="zoom:80%;" />

思路：先排序，再DFS回溯。

**去重**（chong）：本层使用过的元素不能再次重复使用。

* 时间：$O(N*2^{N})$，有剪枝，实际情况是小于这个值的

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210716233925.png" alt="image-20210716233925227" style="zoom: 67%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] nums, int target) {
        Arrays.sort(nums);
        dfs(nums, target, 0, 0);
        return res;
    }

    public void dfs(int[] nums, int target, int sum, int start) {
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < nums.length; i++) {
            if (sum + nums[i] > target) {     // 剪枝
                break;
            }
            if (i - 1 >= start && nums[i] == nums[i - 1]) {  // 去重
                continue;
            }

            path.add(nums[i]);
            dfs(nums, target, sum + nums[i], i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901124449.png" alt="image-20210901124449335" style="zoom:80%;" />

思路：DFS回溯。

剪枝：总和大于n，退出递归。

* 时间：$O(C_{9}^{k}*k)$，有剪枝，实际情况是小于这个值的

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210716194938.png" alt="image-20210716194937987" style="zoom: 80%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum3(int k, int n) {
        dfs(k, n, 0, 1);
        return res;
    }

    private void dfs(int k, int n, int sum, int start) {
        if (sum > n) {		// 剪枝
            return;
        }
        if (sum == n && path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i <= 9; i++) {
            path.add(i);
            dfs(k, n, sum + i, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 分割

### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210901144850368.png" alt="image-20210901144850368" style="zoom:80%;" />

思路：DFS回溯。双指针判断字符串是不是回文串。

**2. 终止条件**：起始位置和字符串长度一样，说明分割得到的字符串都是回文串。

**3. 单层递归的逻辑**：只有当前字符串是回文串才进行操作。

* 时间：$O(N*2^{N})$

<img src="https://pic.leetcode-cn.com/298a80282ac3505fec3710abdc1e656c591cf7acaa3ba976151480729244b649-image.png" alt="image.png" style="zoom: 33%;" />

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        dfs(s, 0);
        return res;
    }

    public void dfs(String s, int start) {
        if (start == s.length()) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < s.length(); i++) {
            String str = s.substring(start, i + 1);
            if (isPalindrome(str)) {
                path.add(str);
                dfs(s, i + 1);
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901150449.png" alt="image-20210901150449183" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901150514.png" alt="image-20210901150514416" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901150528.png" alt="image-20210901150528908" style="zoom:80%;" />

不会。

思路：DFS回溯 + 剪枝。

**2. 终止条件**：如果起始位置遍历到最后一位了，添加的逗号数量等于4，就返回，返回的时候去掉第一个逗号

**3. 单层递归的逻辑**：跳过前导0。如果子串的值在`0~255`范围之内，就操作。

* 剪枝1：当path里超过四个逗号，就返回

* 剪枝2：`i < start + 3`

时间：$O(3^{4}*N)$，N 是 s 的长度

<img src="https://pic.leetcode-cn.com/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-%E3%80%8C%E5%8A%9B%E6%89%A3%E3%80%8D%E7%AC%AC%2093%20%E9%A2%98%EF%BC%9A%E5%A4%8D%E5%8E%9F%20IP%20%E5%9C%B0%E5%9D%80-1.png" alt="「力扣」第 93 题：复原 IP 地址-1.png" style="zoom: 50%;" />

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public List<String> restoreIpAddresses(String s) {
        if (s.length() < 4 || s.length() > 12) {
            return res;
        }

        dfs(s, 0, 0);
        return res;
    }

    public void dfs(String s, int start, int pointNum) {
        if (pointNum > 4) {
            return;             // 剪枝
        }
        if (start == s.length() && pointNum == 4) {
            res.add(path.toString().substring(1, path.length()));       // 去掉第一个'.'
        }

        for (int i = start; i < start + 3 && i < s.length(); i++) {
            String str = s.substring(start, i + 1);
            if (str.charAt(0) == '0' && str.length() > 1) {     // 跳过前导0
                continue;
            }
            if (Integer.valueOf(str) >= 0 && Integer.valueOf(str) <= 255) {
                path.append('.').append(str);
                dfs(s, i + 1, pointNum + 1);
                path.delete(path.lastIndexOf("."), path.length());
            }
        }
    }
}
```

### [306. 累加数](https://leetcode-cn.com/problems/additive-number/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902031048.png" alt="image-20210902031048120" style="zoom:80%;" />

思路：和 [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/) 思路一样。

如果起始位置到最后一位，那就是累加数。如果没有结果，或者结果只有一位，就DFS。当前值等于前两项的值，也DFS。

```java
class Solution {
    public boolean isAdditiveNumber(String s) {
        List<Long> res = new ArrayList<>();
        return dfs(res, s, 0);
    }

    private boolean dfs(List<Long> res, String s, int start) {
        if (start == s.length()){
            return res.size() >= 3;
        }

        for (int i = start; i < s.length(); i++) {
            if (i > start && s.charAt(start) == '0') {
                return false;
            }

            if (i + 1 - start >= 12) {			// 剪枝，卡样例过的
                return false;
            }
            long num = Long.valueOf(s.substring(start, i + 1));
            if (num > Long.MAX_VALUE) {
                return false;
            }
            if (res.size() >= 2 && num != res.get(res.size() - 1) + res.get(res.size() - 2)) {
                continue;
            }

            if (res.size() <= 1 || num == res.get(res.size() - 1) + res.get(res.size() - 2)) {
                res.add(num);
                if (dfs(res, s, i + 1)) {
                    return true;
                }
                res.remove(res.size() - 1);
            }
        }
        return false;
    }
}
```

### [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902024432.png" alt="image-20210902024432393" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902024414.png" alt="image-20210902024413984" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902024812.png" alt="image-20210902024812481" style="zoom:80%;" />

不会。

思路：如果起始位置到最后一位，并且有至少三个数字，就返回结果。如果没有结果，或者结果只有一位，就DFS。当前值等于前两项的值，也DFS。

剪枝：两位以上的数字不能以0开头，截取的数字不能大于 `Integer.MAX_VALUE`，截取的数字不能大于前两个数字和。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902024636.png" alt="image-20210902024636122" style="zoom: 67%;" />

```java
class Solution {
    public List<Integer> splitIntoFibonacci(String s) {
        List<Integer> res = new ArrayList<>();
        dfs(res, s, 0);
        return res;
    }

    private boolean dfs(List<Integer> res, String s, int start) {
        if (res.size() >= 3 && start == s.length()) {
            return true;
        }

        for (int i = start; i < s.length(); i++) {
            if (i > start && s.charAt(start) == '0') {
                return false;
            }

            long num = Long.valueOf(s.substring(start, i + 1));
            if (num > Integer.MAX_VALUE) {
                return false;
            }
            if (res.size() >= 2 && num > res.get(res.size() - 1) + res.get(res.size() - 2)) {
                return false;
            }

            if (res.size() <= 1 || num == res.get(res.size() - 1) + res.get(res.size() - 2)) {
                res.add((int) num);
                if (dfs(res, s, i + 1)) {
                    return true;
                }
                res.remove(res.size() - 1);
            }
        }
        return false;
    }
}
```

## 子集

### [78. 子集](https://leetcode-cn.com/problems/subsets/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901152943.png" alt="image-20210901152943435" style="zoom: 80%;" />

时间：$O(N*2^{N})$ ，空间：$O(N)$ 

思路：DFS 回溯。

**终止条件**：起始下标 `start `大于 数组长度，返回。也可以省去终止条件，因为 `start `大于 数组长度的时候，for循环就终止了。

**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。** **注意：起始下标从0开始！**

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210718120908.png" alt="image-20210718120908775" style="zoom: 67%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, 0);
        return res;
    }

    public void dfs(int[] nums, int start) {
        res.add(new ArrayList<>(path));
        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901153440.png" alt="image-20210901153440368" style="zoom:80%;" />

时间：$O(N*2^{N})$ 

思路：先排序，再DFS回溯。

**单层递归的逻辑**：如果当前节点和上一个节点相同，就跳过这个节点。

<img src="https://pic.leetcode-cn.com/1604912138-sosMZx-90.%E5%AD%90%E9%9B%86II.png" alt="90.子集II.png" style="zoom: 67%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);		// 一定要排序
        dfs(nums, 0);
        return res;
    }

    public void dfs(int[] nums, int start) {
        res.add(new ArrayList<>(path));
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### [491. 递增子集](https://leetcode-cn.com/problems/increasing-subsequences/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901232438.png" alt="image-20210901232438454" style="zoom:80%;" />

时间：$O(N*2^{N})$ 

思路：DFS回溯，路径上有两个以上的值，就添加到结果中。用哈希表统计本层已经使用过的值。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902002045.png" alt="image-20210902002045269" style="zoom:50%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(nums, 0);
        return res;
    }

    public void dfs(int[] nums, int start) {
        if (path.size() >= 2) {
            res.add(new ArrayList<>(path));
        }

        Set<Integer> set = new HashSet<>();
        for (int i = start; i < nums.length; i++) {
            if (!path.isEmpty() && path.get(path.size() - 1) > nums[i]) {
                continue;
            }
            if (set.contains(nums[i])) {
                continue;
            }
            set.add(nums[i]);
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### [698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902011520.png" alt="image-20210902011520504" style="zoom:80%;" />

题意：数组划分为k份，每份大小为 sum / k

思路：nums的总和需要分成k份，其中一个数不能超过 sum / k。每次子集和等于 sum/k，待处理的子集个数减一，直到这个值为0，那就是找到了。

剪枝：不遍历以前没有遍历过的值，如果遍历到头了，还没找到，就说明不存在这个子集。

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = 0;
        int max = 0;
        for (int num : nums) {
            sum += num;
            max = Math.max(max, num);
        }
        if (sum % k != 0 || max > sum / k) {
            return false;
        }

        boolean[] used = new boolean[nums.length];
        return dfs(nums, used, k, sum / k, 0, 0);
    }

    private boolean dfs(int[] nums, boolean[] used, int k, int target, int curSum, int start) {
        if (k == 0) {
            return true;
        }
        if (curSum == target) {
            return dfs(nums, used, k - 1, target, 0, 0);
        }

        for (int i = start; i < nums.length; i++) {
            if (!used[i] && curSum + nums[i] <= target) {
                used[i] = true;
                if (dfs(nums, used, k, target, curSum + nums[i], i + 1)) {
                    return true;
                }
                used[i] = false;
            }
        }
        return false;
    }
}
```

## 排列

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901154545.png" alt="image-20210901154545546" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901154557.png" alt="image-20210901154557079" style="zoom:80%;" />

时间：$O(N*N!)$

思路：DFS回溯。需要判断是否访问过当前节点。

**单层递归的逻辑**：遍历数组中的元素，如果当前元素已经被使用过了，就跳过。

<img src="https://pic.leetcode-cn.com/1607507044-sRHGmt-file_1607507044176" alt="46.全排列" style="zoom:80%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        int N = nums.length;
        boolean[] used = new boolean[N];

        dfs(nums, used);
        return res;
    }

    public void dfs(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            dfs(nums, used);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901160734.png" alt="image-20210901160734801" style="zoom:80%;" />

时间：$O(N*N!)$

思路：本题会出现重复的元素，所有要对排列排序，再DFS回溯。遇到重复的数字要跳过。也需要判断是否访问过当前节点。

<img src="https://pic.leetcode-cn.com/1605408511-mPmGWf-47.%E5%85%A8%E6%8E%92%E5%88%97II1.png" alt="47.全排列II1.png" style="zoom:80%;" />

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;

    public List<List<Integer>> permuteUnique(int[] nums) {
        int N = nums.length;
        used = new boolean[N];
        Arrays.sort(nums);

        dfs(nums);
        return res;
    }

    public void dfs(int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (i - 1 >= 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
                continue;
            }
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;
                dfs(nums);
                used[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }
}
```

### [60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902041652.png" alt="image-20210902041652322" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902041706.png" alt="image-20210902041705996" style="zoom:80%;" />

思路1：全排列。找第k个排列。

时间：$O(N*N!)$

```java
class Solution {
    int count = 0;
    StringBuilder path = new StringBuilder();

    public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        boolean[] used = new boolean[n];

        return dfs(nums, used, k);
    }

    public String dfs(int[] nums, boolean[] used, int k) {
        if (path.length() == nums.length) {
            count++;
            if (count == k) {
                return path.toString();
            }
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            path.append(nums[i]);
            used[i] = true;
            if (!dfs(nums, used, k).equals("")) {
                return path.toString();
            }
            used[i] = false;
            path.deleteCharAt(path.length() - 1);
        }
        return "";
    }
}
```

思路2：DFS + 剪枝。没有回溯。提前计算好阶乘数组，如果要找的节点不在当前节点下面，就直接减去这颗树的大小。最后来到我们想要的叶子节点处。

时间：$O(N^{2})$

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902041940.png" alt="image-20210902041939901" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902042003.png" alt="image-20210902042002893" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902042054.png" alt="image-20210902042054842" style="zoom:80%;" />

```java
class Solution {
    int n;
    int k;
    boolean[] used;
    int[] factorial;
    StringBuilder path = new StringBuilder();

    public String getPermutation(int n, int k) {
        this.n = n;
        this.k = k;
        used = new boolean[n + 1];
        factorial = getFactorial(n);           // 阶乘

        dfs(0);
        return path.toString();
    }

    private void dfs(int depth) {
        if (depth == n) {
            return;
        }

        int count = factorial[n - 1 - depth];
        for (int i = 1; i <= n; i++) {
            if (used[i]) {
                continue;
            }
            if (k > count) {
                k -= count;
                continue;
            }

            path.append(i);
            used[i] = true;
            dfs(depth + 1);
            return;
        }
    }

    private int[] getFactorial(int n) {
        int[] factorial = new int[n + 1];
        factorial[0] = 1;
        for (int i = 1; i <= n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }
        return factorial;
    }
}
```

### [526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210816064825.png" alt="image-20210816064825698" style="zoom:80%;" />

时间：$O(N!)$

思路：DFS回溯。i到N+1位置，就添加结果。遇到使用过的数字跳过。

```java
class Solution {
    int res = 0;

    public int countArrangement(int N) {
        boolean[] used = new boolean[N + 1];
        dfs(1, N, used);
        return res;
    }

    private void dfs(int index, int N, boolean[] used) {
        if (index == N + 1) {
            res++;
            return;
        }

        for (int num = 1; num <= N; num++) {      // 第i位上的数字
            if (used[num]) {
                continue;
            }
            if (num % index == 0 || index % num == 0) {
                used[num] = true;
                dfs(index + 1, N, used);
                used[num] = false;
            }
        }
    }
}
```

### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902013831.png" alt="image-20210902013831732" style="zoom:80%;" />

不会。

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902014851.png" alt="image-20210902014851651" style="zoom: 67%;" />

思路：在DFS中修改字符串s对应的数组arr。遇到数字，不改变。遇到字母，改变为大小写。

大写字符与其对应的小写字符的 ASCII 的差为 32，32 这个值如果敏感的话，它是 $2^{5}$​ ，在编程语言中，可以表示为 `1 << 5`。而

变换大小写这件事等价于：

- 如果字符是小写字符，减去 32 得到大写字符；
- 如果字符是大写字符，加上 32 得到小写字符。

而这两者合并起来，就是给这个字符做一次不进位的加法，即异或上 `1 << 5`。

```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> res = new ArrayList<>();
        char[] arr = s.toCharArray();
        dfs(res, arr, 0);
        return res;
    }

    private void dfs(List<String> res, char[] arr, int index) {
        if (index == arr.length) {
            res.add(new String(arr));
            return;
        }

        dfs(res, arr, index + 1);
        if (Character.isLetter(arr[index])) {
            arr[index] ^= (1 << 5);
            dfs(res, arr, index + 1);
        }
    }
}
```

## 棋盘问题

### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901164739.png" alt="image-20210901164739342" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901164807.png" alt="image-20210901164807576" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901164817.png" alt="image-20210901164817060" style="zoom: 80%;" />

不会 * 2

思路：DFS回溯。这次的递归需要使用两层循环。

**`dfs`**：遍历行和列, 每次递归都从(0,0)开始遍历。如果当前位置有值了，就跳过。尝试 ‘1’ ~ ‘9’ 是否合法：如果合法的话，就操作。如果试遍了1~9，都没有找到，说明这个解是错误的

判断当前位置是否合法：判断这一行/这一列/九方格里是否重复

<img src="https://pic.leetcode-cn.com/1605694427-OXRnMr-file_1605694427277" alt="37.解数独" style="zoom:80%;" />

```java
class Solution {
    public void solveSudoku(char[][] mat) {
        dfs(mat);
    }

    public boolean dfs(char[][] mat) {
        for (int x = 0; x < mat.length; x++) {
            for (int y = 0; y < mat[0].length; y++) {
                if (mat[x][y] != '.') {
                    continue;
                }
                for (char k = '1'; k <= '9'; k++) {
                    if (isValid(mat, x, y, k)) {
                        mat[x][y] = k;
                        if (dfs(mat)) {
                            return true;
                        }
                        mat[x][y] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }

    private boolean isValid(char[][] mat, int x, int y, char k) {
        for (int j = 0; j < mat[0].length; j++) {   // 判断这一行是否重复
            if (mat[x][j] == k) {
                return false;
            }
        }
        for (int i = 0; i < mat.length; i++) {      // 判断这一列是否重复
            if (mat[i][y] == k) {
                return false;
            }
        }
        // 判断九方格里是否重复
        int startX = (x / 3) * 3;
        int startY = (y / 3) * 3;
        for (int i = startX; i < startX + 3; i++) {
            for (int j = startY; j < startY + 3; j++) {
                if (mat[i][j] == k) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901170043.png" alt="image-20210901170043380" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901170050.png" alt="image-20210901170050710" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901170209.png" alt="image-20210901170208979" style="zoom:80%;" />

不会

时间：$O(N!)$，N是皇后数量

思路：DFS回溯。遍历棋盘的列，如果当前位置可以放皇后，就操作。

**终止条件**：如果已经递归完最后一行了，就把棋盘转成List，添加到结果中

当前位置是否可以放皇后：判断当前位置 **`上方/左上角/右上角`** 有没有皇后

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] mat = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                mat[i][j] = '.';            // 初始化棋盘
            }
        }

        dfs(mat, 0);
        return res;
    }

    // x，当前位置在棋盘的第几行
    public void dfs(char[][] mat, int x) {
        if (x == mat.length) {
            res.add(matToList(mat));
            return;
        }

        for (int y = 0; y < mat.length; y++) {
            if (isValid(mat, x, y)) {
                mat[x][y] = 'Q';
                dfs(mat, x + 1);
                mat[x][y] = '.';
            }
        }
    }

    public boolean isValid(char[][] mat, int x, int y) {
        // 判断当前位置上方有没有皇后
        for (int i = x - 1; i >= 0; i--) {
            if (mat[i][y] == 'Q') {
                return false;
            }
        }
        // 判断右上角有没有皇后
        for (int i = x - 1, j = y + 1; i >= 0 && j < mat.length; i--, j++) {
            if (mat[i][j] == 'Q') {
                return false;
            }
        }
        // 判断左上角有没有皇后
        for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
            if (mat[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }

    public List<String> matToList(char[][] mat) {
        List<String> path = new ArrayList<>();
        for (int i = 0; i < mat.length; i++) {
            path.add(new String(mat[i]));
        }
        return path;
    }
}
```

### [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

思路：比 [51. N 皇后](https://leetcode-cn.com/problems/n-queens/) 简单。DFS回溯，统计个数即可。

```java
class Solution {
    int res = 0;

    public int totalNQueens(int n) {
        char[][] mat = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                mat[i][j] = '.';
            }
        }

        dfs(mat, 0);
        return res;
    }

    public void dfs(char[][] mat, int x) {
        if (x == mat.length) {
            res++;
            return;
        }

        for (int y = 0; y < mat.length; y++) {
            if (isValid(mat, x, y)) {
                mat[x][y] = 'Q';
                dfs(mat, x + 1);
                mat[x][y] = '.';
            }
        }
    }

    public boolean isValid(char[][] mat, int x, int y) {
        // 判断当前位置上方有没有皇后
        for (int i = x - 1; i >= 0; i--) {
            if (mat[i][y] == 'Q') {
                return false;
            }
        }
        // 判断右上角有没有皇后
        for (int i = x - 1, j = y + 1; i >= 0 && j < mat.length; i--, j++) {
            if (mat[i][j] == 'Q') {
                return false;
            }
        }
        // 判断左上角有没有皇后
        for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
            if (mat[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

## 小岛问题

### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901172856.png" alt="image-20210901172856048" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901172904.png" alt="image-20210901172904119" style="zoom:80%;" />

思路：**小岛问题 + 回溯**。遍历所有的点，进行DFS，找到了就返回true。字符串下标越过字符串长度，找到了。数组越界，没找到。访问过的节点都置为 `#` 。等DFS完再还原。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };

    public boolean exist(char[][] mat, String word) {
        int M = mat.length;
        int N = mat[0].length;

        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (dfs(mat, word, x, y, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(char[][] board, String word, int x, int y, int index) {
        if (index == word.length()) {			// 这句话一定放开头！
            return true;
        }
        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) {
            return false;
        }
        
        if (board[x][y] == word.charAt(index)) {
            board[x][y] = '#';
            for (int[] dir : dirs) {
                if (dfs(board, word, x + dir[0], y + dir[1], index + 1)) {
                    return true;
                }
            }
            board[x][y] = word.charAt(index);
        }
        return false;
    }
}
```

### [351. 安卓系统手势解锁](https://leetcode-cn.com/problems/android-unlock-patterns/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901174552.png" alt="image-20210901174552086" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901174601.png" alt="image-20210901174601131" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901174653.png" alt="image-20210901174653602" style="zoom:80%;" />

vivo原题。

思路1：打表。

```java
public int numberOfPatterns(int m, int n) {
    int[] nums = new int[10];
    nums[1] = 9;
    nums[2] = 56;
    nums[3] = 320;
    nums[4] = 1624;
    nums[5] = 7152;
    nums[6] = 26016;
    nums[7] = 72912;
    nums[8] = 140704;
    nums[9] = 140704;
    int res = 0;
    for(int i = m;i<=n;i++){
        res += nums[i];
    }
    return res;
}
```

<img src="https://pic.leetcode-cn.com/20490c6749055681fdf0b105023e82584db7189bae7bd05c1e3e26a65667ad86-%E6%89%B9%E6%B3%A8%202020-06-19%20001502.png" alt="批注 2020-06-19 001502.png" style="zoom:80%;" />

思路2：先记录跳跃的点数，再DFS回溯。注意1,3,7,9对称，2,4,6,8对称，5独立。

DFS：遍历所有节点，如果下一个节点没有访问过，两个节点中间没有需要跳过的节点，或者需要跳过的节点已经访问过了，那就DFS。

```java
class Solution {
    public int numberOfPatterns(int m, int n) {
        int[][] skip = new int[10][10];     // skip数组记录跳跃的点数，比如说从1到3，就跳跃2
        skip[1][3] = skip[3][1] = 2;
        skip[1][7] = skip[7][1] = 4;
        skip[3][9] = skip[9][3] = 6;
        skip[4][6] = skip[6][4] = skip[2][8] = skip[8][2] = 5;
        skip[1][9] = skip[9][1] = skip[3][7] = skip[7][3] = 5;
        skip[7][9] = skip[9][7] = 8;

        int res = 0;
        boolean[] visited = new boolean[10];
        for(int i = m; i <= n; i++){
            res += dfs(visited, skip, 1, i - 1) * 4;   // 1,3,7,9对称
            res += dfs(visited, skip, 2, i - 1) * 4;   // 2,4,6,8对称
            res += dfs(visited, skip, 5, i - 1);       // 5独立
        }
        return res;
    }

    public int dfs(boolean[] visited, int[][] skip, int cur, int remainKeyCount){
        if(remainKeyCount == 0){
            return 1;
        }

        int res = 0;
        visited[cur] = true;
        for(int next = 1; next <= 9; next++){
            int crossThroughNumber = skip[cur][next];
            if(!visited[next] && (crossThroughNumber == 0 || visited[crossThroughNumber])){
                res += dfs(visited, skip, next, remainKeyCount - 1);
            }
        }
        visited[cur] = false;
        return res;
    }
}
```

### [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

<img src="C:\Users\xuyifang\AppData\Roaming\Typora\typora-user-images\image-20210902172136534.png" alt="image-20210902172136534" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902172157.png" alt="image-20210902172146294" style="zoom: 80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902182249.png" alt="image-20210902182249839" style="zoom: 33%;" />

思路：统计需要走的步数。从四个方向出发，走过的点置为-1，不能走已经走过的点，遇到2就返回结果。

```java
class Solution {
    int[][] dirs = {
            {-1,0}, {1,0},
            {0,-1}, {0,1}
    };
    int res = 0;

    public int uniquePathsIII(int[][] mat) {
        int startX = 0;
        int startY = 0;
        int stepNum = 1;        // 需要走的步数
        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[0].length; j++) {
                if (mat[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
                if (mat[i][j] == 0) {
                    stepNum++;
                }
            }
        }

        dfs(mat, startX, startY, stepNum);
        return res;
    }

    private void dfs(int[][] mat, int x, int y, int stepNum) {
        if (x < 0 || x >= mat.length || y < 0 || y >= mat[0].length) {
            return;
        }
        if (mat[x][y] == -1) {
            return;
        }
        if (mat[x][y] == 2) {   // 到终点了
            if (stepNum == 0) {
                res++;
            }
            return;
        }

        mat[x][y] = -1;
        for (int[] dir : dirs) {
           dfs(mat, x + dir[0], y + dir[1], stepNum - 1);
        }
        mat[x][y] = 0;
    }
}
```

## 括号

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901185350.png" alt="image-20210901185350116" style="zoom:80%;" />

<img src="https://pic.leetcode-cn.com/efbe574e5e6addcd1c9dc5c13a50c6f162a2b14a95d6aed2c394e18287a067fa-image.png" alt="image.png" style="zoom: 33%;" />

不会

思路：DFS回溯，记录左右括号用了多少个。

* 如果 左括号数量还不够：path 中添加 `(`，左括号数量 + 1，DFS，回溯

* 如果 右括号数量还不够：path 中添加 `)`，右括号数量 + 1，DFS，回溯

剪枝：左括号数量 > 右括号数量，退出DFS

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public List<String> generateParenthesis(int n) {
        dfs(0, 0, n);
        return res;
    }

    // 左括号用了几个，右括号用了几个，左右括号各自要用几个
    public void dfs(int left, int right, int n) {
        if (left < right) {		// 剪枝
            return;
        }
        if (left == n && right == n) {
            res.add(path.toString());
            return;
        }

        if (left < n) {
            path.append("(");
            dfs(left + 1, right, n);
            path.deleteCharAt(path.length() - 1);
        }
        if (right < n) {
            path.append(")");
            dfs(left, right + 1, n);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210901232209.png" alt="image-20210901232209785" style="zoom:80%;" />

不会 * 2

思路：找出不合法的左括号个数和右括号个数。DFS不断删除左括号或右括号，直到不合法的个数为0。检查删除后的括号串是否合法。

```java
class Solution {
    List<String> res = new ArrayList<>();

    public List<String> removeInvalidParentheses(String s) {
        int left = 0;
        int right = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                left++;
            } else if (c == ')') {
                if (left == 0) {
                    right++;
                } else {
                    left--;
                }
            }
        }

        dfs(s, 0, left, right);
        return res;
    }

    public void dfs(String s, int start, int left, int right) {
        if (left == 0 && right == 0) {
            if (isValid(s)) {
                res.add(s);
            }
            return;
        }

        for (int i = start; i < s.length(); i++) {
            if (i - 1 >= start && s.charAt(i) == s.charAt(i - 1)) {		// 去重
                continue;
            }
            
            if (left > 0 && s.charAt(i) == '(') {
                dfs(s.substring(0, i) + s.substring(i + 1), i, left - 1, right);
            }
            if (right > 0 && s.charAt(i) == ')') {
                dfs(s.substring(0, i) + s.substring(i + 1), i, left, right - 1);
            }
        }
    }

    private boolean isValid(String s) {
        int left = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                left++;
            } else if (c == ')') {
                if (left == 0) {
                    return false;
                } else {
                    left--;
                }
            }
        }
        return left == 0;
    }
}
```

## 其他

### [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902002919.png" alt="image-20210902002919356" style="zoom:80%;" />

思路：把所有数字加入到 list，每次取出list中的两个数字做加减乘除，DFS判断是否有效。

`dfs`：

1. 终止条件：如果 list 只剩下一位数字了，判断该数字与24的大小， `Math.abs(nums.get(0) - 24) <= 0.0000000001`
2. 两层循环，看 a 和 b ：
   1. 对比 a + b
   2. a - b
   3. a / b
   4. a * b
   5. b - a
   6. b / a

```java
class Solution {
    public boolean judgePoint24(int[] nums) {
        List<Double> list = new ArrayList<>(4);
        for (int num : nums) {
            list.add((double) num);
        }
        
        return dfs(list);
    }

    public boolean dfs(List<Double> nums) {
        if (nums.size() == 1) {
            return Math.abs(nums.get(0) - 24) <= 0.0000000001;
        }

        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                List<Double> copy = new ArrayList<>(nums);
                double b = copy.remove(j);
                double a = copy.remove(i);
                boolean valid = false;

                copy.add(a + b);
                valid |= dfs(copy);

                copy.set(copy.size() - 1, a - b);
                valid |= dfs(copy);

                copy.set(copy.size() - 1, a / b);
                valid |= dfs(copy);

                copy.set(copy.size() - 1, a * b);
                valid |= dfs(copy);

                copy.set(copy.size() - 1, b - a);
                valid |= dfs(copy);

                copy.set(copy.size() - 1, b / a);
                valid |= dfs(copy);

                if (valid) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

### [282. 给表达式添加运算符](https://leetcode-cn.com/problems/expression-add-operators/)

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902175233.png" alt="image-20210902175233260" style="zoom:80%;" />

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/20210902175305.png" alt="image-20210902175305234" style="zoom:80%;" />

思路：本题和 [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/) 很像。DFS需要记录路径的值，以及上一串数字的值。要去掉首位是0的情况。

```java
class Solution {
    public List<String> addOperators(String s, int target) {
        List<String> res = new ArrayList<>();
        String path = "";
        dfs(res, path, s, target, 0, 0, 0);
        return res;
    }

    // val是path的值，pre是上一串数字
    private void dfs(List<String> res, String path, String s, int target, int start, long val, long pre) {
        if (start == s.length() && val == target) {
            res.add(path);
            return;
        }

        for (int i = start; i < s.length(); i++) {
            if (i > start && s.charAt(start) == '0') {        // 首位是0
                return;
            }

            long num = Long.valueOf(s.substring(start, i + 1));
            if (start == 0) {
                dfs(res, path + num, s, target, i + 1, num, num);
            } else {
                dfs(res, path + "+" + num, s, target, i + 1, val + num, num);

                dfs(res, path + "-" + num, s, target, i + 1, val - num, -num);

                dfs(res, path + "*" + num, s, target, i + 1, val - pre + pre * num, pre * num);
            }
        }
    }
}
```

# 
