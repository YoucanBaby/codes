[TOC]

# HTTP

## 一 、基础概念

### 请求和响应报文

请求报文结构：

- 第一行是包含了**请求方法、URL、协议版本**；
- 接下来的多行都是**请求的首部** Header，每个首部都有一个首部名称，以及对应的值。
- 一个**空行**用来分隔首部和内容主体 Body
- 最后是**请求的内容**主体

```http
GET http://www.example.com/ HTTP/1.1
报文首部

报文主体
```

响应报文结构：

- 第一行包含**协议版本**、**状态码**以及**描述**，最常见的是 200 OK 表示请求成功了
- 接下来多行也是**响应的首部**内容
- 一个**空行**分隔首部和内容主体
- 最后是**响应的内容**主体

```http
HTTP/1.1 200 OK
报文首部

报文主体
```

### URL

URL 的一般形式：<协议>://<主机>:<端口>/<路径>

<img src="https://gitee.com/njuxyf/PictureBed/raw/master/CS-Notes/image-20210426090502606.png" alt="image-20210426090502606" style="zoom:67%;" />

## 二、HTTP 方法

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。

### GET

> 获取资源

当前网络请求中，绝大部分使用的是 GET 方法。

### HEAD

> 获取报文首部

和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。

### POST

> 传输数据

**POST** 主要用来**传输数据**，而 **GET** 主要用来**获取资源**。

### PUT

> 上传文件

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

### DELETE

> 删除文件

与 PUT 功能相反，并且同样不带验证机制。

### CONNECT

> 与代理服务器建立隧道

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

### OPTIONS

> 查询 URL 支持的方法

### TRACE

> 路径追踪，用于测试或诊断

## 三、HTTP 状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别                                 | 含义                       |
| ------ | ------------------------------------ | -------------------------- |
| 1XX    | Informational（**信息**状态码）      | 接收的请求正在处理         |
| 2XX    | Success（**成功**状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（**重定向**状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（**客户端错误**状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（**服务器错误**状态码） | 服务器处理请求出错         |

### 1XX 信息

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

### 2XX 成功

- **200 OK**

### 3XX 重定向

- **301 Moved Permanently** ：永久性重定向。
- **302 Found** ：临时性重定向。
- **304 Not Modified** （未修改）：客户端有缓冲的文件，并发出了一个条件性的请求。服务器告诉客户端，**原来缓冲的文件还可以继续使用。**

### 4XX 客户端错误

- **400 Bad Request** ：存在语法错误。
- **401 Unauthorized** ：需要有用户认证信息。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**

### 5XX 服务器错误

- **500 Internal Server Error** ：服务器执行请求时发生错误。
- **502 Bad Gateway** ：网关错误。
- **503 Service Unavailable** ：服务器超负载或停机维护，无法处理请求。
- **504 Gateway Timeout** ：网关超时。

## 四、具体应用

### 连接管理

#### 1. 持久连接

持久连接只需要**建立一次 TCP 连接**就能进行**多次 HTTP 通信**。

- **从 HTTP/1.1 开始默认是持久连接的，如果要断开连接，需要由客户端或者服务器端提出断开**，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是非持久连接的，如果需要使用持久连接，则使用 `Connection : Keep-Alive`。

#### 2. 管线化

以前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，**不用等待响应就可以直接发送下一个请求**。

### Cookie

HTTP 协议是不保存状态的协议。**HTTP/1.1** 引入 **Cookie 在本地保存用户信息**。但 Cookie 渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 **Web storage API**（本地存储和会话存储）或 IndexedDB。

#### 1. 作用

**在本地保存用户信息。**

#### 2. 使用场景

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

#### 3. 创建过程

服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到本地。

```http
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: sid=123456

[响应的内容]
```

#### 4. 分类

- **会话期 Cookie**：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- **持久性 Cookie**：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

```
Set-Cookie: id=123456; Expires=Mon, 26 Apr 2021 17:01:00 UTC;
```

#### 5. 作用域

**Domain** 标识指定了哪些**主机**可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。

**Path** 标识指定了主机下的哪些**路径**可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 "/" 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：

- /docs
- /docs/Web/
- /docs/Web/HTTP

#### 6. HttpOnly

标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用，因此使用 **HttpOnly** 标记可以在一定程度上**避免跨站脚本攻击**（XSS ）。

#### 7. Secure

标记为 **Secure** 的 Cookie 只能通过被 **HTTPS 协议加密过的请求**发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，**Secure 标记也无法完全保证数据的安全**。

#### 8. 浏览器禁用 Cookie

此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

#### 9. Session

作用：**在服务端保存用户信息。**

使用场景：判断用户是否登录，购物车功能。

可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

Session ID 的安全性问题解决：

1. 产生一个不容易被猜到的 Session ID。
2. 经常重新生成 Session ID。
3. 对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

#### 10. Cookie 与 Session 的区别

- **Cookie** 只能存储 **ASCII 码字符串**，而 **Session** 则可以**存储任何类型的数据**，因此在考虑数据复杂性时首选 Session；
- **Cookie 存储在本地，容易被恶意查看**。如果有隐私数据存在 Cookie 中，可以将 **Cookie 加密**，然后在服务器进行解密；
- 对于大型网站来说，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，所以**不建议将所有的用户信息都存储到 Session 中**。

### 缓存

#### 1. 优点

- 缓解服务器压力；
- 降低客户端获取资源的延迟

#### 2. 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存，存储在本地。

#### 3. Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

### 内容协商

通过内容协商**返回最合适的内容**，例如根据浏览器的**默认语言**选择**返回中文界面**还是**英文界面**。

### 虚拟主机

HTTP/1.1 使用虚拟主机技术，使得**一台服务器拥有多个域名**，并且在逻辑上可以看成多个服务器。

### 通信数据转发

#### 1. 代理

作用：代理服务器**转发客户端的请求给其它服务器**。

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为**正向代理**和**反向代理**：

- **正向代理**代理的对象是客户端，或者说 正向代理**隐藏真实客户端**。
- **反向代理**代理的对象是服务端，或者说 反向代理**隐藏真实服务端**。

#### 2. 网关

网关服务器会将 **HTTP协议 转化为其它协议**进行通信。

#### 3. 隧道

使用 **SSL** 等加密手段，在客户端和服务器之间进行**安全的通信**。

## 五、HTTPS

HTTP 有以下不足：

- 通信不加密，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

**HTTPS = HTTP + SSL**，HTTP 先和 SSL 通信，再由 SSL 和 TCP 通信，通过使用 SSL，HTTPS 具有了**加密**、**认证**和**完整性保护**这些功能。

### 加密

#### 1. 公钥密码体制

公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：

- 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。 
- 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。

公钥密码体制的公钥和算法都是公开的（这是为什么叫公钥密码体制的原因），私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。

#### 2. 对称密钥加密

对称密钥加密（Symmetric-Key Encryption），**加密和解密使用同一密钥**。

#### 3.非对称密钥加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），**加密和解密使用不同的密钥**。

#### 4. HTTPS 采用混合加密方式

使用**非对称密钥加密**的方式**传输密钥**，在获得到 密钥 后，使用**对称密钥加密**的方式进行**通信**。

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（**CA**，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器向 CA **申请公开密钥**，CA 在**证明服务器的身份**之后，会对申请的公开密钥做**数字签名**处理，并将该**公开密钥放入它的证书中**，最后返回这个公开密钥。

进行 HTTPS 通信时，服务器会把**证书**发送给客户端。客户端取得其中的公开密钥之后，先使用**数字签名**进行**验证**，如果**验证通过，就可以通信**。

签名：签名就是在*信息*的后面再加上一段内容，可以证明***\*信息\****没有被修改过，怎么样可以达到这个效果呢？一般是对***\*信息\****做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的***\*信息\****内容。

### 完整性保护

SSL 使用**报文摘要**功能来进行完整性保护。

### HTTPS 的缺点

- 因为需要进行加密解密等过程，因此**速度会更慢**；
- **证书授权会很花钱**。

## 六、HTTP 发展史

### HTTP/0.9

* 只有 GET 命令
* 服务器发送完毕，就关闭 TCP 连接。

### HTTP/1.0

* 增加**命令**，如：POST、PUT

* 增加**请求头、响应头、状态码**

* 增加**缓存**、**权限**、多字符集支持、多部分发送机制

### HTTP/1.1

* 默认是 **持久连接**
* 支持 **管线化**

* 增加 **cookie** 机制

* 支持 **同时打开多个 TCP 连接**
* 支持 **虚拟主机**

### HTTP/2.0

* 数据以 **二进制传输**
* **首部压缩**：压缩首部信息
* 服务端 **推送**
* **多路复用**技术

### HTTP/3.0

* 采用 **UDP 协议**
* **QUIC 协议**，可以做到 0 RTT 传输

## 七、GET 和 POST 区别

### 作用

* GET 用于**获取资源**。
* POST 用于**传输数据**。

### 参数

* GET 的参数是以查询**字符串**出现在 **URL** 中

* POST 的参数**存储在实体主体中**。

### 安全

* GET 方法是**安全**的。
* POST 方法**不安全** ，因为 **POST 会改变服务器状态。**

### 可缓存

- **请求报文的 HTTP 方法本身是可缓存的**，包括 **GET** 和 HEAD
- PUT 和 DELETE 不可缓存，**POST 在多数情况下不可缓存的**。

## 八、常见的 Web 攻击技术

### 1. XSS 攻击

跨站脚本攻击，XSS。

定义：使用非法的 **HTML 标签** 或 **JavaScript 脚本**，**以获得用户的 Cookie 或 重要信息**。

解决方法：设置 **HttpOnly**，**过滤特殊字符**。

### 2. SQL 注入攻击

定义：对 Web 连接的数据库**注入恶意的 SQL 语句**。

解决方法：**验证用户的输入**。

### 3. OS 命令注入攻击

定义：从 Web 应用中通过 **Shell** 来执行**操作系统命令**。

解决方法：不调用 OS 命令，使用 Java JDBC中的 **`PreparedStatement `预编译** 预防 SQL 注入。

### 4. CSRF 攻击

**跨站点请求伪造**攻击，CSRF（Cross-Site Request Forgeries）攻击。

定义：攻击者**盗用了用户的身份**，**以用户的名义发送恶意请求**。

解决方法：对请求进行**认证**，**确保该请求确实是用户本人**，具体可以**在 Session 中增加 token**。

### 5. DoS 攻击

**拒绝服务**攻击，DoS（Denial of Service attack）攻击。

定义：发生在三次握手的第三次，攻击者不发送ACK，使TCP连接挂起，浪费CPU资源。最后**发送大量请求使服务器瘫痪**。

### 6. DDoS 攻击

**分布式拒绝服务**攻击，DDoS（Distributed Denial of Service attack）攻击。

定义：使用多台计算机，对目标进行 DoS攻击。

在 DoS 攻击 的基础上，在**公共网络**上，**借助多台计算机，向目标进行攻击**。

解决方法：**检测**技术和**清洗**技术，检测技术就是**检测网站是否正在遭受 DDoS 攻击**，而清洗技术就是**清洗掉异常流量**。